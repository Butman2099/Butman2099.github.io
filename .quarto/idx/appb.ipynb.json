{"title":"Вступ до мови програмування Python","markdown":{"yaml":{"title":"Вступ до мови програмування Python"},"headingText":"Коментарі коду","containsRefs":false,"markdown":"\n\n\n\n\n\n\n\nКоментар --- це примітка, зроблена програмістом у вихідному коді програми. Його мета --- прояснити вихідний код і полегшити людям відстеження того, що відбувається. Все, що міститься в коментарі, зазвичай ігнорується при фактичному запуску коду, що робить коментарі корисними для включення пояснень і міркувань, а також для видалення певних рядків коду, в яких ви можете бути не впевнені. Коментарі в Python створюються за допомогою символу решітуи (`# вставити текст тут`). Включення `#` у рядок коду коментує все, що слідує за ним.\n\nВи можете побачити текст, укладений у потрійні лапки (`\"\"\" вставте текст тут \"\"\"`). Такий синтаксис представлятиме багаторядкове коментування, але це не зовсім точно. Це особливий тип `string` (тип даних, який ми розглянемо), який називається` docstring`, який використовується для пояснення призначення функції.\n\nПереконайтеся, що Ви прочитали коментарі в кожній комірці коду (якщо вони там є). Вони нададуть більш детальні пояснення того, що відбувається в режимі реального часу, коли ви переглядаєте кожен рядок коду.\n\n## Змінна\n\nЗмінні надають імена для значень. Якщо ви хочете зберегти значення для подальшого або повторного використання, ви присвоюєте значенню ім'я, зберігаючи вміст у змінній. Змінні в програмуванні працюють принципово аналогічно змінним в алгебрі, але в Python вони можуть приймати різні типи даних.\n\nОсновними типами змінних, які ми розглянемо в цьому розділі, є `цілі числа`, `числа з плаваючою комою`, `логічні значення` та `рядки`.\n\n`Ціле число` у програмуванні - це те саме, що і в математиці, кругле число без значень після десяткової коми. Ми використовуємо вбудовану функцію `print()` тут для відображення значень наших змінних, а також їх типів!\n\nЗмінні, незалежно від типу, призначаються за допомогою одного знака рівності (`=`). Змінні чутливі до регістру, тому будь-які зміни в зміні заголовних літер імені змінної будуть посилатися повністю на іншу змінну.\n\nЧисло з плаваючою комою або `float` - це вигадлива назва дійсного числа (знову ж таки, як у математиці). Щоб визначити `float`, нам потрібно або включити десяткову крапку, або вказати, що значення є float.\n\nЗмінна типу `float` не округлятиме число, яке ви в ній зберігаєте, тоді як змінна типу `integer` округлятиме. Це робить `floats` більш придатними для математичних обчислень, де потрібно більше, ніж просто цілі числа.\n\nЗверніть увагу, що оскільки ми використовували функцію `float()`, щоб змусити число рахуватися `float`, ми можемо використовувати функцію `int()`, щоб змусити число представлятися в типі `int`.\n\nФункція `int()` також усіче будь-які цифри, які число може містити після десяткової коми!\n\nРядки дозволяють включати текст як змінну для роботи. Вони визначаються з використанням або одинарних лапок (''), або подвійних лапок (\"\").\n\nОбидва варіанти дозволені, так що ми можемо включити апострофи або лапки в рядок, якщо ми того побажаємо.\n\nЛогічні значення, або `bools`, - це двійкові типи змінних. `bool` може приймати лише одне з двох значень, це `True` або `False`. У цій ідеї істинних значень є набагато більше, коли мова заходить про програмування, про що ми розповімо пізніше в розділі [Логічні оператори](#id-section5) цього зошита.\n\nІснує ще багато типів даних, які ви можете призначити змінними в Python, але це основні з них! Ми розглянемо ще трохи пізніше, коли будемо просуватися по цьому блокноту.\n\n## Базова математика\n\nPython має ряд вбудованих математичних функцій. Їх можна ще більше розширити, імпортуючи пакет **math** або включивши будь-яку кількість інших обчислювальних пакетів.\n\nПідтримуються всі основні арифметичні операції: `+`, `-`, `/`, і `*`. Ви можете створювати експоненти за допомогою `**`, а модульна арифметика вводиться за допомогою оператора mod, `%`.\n\nЯкщо ви не знайомі з оператором mod, він працює як функція залишку. Якщо ми введемо $15 \\ \\% \\  4$, він поверне залишок після ділення $15$ на $4$.\n\nМатематичні функції також працюють зі змінними!\n\nПереконайтеся, що ваші змінні є плаваючими, якщо ви хочете, щоб у вашій відповіді були десяткові крапки. Якщо ви виконуєте математику виключно з цілими числами, Ви отримуєте ціле число. Включення будь-якого значення з плаваючою точкою в обчислення зробить результат плаваючим.\n\nPython має кілька вбудованих математичних функцій. Найбільш помітними з них є:\n\n* `abs()`\n* `round()`\n* `max()`\n* `min()`\n* `sum()`\n\nУсі ці функції діють так, як ви очікували, враховуючи їх назви. Виклик `abs()` для числа поверне його абсолютне значення. Функція `round()` округлить число до вказаної кількості десяткових знаків (значення за замовчуванням дорівнює $0$). Виклик `max()` або `min()` для набору чисел поверне, відповідно, максимальне або мінімальне значення в наборі. Виклик `sum()` для набору чисел призведе до їх підсумовування. Якщо ви не знайомі з тим, як працюють колекції значень у Python, не хвилюйтеся! Ми детально розглянемо набір в наступному розділі.\n\nДодаткові математичні функції можуть бути додані разом з пакетом `math`.\n\nМатематична бібліотека додає довгий список нових математичних функцій до Python. Не соромтеся ознайомитися з [документацією](https://docs.python.org/3/library/math.html) для отримання повного списку та деталей. У ньому полягають деякі математичні константи\n\nА також деякі часто використовувані математичні функції\n\n## Колекції\n### Списки (lists)\n\n`Список` у Python - це впорядкована колекція об'єктів, яка може містити будь-який тип даних. Ми визначаємо `список`, використовуючи квадратні дужки (`[]`).\n\nМи також можемо отримати доступ до списку та проіндексувати його за допомогою дужок. Щоб вибрати окремий елемент, просто введіть назву списку, а потім індекс елемента, який ви шукаєте, у фігурних дужках.\n\nІндексація в Python починається з $ 0$. Якщо у вас є список довжиною $n$, перший елемент списку знаходиться з індексом $0$, другий елемент з індексом $1$, і так далі, і тому подібне. Останній елемент списку матиме індекс $n-1$. Будьте обережні! Спроба отримати доступ до неіснуючого індексу призведе до помилки.\n\nМи можемо побачити кількість елементів у списку, викликавши функцію `len()`.\n\nМи можемо оновлювати та змінювати список, отримуючи доступ до індексу та призначаючи нове значення.\n\nЦе принципово відрізняється від того, як обробляються рядки. `Список` є змінним, що означає, що ви можете змінювати елементи `списку` без зміни самого списку. Деякі типи даних, такі як `рядки`, є незмінними, що означає, що ви взагалі не можете їх змінити. Як тільки `рядок` або інший незмінний тип даних був створений, він не може бути безпосередньо змінений без створення абсолютно нового об'єкта.\n\nЯк ми вже говорили раніше, список може містити будь-який тип даних. Таким чином, списки також можуть містити рядки.\n\nСписки також можуть містити кілька різних типів даних одночасно!\n\nЯкщо ви хочете об'єднати два списки, їх можна об'єднати символом `+`.\n\nОкрім доступу до окремих елементів списку, ми можемо отримати доступ до груп елементів за допомогою зрізу.\n\n#### Зріз (slicing)\n\nМи використовуємо двокрапку (`:`) для нарізки списків.\n\nВикористовуючи `:`, ми можемо вибрати групу елементів у списку, починаючи з першого вказаного елемента і закінчуючи (але не включаючи) останнім зазначеним елементом.\n\nМи також можемо вибрати все після певного значення\n\nІ все перед конкретним значенням\n\nВикористання негативних чисел буде відлічуватися з кінця індексів, а не з початку. Наприклад, індекс `-1` вказує на останній елемент списку.\n\nВи також можете додати третій компонент для нарізки. Замість того, щоб просто вказати першу та кінцеву частини вашого зрізу, ви можете вказати розмір кроку, який ви хочете зробити. Таким чином, замість того, щоб брати кожен окремий елемент, ви можете взяти будь-який інший елемент.\n\nТут ми вибрали весь список (оскільки `0:7` дасть елементи від `0` до `6`), і ми вибрали розмір кроку `2`. Отже, це виведе елемент `0`, елемент `2`, елемент `4` тощо на вибраний елемент списку. Ми можемо пропустити вказаний початок і кінець нашого фрагмента, вказавши лише крок, якщо хочемо.\n\nСписки неявно вибирають початок і кінець списку, якщо не вказано інше.\n\nПри негативному розмірі кроку ми можемо навіть перевернути список!\n\nPython не має власних матриць. Інші пакети, такі як `numpy`, додають матриці як окремий тип даних, але в базовому Python найкращим способом створення матриці є використання списку списків.\n\nМи також можемо використовувати вбудовані функції для створення списків. Зокрема, ми розглянемо `range()` (тому що ми будемо використовувати його пізніше!). Діапазон може приймати кілька різних вхідних даних і поверне список.\n\nПодібно до наших попередніх методів нарізки списків, ми можемо визначити як початок, так і кінець нашого діапазону. Це поверне список, який включає початок і виключає кінець, точно так само, як зріз.\n\nМи також можемо вказати розмір кроку. Це знову має таку ж поведінку, як і зріз.\n\n### Кортежі (Tuples)\n\n`Кортеж` - це тип даних, подібний до списку в тому сенсі, що він може містити різні типи даних. Ключова відмінність тут полягає в тому, що `кортеж` є незмінним. Ми визначаємо `кортеж`, розділяючи елементи, які ми хочемо включити комами. Зазвичай `кортеж` укладають в круглі дужки.\n\nЯк згадувалося раніше, кортежі незмінні. Ви не можете змінити будь-яку їх частину, не визначивши новий кортеж.\n\nВи можете нарізати кортежі так само, як ви нарізаєте списки!\n\nІ об'єднайте їх так, як Ви б це зробили з рядками!\n\nМи можемо `упакувати` значення разом, створивши кортеж (як зазначено вище), або ми можемо `розпакувати` значення з кортежу, витягуючи їх.\n\nРозпакування присвоює кожне значення кортежу по порядку кожній змінній у лівій частині знака рівності. Деякі функції, включаючи спеціальні функції, можуть повертати кортежі, тому ми можемо використовувати це, щоб безпосередньо розпакувати їх і отримати доступ до потрібних нам значень.\n\n### Множини (Sets)\n\n`Множини` - це набір невпорядкованих, унікальних елементів. Він працює майже точно так, як ви очікували б від звичайного набору математичних задач, і визначається за допомогою фігурних дужок (`{}`).\n\nЗверніть увагу, як будь-які додаткові екземпляри одного і того ж елемента видаляються в остаточному наборі. Ми також можемо створити `множину` зі списку, використовуючи функцію `set()`.\n\nВиклик `len()` для множини повідомить вам, скільки в ньому елементів.\n\nОскільки `множина` представляє невпорядковану структуру даних, ми не можемо отримати доступ до окремих елементів за допомогою індексу. Однак ми можемо легко перевірити приналежність (щоб побачити, чи міститься щось у наборі) та використовувати об'єднання та перетини множин за допомогою вбудованих функцій set.\n\nТут ми перевірили, чи міститься рядок `cats` у нашому `animal_set`, і він повернув `True`, повідомивши нам, що він насправді знаходиться в нашому наборі.\n\nМи можемо з'єднати множини, використовуючи типові математичні оператори множин, а саме `|` для об'єднання та `&` для перетину. Використання `|` або `&` поверне саме те, що ви очікували б, якщо Ви знайомі з множинами в математиці.\n\nСполучення двох наборів за допомогою `|` об'єднує множини, видаляючи будь-які повторення, щоб зробити кожен елемент набору унікальним.\n\nСполучення двох наборів за допомогою `&` обчислює перетин обох наборів, повертаючи набір, який містить лише те, що вони мають спільне.\n\nЯкщо вам цікаво дізнатися більше про вбудовані функції для наборів, не соромтеся ознайомитися з [документацією](https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset).\n\n### Словники (Dictionaries)\n\nЩе однією важливою структурою даних у Python є словник. Словники визначаються за допомогою комбінації фігурних дужок (`{}`) і двокрапок (`:`). Фігурні дужки визначають початок і кінець словника, а двокрапки вказують пари ключ-значення. Словник - це, по суті, набір пар ключ-значення. Ключ будь-якого запису повинен бути незмінним типом даних. Це робить кандидатами як рядки, так і кортежі. Ключі можуть бути як додані, так і видалені.\n\nУ наступному прикладі ми маємо словник, що складається з пар ключ-значення, де ключовим є жанр художньої літератури (`рядок`), а значенням є список книг (`list`) у цьому жанрі. Оскільки колекція все ще вважається єдиною сутністю, ми можемо використовувати її для збору декількох змінних або значень в одну пару ключ-значення.\n\nПісля визначення словника ми можемо отримати доступ до будь-якого окремого значення, вказавши його ключ у дужках.\n\nМи також можемо змінити значення, пов'язане з даним ключем\n\nДодати нову пару ключ-значення так само просто, як і визначити її.\n\n## Рядки (Strings)\n\nМи вже знаємо, що рядки зазвичай використовуються для тексту. Ми можемо використовувати вбудовані операції для легкого об'єднання, розділення та форматування рядків, залежно від наших потреб.\n\nСимвол `+` вказує на конкатенацію мовою рядків. Це об'єднає два рядки в довший рядок.\n\nРядки також індексуються приблизно так само, як і списки.\n\nВбудовані об'єкти та класи часто мають пов'язані з ними спеціальні функції, які називаються методами. Ми отримуємо доступ до цих методів, використовуючи точку ('.'). Ми детальніше розглянемо об'єкти та пов'язані з ними методи в іншій лекції!\n\nВикористовуючи рядкові методи, ми можемо підраховувати екземпляри символу або групи символів.\n\nМи також можемо знайти перший екземпляр символу або групи символів у рядку.\n\nА також замінити символи в рядку.\n\nІснують також деякі методи, які є унікальними для рядків. Функція `upper()` перетворює всі символи в рядку в верхній регістр, в той час як `lower()` перетворює всі символи в рядку в нижній регістр!\n\n### Форматування рядків\n\nВикористовуючи метод `format()`, ми можемо додавати значення змінних і зазвичай форматувати наші рядки.\n\nМи використовуємо фігурні дужки (`{}`) для позначення частин рядка, які будуть заповнені пізніше, і ми використовуємо аргументи функції `format()` для надання значень для заміни. Цифри у фігурних дужках вказують індекс значення в аргументах `format()`.\n\nДивіться `format()` [документація](https://docs.python.org/3/library/string.html#format-examples) для отримання додаткових прикладів.\n\n\nЯкщо вам потрібне швидке та брудне форматування, ви можете замість цього використовувати символ`%`, який називається оператором форматування рядка.\n\nСимвол `%` в основному вказує Python на створення заповнювача. Будь-який символ, що слідує за `%` (у рядку), вказує, який тип матиме значення, введене в заповнювач. Цей символ називається *типом перетворення*. Після закриття рядка нам знадобиться ще один `%`, за яким слідують значення для вставки. У випадку одного значення ви можете просто помістити його туди. Якщо ви вставляєте більше одного значення, вони повинні бути укладені в кортеж.\n\nУ цих прикладах `%s` вказує, що Python повинен перетворити значення в рядки. Існує кілька типів перетворення, які ви можете використовувати, щоб уточнити форматування. Дивіться [форматування рядка](https://docs.python.org/3/library/stdtypes.html#string-formatting) для отримання додаткових прикладів та більш повної інформації про використання.\n\n## Логічні оператори\n### Базова логіка\n\nЛогічні оператори мають справу з `булевими` значеннями, як ми коротко розглянули раніше. Якщо ви пам'ятаєте, `bool` приймає одне з двох значень: `True` або `False` (або $1$ або $0$). Основні логічні твердження, які ми можемо зробити, визначаються за допомогою вбудованих компараторів. Це `==` (дорівнює), `!= ` (не дорівнює), `<` (Менше), `>` (Більше), `<= ` (менше або дорівнює) і `>=` (більше або дорівнює).\n\nЦі компаратори також працюють у поєднанні зі змінними.\n\nМи можемо зв'язати ці компаратори разом, щоб створити більш складні логічні оператори, використовуючи логічні оператори `or`, `and` і `not`.\n\nОператор `or` виконує логічне обчислення `або`. Будь-який компонент, об'єднаний за допомогою `або`, що є `True`, представлятиме все твердження як `True`. Оператор `and` виводить `True`, лише якщо всі компоненти разом є `True`. В іншому випадку він видасть `False`. Твердження `not` просто інвертує значення істинності будь-якого наступного за ним твердження. Таким чином, твердження `True` буде оцінено як `False`, коли перед ним буде поставлено `not`. Аналогічно, `False` твердження стане `True`, коли перед ним буде стояти `not`.\n\nПрипустимо, у нас є два логічні твердження, $P$ і $Q$. Таблиця істинності для основних логічних операторів виглядає наступним чином:\n\n|  P  |  Q  | `not` P| P `and` Q | P `or` Q|\n|:-----:|:-----:|:---:|:---:|:---:|\n| `True` | `True` | `False` | `True` | `True` |\n| `False` | `True` | `True` | `False` | `True` |\n| `True` | `False` | `False` | `False` | `True` |\n| `False` | `False` | `True` | `False` | `False` |\n\nМи можемо зв'язати кілька логічних операторів разом, використовуючи логічні оператори.\n\nЛогічні твердження можуть бути настільки простими або складними, наскільки нам подобається, залежно від того, що нам потрібно висловити. Оцінюючи наведене вище логічне твердження крок за кроком, ми бачимо, що ми оцінюємо (`True and True`) `or` (`False and not False`). Дана конструкція набуваж вигляду `True or (False and True`). Згодом стає `True or False`, і в кінцевому рахунку оцінюється як `True`.\n\n#### Істинність\n\nТипи даних у Python мають цікаву характеристику, яка називається істинністю. Це означає, що більшість вбудованих типів будуть оцінюватися як `True` або `False`, коли потрібне логічне значення (наприклад, за допомогою оператора if). Як правило, контейнери, такі як рядки, кортежі, словники, списки та множини, повертають `True`, якщо вони взагалі що-небудь містять, і `False`, якщо вони нічого не містять.\n\nІ так далі, для інших колекцій та контейнерів. `None` також оцінюється як `False`. Число `1` еквівалентно `True`, а число `0` також еквівалентно `False` в логічному контексті.\n\n### If-оператори\n\nМи можемо створювати сегменти коду, які виконуються тільки при виконанні набору умов. Ми використовуємо оператори if у поєднанні з логічними операторами для створення розгалужень у нашому коді.\n\nБлок `if` вводиться, коли умова вважається `True`. Якщо умова оцінюється як `False`, блок `if` буде просто пропущений, якщо тільки до нього не додається блок `else`. Умови створюються за допомогою логічних операторів або за допомогою істинності значень у Python. Оператор if визначається двокрапкою і блоком тексту з відступом.\n\nОскільки в цьому прикладі `i = 4` і оператор if шукає лише те, чи `i = 5`, оператор print ніколи не буде виконаний. Ми можемо додати оператор `else`, щоб створити блок коду на випадок надзвичайних ситуацій на випадок, якщо умова в операторі if не буде оцінена як `True`.\n\nМи можемо реалізувати інші гілки від того самого оператора if, використовуючи `elif`, скорочення від `else if`. Ми можемо включати стільки `elifсів`, скільки захочемо, поки не вичерпаємо всі логічні гілки умови.\n\nВи також можете вкласти оператори if в інші оператори if, щоб перевірити наявність додаткових умов.\n\nПам'ятайте, що ми можемо згрупувати кілька умов разом, використовуючи логічні оператори!\n\nВи можете використовувати логічні компаратори для порівняння рядків!\n\nЯк і у випадку з іншими типами даних, `==` перевірить, чи дві речі з обох сторін мають однакове значення.\n\nДеякі вбудовані функції повертають логічне значення, тому їх можна використовувати як умови в операторі if. Користувацькі функції також можуть бути сконструйовані таким чином, щоб вони повертали логічне значення. Це буде розглянуто пізніше в розділі визначення функції!\n\nКлючове слово `in` зазвичай використовується для перевірки приналежності значення до іншого значення. Ми можемо перевірити приналежність у контексті оператора if і використовувати його для виведення значення істини.\n\nТут ми використовуємо `in`, щоб перевірити, чи містить змінна `my_string` містить якісь конкретні літери. Пізніше ми будемо використовувати `in` для перебору списків!\n\n## Циклічні структури\n\nЦиклічні структури є однією з найважливіших частин програмування. Цикл `for` і цикл `while` надають спосіб багаторазового запуску блоку коду повторно. Цикл `while` буде повторюватися, поки не буде виконана певна умова. Якщо в будь-який момент після ітерації ця умова більше не виконується, цикл завершується. Цикл `for` буде виконувати ітерацію по послідовності значень і завершиться, коли послідовність закінчиться. Натомість ви можете включити умови в цикл `for`, щоб вирішити, чи повинен він закінчуватися достроково, чи ви можете просто дозволити йому піти своїм шляхом.\n\nЗа допомогою циклів `while` нам потрібно переконатися, що щось насправді змінюється від ітерації до ітерації, щоб цикл фактично закінчувався. У цьому випадку ми використовуємо скорочення `i -= 1` (скорочення від `i = i - 1`), так що значення `i` стає меншим з кожною ітерацією. Врешті-решт `i` буде зменшено до `0`, що призведе до виконання умови `False` та виходу з циклу.\n\nЦикл `for` повторюється задану кількість разів, що визначається при вказівці запису в цикл. У цьому випадку ми повторюємо список, повернутий з `range()`. Цикл `for` вибирає значення зі списку по порядку і тимчасово присвоює йому значення `i`, щоб із цим значенням можна було виконувати операції.\n\nЗверніть увагу, що в цьому циклі `for` ми використовуємо ключове слово `in`. Використання ключового слова `in` не обмежується перевіркою приналежності, як у прикладі if-конструкцій. Ви можете оброблювати будь-яку колекцію за допомогою циклу `for`, використовуючи ключове слово `in`.\n\nУ цьому наступному прикладі ми переглянемо `множину`, оскільки хочемо перевірити наявність вмісту та додати до нового набору.\n\nЄ два твердження, які дуже корисні при роботі як з циклами `for`, так і з циклами `while`. Це `break` і `continue`. Якщо `break` трапляється в будь-який момент під час виконання циклу, цикл негайно завершується.\n\nОператор `continue` вкаже циклу негайно завершити цю ітерацію і перейти до наступної ітерації циклу.\n\nЦей цикл пропускає друк числа $3$ через інструкцію `continue`, яка виконується, коли ми вводимо оператор if. Код ніколи не бачить команди для друку числа $3$, оскільки він уже перейшов до наступної ітерації.\n\nЗмінна, яку ми використовуємо для ітерації циклу, збереже своє значення при завершенні циклу. Аналогічно, будь-які змінні, визначені в контексті циклу, продовжуватимуть існувати поза ним.\n\nМи також можемо виконувати ітерації по словнику!\n\nЯкщо ми просто перебираємо словник, не роблячи нічого іншого, ми отримуємо лише ключі. Ми можемо або використовувати ключі для отримання значень, як у прикладі:\n\nАбо ми можемо використовувати функцію `items()`, щоб отримати і ключ, і значення одночасно\n\nФункція `items` створює кортеж з кожної пари ключ-значення, а цикл for розпаковує цей кортеж в `ключ, значення` при кожному окремому виконанні циклу!\n\n## Функції\n\nФункція-це багаторазовий блок коду, який ви можете викликати повторно для виконання обчислень, виведення даних або дійсно робити все, що завгодно. Це один з ключових аспектів використання мови програмування. Щоб додати до вбудованих функцій у Python, ви можете визначити свої власні!\n\nФункції визначаються за допомогою `def`, імені функції, списку параметрів та двокрапки. Все, що вказано з відступом нижче двокрапки, буде включено у визначення функції.\n\nМи можемо змусити наші функції робити все, що ви можете зробити зі звичайним блоком коду. Наприклад, наша функція `hello_world()` виводить рядок при кожному його виклику. Якщо ми хочемо зберегти значення, обчислене функцією, ми можемо визначити функцію так, щоб вона `return` потрібне нам значення. Це дуже важлива особливість функцій, оскільки будь-яка змінна, визначена виключно всередині функції, не буде існувати поза нею.\n\n**Область** змінної - це частина блоку коду, де ця змінна прив'язана до певного значення. Функції в Python мають закриту область дії, що робить можливим прямий доступ до змінних лише всередині цих областей. Якщо ми передамо ці значення оператору return, ми можемо отримати їх із функції.\n\nТак само, як ми можемо отримувати значення з функції, ми також можемо розміщувати значення у функції. Ми робимо це, визначаючи нашу функцію з параметрами.\n\nУ цьому прикладі у нас був лише один параметр для нашої функції, `x`. Ми можемо легко додати додаткові параметри, розділивши всі комою.\n\nЯкщо ми хочемо, ми можемо визначити функцію так, щоб вона приймала довільну кількість параметрів. Ми повідомляємо Python, що хочемо цього, використовуючи зірочку (`*`).\n\nВи використовуєте `*args` як параметр для вашої функції - це коли ви не знаєте, скільки значень можна передати в неї, як у випадку з нашою функцією sum. Зірочка в даному випадку - це синтаксис, який повідомляє Python, що ви збираєтеся передати довільну кількість параметрів у свою функцію. Ці параметри зберігаються у вигляді кортежу.\n\nНаші функції можуть повертати будь-який тип даних. Це дозволяє нам легко створювати функції, які перевіряють умови, які ми можемо захотіти відстежувати.\n\nТут ми визначаємо функцію, яка повертає логічне значення. Ми можемо легко використовувати це в поєднанні з операторами if та іншими ситуаціями, які потребують логічного значення.\n\nЦя наведена вище функція повертає впорядковану пару вхідних параметрів, збережених як кортеж.\n\n## Подальші кроки\n\nЯкщо ви хочете глибше заглибитися в матеріал, тоді зверніться до [документації по Python](https://docs.python.org/3/index.html).\n","srcMarkdownNoYaml":"\n\n\n\n\n\n\n## Коментарі коду\n\nКоментар --- це примітка, зроблена програмістом у вихідному коді програми. Його мета --- прояснити вихідний код і полегшити людям відстеження того, що відбувається. Все, що міститься в коментарі, зазвичай ігнорується при фактичному запуску коду, що робить коментарі корисними для включення пояснень і міркувань, а також для видалення певних рядків коду, в яких ви можете бути не впевнені. Коментарі в Python створюються за допомогою символу решітуи (`# вставити текст тут`). Включення `#` у рядок коду коментує все, що слідує за ним.\n\nВи можете побачити текст, укладений у потрійні лапки (`\"\"\" вставте текст тут \"\"\"`). Такий синтаксис представлятиме багаторядкове коментування, але це не зовсім точно. Це особливий тип `string` (тип даних, який ми розглянемо), який називається` docstring`, який використовується для пояснення призначення функції.\n\nПереконайтеся, що Ви прочитали коментарі в кожній комірці коду (якщо вони там є). Вони нададуть більш детальні пояснення того, що відбувається в режимі реального часу, коли ви переглядаєте кожен рядок коду.\n\n## Змінна\n\nЗмінні надають імена для значень. Якщо ви хочете зберегти значення для подальшого або повторного використання, ви присвоюєте значенню ім'я, зберігаючи вміст у змінній. Змінні в програмуванні працюють принципово аналогічно змінним в алгебрі, але в Python вони можуть приймати різні типи даних.\n\nОсновними типами змінних, які ми розглянемо в цьому розділі, є `цілі числа`, `числа з плаваючою комою`, `логічні значення` та `рядки`.\n\n`Ціле число` у програмуванні - це те саме, що і в математиці, кругле число без значень після десяткової коми. Ми використовуємо вбудовану функцію `print()` тут для відображення значень наших змінних, а також їх типів!\n\nЗмінні, незалежно від типу, призначаються за допомогою одного знака рівності (`=`). Змінні чутливі до регістру, тому будь-які зміни в зміні заголовних літер імені змінної будуть посилатися повністю на іншу змінну.\n\nЧисло з плаваючою комою або `float` - це вигадлива назва дійсного числа (знову ж таки, як у математиці). Щоб визначити `float`, нам потрібно або включити десяткову крапку, або вказати, що значення є float.\n\nЗмінна типу `float` не округлятиме число, яке ви в ній зберігаєте, тоді як змінна типу `integer` округлятиме. Це робить `floats` більш придатними для математичних обчислень, де потрібно більше, ніж просто цілі числа.\n\nЗверніть увагу, що оскільки ми використовували функцію `float()`, щоб змусити число рахуватися `float`, ми можемо використовувати функцію `int()`, щоб змусити число представлятися в типі `int`.\n\nФункція `int()` також усіче будь-які цифри, які число може містити після десяткової коми!\n\nРядки дозволяють включати текст як змінну для роботи. Вони визначаються з використанням або одинарних лапок (''), або подвійних лапок (\"\").\n\nОбидва варіанти дозволені, так що ми можемо включити апострофи або лапки в рядок, якщо ми того побажаємо.\n\nЛогічні значення, або `bools`, - це двійкові типи змінних. `bool` може приймати лише одне з двох значень, це `True` або `False`. У цій ідеї істинних значень є набагато більше, коли мова заходить про програмування, про що ми розповімо пізніше в розділі [Логічні оператори](#id-section5) цього зошита.\n\nІснує ще багато типів даних, які ви можете призначити змінними в Python, але це основні з них! Ми розглянемо ще трохи пізніше, коли будемо просуватися по цьому блокноту.\n\n## Базова математика\n\nPython має ряд вбудованих математичних функцій. Їх можна ще більше розширити, імпортуючи пакет **math** або включивши будь-яку кількість інших обчислювальних пакетів.\n\nПідтримуються всі основні арифметичні операції: `+`, `-`, `/`, і `*`. Ви можете створювати експоненти за допомогою `**`, а модульна арифметика вводиться за допомогою оператора mod, `%`.\n\nЯкщо ви не знайомі з оператором mod, він працює як функція залишку. Якщо ми введемо $15 \\ \\% \\  4$, він поверне залишок після ділення $15$ на $4$.\n\nМатематичні функції також працюють зі змінними!\n\nПереконайтеся, що ваші змінні є плаваючими, якщо ви хочете, щоб у вашій відповіді були десяткові крапки. Якщо ви виконуєте математику виключно з цілими числами, Ви отримуєте ціле число. Включення будь-якого значення з плаваючою точкою в обчислення зробить результат плаваючим.\n\nPython має кілька вбудованих математичних функцій. Найбільш помітними з них є:\n\n* `abs()`\n* `round()`\n* `max()`\n* `min()`\n* `sum()`\n\nУсі ці функції діють так, як ви очікували, враховуючи їх назви. Виклик `abs()` для числа поверне його абсолютне значення. Функція `round()` округлить число до вказаної кількості десяткових знаків (значення за замовчуванням дорівнює $0$). Виклик `max()` або `min()` для набору чисел поверне, відповідно, максимальне або мінімальне значення в наборі. Виклик `sum()` для набору чисел призведе до їх підсумовування. Якщо ви не знайомі з тим, як працюють колекції значень у Python, не хвилюйтеся! Ми детально розглянемо набір в наступному розділі.\n\nДодаткові математичні функції можуть бути додані разом з пакетом `math`.\n\nМатематична бібліотека додає довгий список нових математичних функцій до Python. Не соромтеся ознайомитися з [документацією](https://docs.python.org/3/library/math.html) для отримання повного списку та деталей. У ньому полягають деякі математичні константи\n\nА також деякі часто використовувані математичні функції\n\n## Колекції\n### Списки (lists)\n\n`Список` у Python - це впорядкована колекція об'єктів, яка може містити будь-який тип даних. Ми визначаємо `список`, використовуючи квадратні дужки (`[]`).\n\nМи також можемо отримати доступ до списку та проіндексувати його за допомогою дужок. Щоб вибрати окремий елемент, просто введіть назву списку, а потім індекс елемента, який ви шукаєте, у фігурних дужках.\n\nІндексація в Python починається з $ 0$. Якщо у вас є список довжиною $n$, перший елемент списку знаходиться з індексом $0$, другий елемент з індексом $1$, і так далі, і тому подібне. Останній елемент списку матиме індекс $n-1$. Будьте обережні! Спроба отримати доступ до неіснуючого індексу призведе до помилки.\n\nМи можемо побачити кількість елементів у списку, викликавши функцію `len()`.\n\nМи можемо оновлювати та змінювати список, отримуючи доступ до індексу та призначаючи нове значення.\n\nЦе принципово відрізняється від того, як обробляються рядки. `Список` є змінним, що означає, що ви можете змінювати елементи `списку` без зміни самого списку. Деякі типи даних, такі як `рядки`, є незмінними, що означає, що ви взагалі не можете їх змінити. Як тільки `рядок` або інший незмінний тип даних був створений, він не може бути безпосередньо змінений без створення абсолютно нового об'єкта.\n\nЯк ми вже говорили раніше, список може містити будь-який тип даних. Таким чином, списки також можуть містити рядки.\n\nСписки також можуть містити кілька різних типів даних одночасно!\n\nЯкщо ви хочете об'єднати два списки, їх можна об'єднати символом `+`.\n\nОкрім доступу до окремих елементів списку, ми можемо отримати доступ до груп елементів за допомогою зрізу.\n\n#### Зріз (slicing)\n\nМи використовуємо двокрапку (`:`) для нарізки списків.\n\nВикористовуючи `:`, ми можемо вибрати групу елементів у списку, починаючи з першого вказаного елемента і закінчуючи (але не включаючи) останнім зазначеним елементом.\n\nМи також можемо вибрати все після певного значення\n\nІ все перед конкретним значенням\n\nВикористання негативних чисел буде відлічуватися з кінця індексів, а не з початку. Наприклад, індекс `-1` вказує на останній елемент списку.\n\nВи також можете додати третій компонент для нарізки. Замість того, щоб просто вказати першу та кінцеву частини вашого зрізу, ви можете вказати розмір кроку, який ви хочете зробити. Таким чином, замість того, щоб брати кожен окремий елемент, ви можете взяти будь-який інший елемент.\n\nТут ми вибрали весь список (оскільки `0:7` дасть елементи від `0` до `6`), і ми вибрали розмір кроку `2`. Отже, це виведе елемент `0`, елемент `2`, елемент `4` тощо на вибраний елемент списку. Ми можемо пропустити вказаний початок і кінець нашого фрагмента, вказавши лише крок, якщо хочемо.\n\nСписки неявно вибирають початок і кінець списку, якщо не вказано інше.\n\nПри негативному розмірі кроку ми можемо навіть перевернути список!\n\nPython не має власних матриць. Інші пакети, такі як `numpy`, додають матриці як окремий тип даних, але в базовому Python найкращим способом створення матриці є використання списку списків.\n\nМи також можемо використовувати вбудовані функції для створення списків. Зокрема, ми розглянемо `range()` (тому що ми будемо використовувати його пізніше!). Діапазон може приймати кілька різних вхідних даних і поверне список.\n\nПодібно до наших попередніх методів нарізки списків, ми можемо визначити як початок, так і кінець нашого діапазону. Це поверне список, який включає початок і виключає кінець, точно так само, як зріз.\n\nМи також можемо вказати розмір кроку. Це знову має таку ж поведінку, як і зріз.\n\n### Кортежі (Tuples)\n\n`Кортеж` - це тип даних, подібний до списку в тому сенсі, що він може містити різні типи даних. Ключова відмінність тут полягає в тому, що `кортеж` є незмінним. Ми визначаємо `кортеж`, розділяючи елементи, які ми хочемо включити комами. Зазвичай `кортеж` укладають в круглі дужки.\n\nЯк згадувалося раніше, кортежі незмінні. Ви не можете змінити будь-яку їх частину, не визначивши новий кортеж.\n\nВи можете нарізати кортежі так само, як ви нарізаєте списки!\n\nІ об'єднайте їх так, як Ви б це зробили з рядками!\n\nМи можемо `упакувати` значення разом, створивши кортеж (як зазначено вище), або ми можемо `розпакувати` значення з кортежу, витягуючи їх.\n\nРозпакування присвоює кожне значення кортежу по порядку кожній змінній у лівій частині знака рівності. Деякі функції, включаючи спеціальні функції, можуть повертати кортежі, тому ми можемо використовувати це, щоб безпосередньо розпакувати їх і отримати доступ до потрібних нам значень.\n\n### Множини (Sets)\n\n`Множини` - це набір невпорядкованих, унікальних елементів. Він працює майже точно так, як ви очікували б від звичайного набору математичних задач, і визначається за допомогою фігурних дужок (`{}`).\n\nЗверніть увагу, як будь-які додаткові екземпляри одного і того ж елемента видаляються в остаточному наборі. Ми також можемо створити `множину` зі списку, використовуючи функцію `set()`.\n\nВиклик `len()` для множини повідомить вам, скільки в ньому елементів.\n\nОскільки `множина` представляє невпорядковану структуру даних, ми не можемо отримати доступ до окремих елементів за допомогою індексу. Однак ми можемо легко перевірити приналежність (щоб побачити, чи міститься щось у наборі) та використовувати об'єднання та перетини множин за допомогою вбудованих функцій set.\n\nТут ми перевірили, чи міститься рядок `cats` у нашому `animal_set`, і він повернув `True`, повідомивши нам, що він насправді знаходиться в нашому наборі.\n\nМи можемо з'єднати множини, використовуючи типові математичні оператори множин, а саме `|` для об'єднання та `&` для перетину. Використання `|` або `&` поверне саме те, що ви очікували б, якщо Ви знайомі з множинами в математиці.\n\nСполучення двох наборів за допомогою `|` об'єднує множини, видаляючи будь-які повторення, щоб зробити кожен елемент набору унікальним.\n\nСполучення двох наборів за допомогою `&` обчислює перетин обох наборів, повертаючи набір, який містить лише те, що вони мають спільне.\n\nЯкщо вам цікаво дізнатися більше про вбудовані функції для наборів, не соромтеся ознайомитися з [документацією](https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset).\n\n### Словники (Dictionaries)\n\nЩе однією важливою структурою даних у Python є словник. Словники визначаються за допомогою комбінації фігурних дужок (`{}`) і двокрапок (`:`). Фігурні дужки визначають початок і кінець словника, а двокрапки вказують пари ключ-значення. Словник - це, по суті, набір пар ключ-значення. Ключ будь-якого запису повинен бути незмінним типом даних. Це робить кандидатами як рядки, так і кортежі. Ключі можуть бути як додані, так і видалені.\n\nУ наступному прикладі ми маємо словник, що складається з пар ключ-значення, де ключовим є жанр художньої літератури (`рядок`), а значенням є список книг (`list`) у цьому жанрі. Оскільки колекція все ще вважається єдиною сутністю, ми можемо використовувати її для збору декількох змінних або значень в одну пару ключ-значення.\n\nПісля визначення словника ми можемо отримати доступ до будь-якого окремого значення, вказавши його ключ у дужках.\n\nМи також можемо змінити значення, пов'язане з даним ключем\n\nДодати нову пару ключ-значення так само просто, як і визначити її.\n\n## Рядки (Strings)\n\nМи вже знаємо, що рядки зазвичай використовуються для тексту. Ми можемо використовувати вбудовані операції для легкого об'єднання, розділення та форматування рядків, залежно від наших потреб.\n\nСимвол `+` вказує на конкатенацію мовою рядків. Це об'єднає два рядки в довший рядок.\n\nРядки також індексуються приблизно так само, як і списки.\n\nВбудовані об'єкти та класи часто мають пов'язані з ними спеціальні функції, які називаються методами. Ми отримуємо доступ до цих методів, використовуючи точку ('.'). Ми детальніше розглянемо об'єкти та пов'язані з ними методи в іншій лекції!\n\nВикористовуючи рядкові методи, ми можемо підраховувати екземпляри символу або групи символів.\n\nМи також можемо знайти перший екземпляр символу або групи символів у рядку.\n\nА також замінити символи в рядку.\n\nІснують також деякі методи, які є унікальними для рядків. Функція `upper()` перетворює всі символи в рядку в верхній регістр, в той час як `lower()` перетворює всі символи в рядку в нижній регістр!\n\n### Форматування рядків\n\nВикористовуючи метод `format()`, ми можемо додавати значення змінних і зазвичай форматувати наші рядки.\n\nМи використовуємо фігурні дужки (`{}`) для позначення частин рядка, які будуть заповнені пізніше, і ми використовуємо аргументи функції `format()` для надання значень для заміни. Цифри у фігурних дужках вказують індекс значення в аргументах `format()`.\n\nДивіться `format()` [документація](https://docs.python.org/3/library/string.html#format-examples) для отримання додаткових прикладів.\n\n\nЯкщо вам потрібне швидке та брудне форматування, ви можете замість цього використовувати символ`%`, який називається оператором форматування рядка.\n\nСимвол `%` в основному вказує Python на створення заповнювача. Будь-який символ, що слідує за `%` (у рядку), вказує, який тип матиме значення, введене в заповнювач. Цей символ називається *типом перетворення*. Після закриття рядка нам знадобиться ще один `%`, за яким слідують значення для вставки. У випадку одного значення ви можете просто помістити його туди. Якщо ви вставляєте більше одного значення, вони повинні бути укладені в кортеж.\n\nУ цих прикладах `%s` вказує, що Python повинен перетворити значення в рядки. Існує кілька типів перетворення, які ви можете використовувати, щоб уточнити форматування. Дивіться [форматування рядка](https://docs.python.org/3/library/stdtypes.html#string-formatting) для отримання додаткових прикладів та більш повної інформації про використання.\n\n## Логічні оператори\n### Базова логіка\n\nЛогічні оператори мають справу з `булевими` значеннями, як ми коротко розглянули раніше. Якщо ви пам'ятаєте, `bool` приймає одне з двох значень: `True` або `False` (або $1$ або $0$). Основні логічні твердження, які ми можемо зробити, визначаються за допомогою вбудованих компараторів. Це `==` (дорівнює), `!= ` (не дорівнює), `<` (Менше), `>` (Більше), `<= ` (менше або дорівнює) і `>=` (більше або дорівнює).\n\nЦі компаратори також працюють у поєднанні зі змінними.\n\nМи можемо зв'язати ці компаратори разом, щоб створити більш складні логічні оператори, використовуючи логічні оператори `or`, `and` і `not`.\n\nОператор `or` виконує логічне обчислення `або`. Будь-який компонент, об'єднаний за допомогою `або`, що є `True`, представлятиме все твердження як `True`. Оператор `and` виводить `True`, лише якщо всі компоненти разом є `True`. В іншому випадку він видасть `False`. Твердження `not` просто інвертує значення істинності будь-якого наступного за ним твердження. Таким чином, твердження `True` буде оцінено як `False`, коли перед ним буде поставлено `not`. Аналогічно, `False` твердження стане `True`, коли перед ним буде стояти `not`.\n\nПрипустимо, у нас є два логічні твердження, $P$ і $Q$. Таблиця істинності для основних логічних операторів виглядає наступним чином:\n\n|  P  |  Q  | `not` P| P `and` Q | P `or` Q|\n|:-----:|:-----:|:---:|:---:|:---:|\n| `True` | `True` | `False` | `True` | `True` |\n| `False` | `True` | `True` | `False` | `True` |\n| `True` | `False` | `False` | `False` | `True` |\n| `False` | `False` | `True` | `False` | `False` |\n\nМи можемо зв'язати кілька логічних операторів разом, використовуючи логічні оператори.\n\nЛогічні твердження можуть бути настільки простими або складними, наскільки нам подобається, залежно від того, що нам потрібно висловити. Оцінюючи наведене вище логічне твердження крок за кроком, ми бачимо, що ми оцінюємо (`True and True`) `or` (`False and not False`). Дана конструкція набуваж вигляду `True or (False and True`). Згодом стає `True or False`, і в кінцевому рахунку оцінюється як `True`.\n\n#### Істинність\n\nТипи даних у Python мають цікаву характеристику, яка називається істинністю. Це означає, що більшість вбудованих типів будуть оцінюватися як `True` або `False`, коли потрібне логічне значення (наприклад, за допомогою оператора if). Як правило, контейнери, такі як рядки, кортежі, словники, списки та множини, повертають `True`, якщо вони взагалі що-небудь містять, і `False`, якщо вони нічого не містять.\n\nІ так далі, для інших колекцій та контейнерів. `None` також оцінюється як `False`. Число `1` еквівалентно `True`, а число `0` також еквівалентно `False` в логічному контексті.\n\n### If-оператори\n\nМи можемо створювати сегменти коду, які виконуються тільки при виконанні набору умов. Ми використовуємо оператори if у поєднанні з логічними операторами для створення розгалужень у нашому коді.\n\nБлок `if` вводиться, коли умова вважається `True`. Якщо умова оцінюється як `False`, блок `if` буде просто пропущений, якщо тільки до нього не додається блок `else`. Умови створюються за допомогою логічних операторів або за допомогою істинності значень у Python. Оператор if визначається двокрапкою і блоком тексту з відступом.\n\nОскільки в цьому прикладі `i = 4` і оператор if шукає лише те, чи `i = 5`, оператор print ніколи не буде виконаний. Ми можемо додати оператор `else`, щоб створити блок коду на випадок надзвичайних ситуацій на випадок, якщо умова в операторі if не буде оцінена як `True`.\n\nМи можемо реалізувати інші гілки від того самого оператора if, використовуючи `elif`, скорочення від `else if`. Ми можемо включати стільки `elifсів`, скільки захочемо, поки не вичерпаємо всі логічні гілки умови.\n\nВи також можете вкласти оператори if в інші оператори if, щоб перевірити наявність додаткових умов.\n\nПам'ятайте, що ми можемо згрупувати кілька умов разом, використовуючи логічні оператори!\n\nВи можете використовувати логічні компаратори для порівняння рядків!\n\nЯк і у випадку з іншими типами даних, `==` перевірить, чи дві речі з обох сторін мають однакове значення.\n\nДеякі вбудовані функції повертають логічне значення, тому їх можна використовувати як умови в операторі if. Користувацькі функції також можуть бути сконструйовані таким чином, щоб вони повертали логічне значення. Це буде розглянуто пізніше в розділі визначення функції!\n\nКлючове слово `in` зазвичай використовується для перевірки приналежності значення до іншого значення. Ми можемо перевірити приналежність у контексті оператора if і використовувати його для виведення значення істини.\n\nТут ми використовуємо `in`, щоб перевірити, чи містить змінна `my_string` містить якісь конкретні літери. Пізніше ми будемо використовувати `in` для перебору списків!\n\n## Циклічні структури\n\nЦиклічні структури є однією з найважливіших частин програмування. Цикл `for` і цикл `while` надають спосіб багаторазового запуску блоку коду повторно. Цикл `while` буде повторюватися, поки не буде виконана певна умова. Якщо в будь-який момент після ітерації ця умова більше не виконується, цикл завершується. Цикл `for` буде виконувати ітерацію по послідовності значень і завершиться, коли послідовність закінчиться. Натомість ви можете включити умови в цикл `for`, щоб вирішити, чи повинен він закінчуватися достроково, чи ви можете просто дозволити йому піти своїм шляхом.\n\nЗа допомогою циклів `while` нам потрібно переконатися, що щось насправді змінюється від ітерації до ітерації, щоб цикл фактично закінчувався. У цьому випадку ми використовуємо скорочення `i -= 1` (скорочення від `i = i - 1`), так що значення `i` стає меншим з кожною ітерацією. Врешті-решт `i` буде зменшено до `0`, що призведе до виконання умови `False` та виходу з циклу.\n\nЦикл `for` повторюється задану кількість разів, що визначається при вказівці запису в цикл. У цьому випадку ми повторюємо список, повернутий з `range()`. Цикл `for` вибирає значення зі списку по порядку і тимчасово присвоює йому значення `i`, щоб із цим значенням можна було виконувати операції.\n\nЗверніть увагу, що в цьому циклі `for` ми використовуємо ключове слово `in`. Використання ключового слова `in` не обмежується перевіркою приналежності, як у прикладі if-конструкцій. Ви можете оброблювати будь-яку колекцію за допомогою циклу `for`, використовуючи ключове слово `in`.\n\nУ цьому наступному прикладі ми переглянемо `множину`, оскільки хочемо перевірити наявність вмісту та додати до нового набору.\n\nЄ два твердження, які дуже корисні при роботі як з циклами `for`, так і з циклами `while`. Це `break` і `continue`. Якщо `break` трапляється в будь-який момент під час виконання циклу, цикл негайно завершується.\n\nОператор `continue` вкаже циклу негайно завершити цю ітерацію і перейти до наступної ітерації циклу.\n\nЦей цикл пропускає друк числа $3$ через інструкцію `continue`, яка виконується, коли ми вводимо оператор if. Код ніколи не бачить команди для друку числа $3$, оскільки він уже перейшов до наступної ітерації.\n\nЗмінна, яку ми використовуємо для ітерації циклу, збереже своє значення при завершенні циклу. Аналогічно, будь-які змінні, визначені в контексті циклу, продовжуватимуть існувати поза ним.\n\nМи також можемо виконувати ітерації по словнику!\n\nЯкщо ми просто перебираємо словник, не роблячи нічого іншого, ми отримуємо лише ключі. Ми можемо або використовувати ключі для отримання значень, як у прикладі:\n\nАбо ми можемо використовувати функцію `items()`, щоб отримати і ключ, і значення одночасно\n\nФункція `items` створює кортеж з кожної пари ключ-значення, а цикл for розпаковує цей кортеж в `ключ, значення` при кожному окремому виконанні циклу!\n\n## Функції\n\nФункція-це багаторазовий блок коду, який ви можете викликати повторно для виконання обчислень, виведення даних або дійсно робити все, що завгодно. Це один з ключових аспектів використання мови програмування. Щоб додати до вбудованих функцій у Python, ви можете визначити свої власні!\n\nФункції визначаються за допомогою `def`, імені функції, списку параметрів та двокрапки. Все, що вказано з відступом нижче двокрапки, буде включено у визначення функції.\n\nМи можемо змусити наші функції робити все, що ви можете зробити зі звичайним блоком коду. Наприклад, наша функція `hello_world()` виводить рядок при кожному його виклику. Якщо ми хочемо зберегти значення, обчислене функцією, ми можемо визначити функцію так, щоб вона `return` потрібне нам значення. Це дуже важлива особливість функцій, оскільки будь-яка змінна, визначена виключно всередині функції, не буде існувати поза нею.\n\n**Область** змінної - це частина блоку коду, де ця змінна прив'язана до певного значення. Функції в Python мають закриту область дії, що робить можливим прямий доступ до змінних лише всередині цих областей. Якщо ми передамо ці значення оператору return, ми можемо отримати їх із функції.\n\nТак само, як ми можемо отримувати значення з функції, ми також можемо розміщувати значення у функції. Ми робимо це, визначаючи нашу функцію з параметрами.\n\nУ цьому прикладі у нас був лише один параметр для нашої функції, `x`. Ми можемо легко додати додаткові параметри, розділивши всі комою.\n\nЯкщо ми хочемо, ми можемо визначити функцію так, щоб вона приймала довільну кількість параметрів. Ми повідомляємо Python, що хочемо цього, використовуючи зірочку (`*`).\n\nВи використовуєте `*args` як параметр для вашої функції - це коли ви не знаєте, скільки значень можна передати в неї, як у випадку з нашою функцією sum. Зірочка в даному випадку - це синтаксис, який повідомляє Python, що ви збираєтеся передати довільну кількість параметрів у свою функцію. Ці параметри зберігаються у вигляді кортежу.\n\nНаші функції можуть повертати будь-який тип даних. Це дозволяє нам легко створювати функції, які перевіряють умови, які ми можемо захотіти відстежувати.\n\nТут ми визначаємо функцію, яка повертає логічне значення. Ми можемо легко використовувати це в поєднанні з операторами if та іншими ситуаціями, які потребують логічного значення.\n\nЦя наведена вище функція повертає впорядковану пару вхідних параметрів, збережених як кортеж.\n\n## Подальші кроки\n\nЯкщо ви хочете глибше заглибитися в матеріал, тоді зверніться до [документації по Python](https://docs.python.org/3/index.html).\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":true,"html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML"},"highlight-style":"arrow","css":["style.css"],"output-file":"appb.html"},"language":{"toc-title-document":"Зміст","toc-title-website":"На цій сторінці","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Анотація","section-title-appendices":"Додатки","section-title-footnotes":"Зноски","section-title-references":"Використана література","section-title-reuse":"Повторне використання","section-title-copyright":"Copyright","section-title-citation":"Цитата","appendix-attribution-cite-as":"Будь-ласка, цитуйте цю роботу як:","appendix-attribution-bibtex":"BibTeX:","title-block-author-single":"Автор","title-block-author-plural":"Автори","title-block-affiliation-single":"Приналежність","title-block-affiliation-plural":"Приналежності","title-block-published":"Дата публікації","title-block-modified":"Змінено","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Код","code-tools-menu-caption":"Код","code-tools-show-all-code":"Розгорнути код","code-tools-hide-all-code":"Приховати код","code-tools-view-source":"Переглянути код","code-tools-source-code":"Вихідний код","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Копіювати","copy-button-tooltip-success":"Скопійовано!","repo-action-links-edit":"Редагувати сторінку","repo-action-links-source":"Переглянути код","repo-action-links-issue":"Повідомити про проблему","back-to-top":"Back to top","search-no-results-text":"Пошук не дав результату","search-matching-documents-text":"Результати пошуку","search-copy-link-title":"Скопіюйте посилання для пошуку","search-hide-matches-text":"Приховати додаткові результати","search-more-match-text":"Додатковий результат у цьому документі","search-more-matches-text":"Додаткові результати у цьому документі","search-clear-button-title":"Очистити","search-detached-cancel-button-title":"Скасувати","search-submit-button-title":"Надіслати","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Рис.","crossref-tbl-title":"Таблиця","crossref-lst-title":"Список","crossref-thm-title":"Теорема","crossref-lem-title":"Лема","crossref-cor-title":"Наслідок","crossref-prp-title":"Твердження","crossref-cnj-title":"Гіпотеза","crossref-def-title":"Визначення","crossref-exm-title":"Приклад","crossref-exr-title":"Завдання","crossref-ch-prefix":"Глава","crossref-apx-prefix":"Додаток","crossref-sec-prefix":"Розділ","crossref-eq-prefix":"Рівняння","crossref-lof-title":"Список Рисунків","crossref-lot-title":"Список Таблиць","crossref-lol-title":"Список Каталогів","environment-proof-title":"Доведення","environment-remark-title":"Зауваження","environment-solution-title":"Рішення","listing-page-order-by":"Сортувати по","listing-page-order-by-default":"попередньо вибраний","listing-page-order-by-date-asc":"Найновіші","listing-page-order-by-date-desc":"Найстріші","listing-page-order-by-number-desc":"За спаданням","listing-page-order-by-number-asc":"За зростанням","listing-page-field-date":"Дата","listing-page-field-title":"Заголовок","listing-page-field-description":"Опис","listing-page-field-author":"Автор","listing-page-field-filename":"Ім'я файлу","listing-page-field-filemodified":"Змінено","listing-page-field-subtitle":"Підзаголовок","listing-page-field-readingtime":"Час читання","listing-page-field-categories":"Категорії","listing-page-minutes-compact":"{0} хвилин","listing-page-category-all":"Все","listing-page-no-matches":"Немає відповідних елементів"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.433","bibliography":["references.bib"],"csl":"physical-review-b.csl","callout-appearance":"default","grid":{"body-width":"1050px"},"page-layout":"full","theme":{"light":"cosmo","dark":"superhero"},"title":"Вступ до мови програмування Python"},"extensions":{"book":{"multiFile":true}}},"docx":{"identifier":{"display-name":"MS Word","target-format":"docx","base-format":"docx"},"execute":{"fig-width":5,"fig-height":4,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"docx","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"page-width":6.5},"pandoc":{"default-image-extension":"png","to":"docx","toc":true,"number-sections":true,"output-file":"appb.docx"},"language":{"toc-title-document":"Зміст","toc-title-website":"На цій сторінці","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Анотація","section-title-appendices":"Додатки","section-title-footnotes":"Зноски","section-title-references":"Використана література","section-title-reuse":"Повторне використання","section-title-copyright":"Copyright","section-title-citation":"Цитата","appendix-attribution-cite-as":"Будь-ласка, цитуйте цю роботу як:","appendix-attribution-bibtex":"BibTeX:","title-block-author-single":"Автор","title-block-author-plural":"Автори","title-block-affiliation-single":"Приналежність","title-block-affiliation-plural":"Приналежності","title-block-published":"Дата публікації","title-block-modified":"Змінено","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Код","code-tools-menu-caption":"Код","code-tools-show-all-code":"Розгорнути код","code-tools-hide-all-code":"Приховати код","code-tools-view-source":"Переглянути код","code-tools-source-code":"Вихідний код","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Копіювати","copy-button-tooltip-success":"Скопійовано!","repo-action-links-edit":"Редагувати сторінку","repo-action-links-source":"Переглянути код","repo-action-links-issue":"Повідомити про проблему","back-to-top":"Back to top","search-no-results-text":"Пошук не дав результату","search-matching-documents-text":"Результати пошуку","search-copy-link-title":"Скопіюйте посилання для пошуку","search-hide-matches-text":"Приховати додаткові результати","search-more-match-text":"Додатковий результат у цьому документі","search-more-matches-text":"Додаткові результати у цьому документі","search-clear-button-title":"Очистити","search-detached-cancel-button-title":"Скасувати","search-submit-button-title":"Надіслати","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Рис.","crossref-tbl-title":"Таблиця","crossref-lst-title":"Список","crossref-thm-title":"Теорема","crossref-lem-title":"Лема","crossref-cor-title":"Наслідок","crossref-prp-title":"Твердження","crossref-cnj-title":"Гіпотеза","crossref-def-title":"Визначення","crossref-exm-title":"Приклад","crossref-exr-title":"Завдання","crossref-ch-prefix":"Глава","crossref-apx-prefix":"Додаток","crossref-sec-prefix":"Розділ","crossref-eq-prefix":"Рівняння","crossref-lof-title":"Список Рисунків","crossref-lot-title":"Список Таблиць","crossref-lol-title":"Список Каталогів","environment-proof-title":"Доведення","environment-remark-title":"Зауваження","environment-solution-title":"Рішення","listing-page-order-by":"Сортувати по","listing-page-order-by-default":"попередньо вибраний","listing-page-order-by-date-asc":"Найновіші","listing-page-order-by-date-desc":"Найстріші","listing-page-order-by-number-desc":"За спаданням","listing-page-order-by-number-asc":"За зростанням","listing-page-field-date":"Дата","listing-page-field-title":"Заголовок","listing-page-field-description":"Опис","listing-page-field-author":"Автор","listing-page-field-filename":"Ім'я файлу","listing-page-field-filemodified":"Змінено","listing-page-field-subtitle":"Підзаголовок","listing-page-field-readingtime":"Час читання","listing-page-field-categories":"Категорії","listing-page-minutes-compact":"{0} хвилин","listing-page-category-all":"Все","listing-page-no-matches":"Немає відповідних елементів"},"metadata":{"bibliography":["references.bib"],"csl":"physical-review-b.csl","callout-appearance":"default","title":"Вступ до мови програмування Python"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","docx"]}