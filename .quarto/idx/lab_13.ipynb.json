{"title":"Лабораторна робота № 13","markdown":{"yaml":{"title":"Лабораторна робота № 13"},"headingText":"Теоретичні відомості","containsRefs":false,"markdown":"\n\n\n\n\n\n\n**Тема.** Найпростіші мережі та мережні міри складності.\n\n**Мета.** Навчитися використовувати елементи теорії графів для отримання спектральний і топологічних мір складності.\n\n\nДля сучасних складних систем характерна нерегулярність зв'язків і висока чисельність елементів, яка може досягати десятків і сотень тисяч. Таким системам та їх мережним моделям, які володіють нетривіальними топологічними властивостями, найбільше відповідає термін \"комплексні\". Комплексною мережею вважається система, яка \n\n- складається з великої кількості компонентів; \n- допускає «далекосяжні» зв'язки між компонентами;\n- володіє великомасштабною (у тому числі просторово-часовою) мінливістю. \n\nДана мережа є графом з досить великою кількістю вузлів різної природи, що характеризуються багатовимірним кортежем ознак і динамічно мінливими зв’язками; розподіл ознак вузлів і характеристик зв'язків може бути описаний ймовірнісною моделлю (багатомірним розподілом). \n\nОсновною причиною підвищення актуальності розробок у області теорії і практики комплексних мереж є результати сучасних досліджень реальних комп'ютерних, біологічних і соціальних мереж. Властивості багатьох реальних мереж істотно відрізняються від властивостей класичних випадкових графів з рівноймовірними зв’язками між вузлами, які донедавна розглядалися в якості їх базисного математичного модельного прототипу, і тому побудову їх моделей було запропоновано здійснювати з використанням зв'язних структур і степеневих розподілів. \n\nУ теорії комплексних мереж виділяють три основні напрямки: \n\n- дослідження статистичних властивостей, які характеризують поведінку мереж; \n- створення моделей мереж; \n- прогнозування поведінки при зміні структурних властивостей мереж. \n\nКомплексні мережі використовуються для моделювання об’єктів і систем, дослідження яких іншими способами (за допомогою спостереження або активного експерименту) недоцільні або неможливі. Комп'ютерні мережі відносяться до мереж, які постійно ростуть і розвиваються. Серед факторів, що впливають на зростання мережі в першу чергу необхідно відзначити розмір або протяжність локальної мережі, яка визначається відстанню між найвіддаленішими станціями, при якій в нормальному режимі роботи вузлів чітко розпізнаються колізії, і кількість об'єднаних у мережу комп'ютерів. Для Інтернет-мереж цей розмір називається діаметром мережі і складає приблизно 1 км відстані, що дозволяє отримати високу швидкість зв’язку та максимально можливий рівень сервісу. При зростанні мережі збільшується кількість колізій, різко падає її корисна пропускна\nздатність і швидкодія передавання сигналу. Обмеження мережі за довжиною є передумовою вибору структури мережі, розбиття її на окремі частини (сегменти), появи додаткових серверів з новою мережею зв’язків, проблеми генеруються в контексті технологій так званої \"останньої милі\". Спостерігається динаміка зростання мережі, своєрідна кластеризація, сервери виступають центрами утворених кластерів, відбувається просторове позиціонування компонент мережі у вигляді чітких ієрархічних структур. \n\nМережа розглядається як множина сегментів, кожен з яких закінчується точкою розгалуження або кінцевої вершиною мережі. Вершинами мережі є сервери, комутатори й кінцеві користувачі, загальну кількість яких позначимо $N$. Локальні комп’ютерні мережі є об'єктними прототипами графових структур і тому для їх дослідження застосовують методи теорії графів.\n\nМоделювання мереж із використанням апарата теорії графів є важливим напрямком досліджень дискретної математики. В останні роки зросла зацікавленість дослідників до складних мереж з великою кількістю вузлів, зокрема до комп'ютерних мереж, структура яких нерегулярна, складна і динамічно розвивається в часі. Для таких мереж доводиться генерувати стохастичні графи з величезною кількістю вершин. \n\nУ загальному вигляді модель комп'ютерної мережі являє собою випадковий граф, закон взаєморозміщення ребер і вершин для якого задається розподілом ймовірностей.\n\nУ даний час найпоширенішими є два основних підходи до моделювання складних мереж: \n\n- випадкові Пуассонівські графи та узагальнені випадкові графи; \n- модель \"тісного світу\" Ватса і Строґатса та її узагальнення, еволюційна модель \nзростання мережі Барабаші й Альберт.\n\nПерший передбачає генерацію випадкового графа із заздалегідь відомою кількістю вершин і заданими ймовірнісними властивостями. Його ще називають графом **Ердоша-Рені** зі сталою кількістю вершин $N$. Розподіл ступенів вузлів $k$ для цього графа визначається формулою Пуассона $P(k) = \\exp^{-\\left\\langle k \\right\\rangle} \\left\\langle k \\right\\rangle^k / k!$. Побудова графа здійснюється генеруванням, коли до $N$ відокремлених вершин послідовно додаються ребра, що з'єднують випадковим чином довільні пари вершин. Початково граф складатиметься із сукупності малих вершин, які в процесі генерування з часом розростаються до гігантського кластера зв'язаних між собою вершин, число яких є скінченною частиною загальної кількості $N$. При генерації постійно зростає ймовірність зв'язування вершин, яка досягає з часом деякого критичного значення. В результаті процесу, який має характер фазового переходу, граф спонтанно розростається до гігантського кластера вершин, пов’язаних між собою, що нагадує конденсацію краплі води в перенасиченій парі.\n\nМодель **Ваттса-Строґаца** є комп'ютерною моделлю тісного світу. Її побудова зводиться до наступного: розглядається одновимірний, замкнений у кільце, періодичний ланцюг, який складається із $N$ вершин. Спочатку кожну вершину з'єднують з іншими сусідніми, які знаходяться від неї на відстані, не більшій за $k$, а потім кожне ребро з певною ймовірністю $m$ перез'єднується з довільною вершиною, що призводить до трансформації регулярного ланцюга у граф тісного світу (@fig-watts-strogatz). Оскільки в цій моделі кількість ребер є сталою, а ймовірності реалізації графів --- різні, то вона зводиться до канонічного ансамблю графів і описує реально існуючі мережі, топологія яких не є ані цілком регулярною, ані цілком випадковою.\n\n::: {#fig-watts-strogatz}\n\n![](Images\\lab_13\\Watts-Strogatz-model.jpg)\n\nТрансформація регулярного ланцюга у граф тісного світу і далі у випадковий граф \n\n:::\n\nБільшість реальних графів підпорядковуються степеневому закону розподілу $P(k)$. Ці графи побудови мереж описуються моделлю переважного приєднання Барабаші-Альберт. Через далекоглядні взаємодії у системи не існує масштабу зміни характерних величин. Ріст і переважне приєднання є основними механізмами побудови безмасштабних (масштабно-інваріантних) мереж. \n\nНехай вузол $i$ має $k_i$ зв'язків і він може бути приєднаним (зв'язаним) до інших вузлів $k_i$. Ймовірність приєднання нового вузла до вузла $i$ залежить від ступеня $k_i$ вузла $i$. Величину $W(k_i) = k_i/\\sum_{j}k_j$ називають переважним приєднанням (preferential attachment). Не всі вузли мають однакову кількість зв'язків, тому вони характеризуються функцією розподілу $P(k)$, що визначає ймовірність того, що випадково вибраний вузол має $k$ зв'язків. Для комплексних мереж функція $P(k)$ відрізняється від розподілу Пуассона для випадкових графів. Для переважної більшості комплексних мереж спостерігається степенева залежність $P(k)\\propto k^{-\\gamma}$.\n\nУ попередній роботі ми вже ввели деякі з мір складності. Зараз же зробимо це систематично і покажемо, яким чином у межах єдиного алгоритму розрахувати і проаналізувати основні **спектральні** і **топологічні** властивості найпростіших графів. \nДля аналізу мережі досліджують характеристики окремих вузлів (локальні), характеристики мережі в цілому (глобальні), та характеристики мережних підструктур. Числові показники деяких глобальних характеристик мережі можуть бути представлені у вигляді аналітичних узагальнень її локальних характеристик (наприклад --- найменше, найбільше, середнє значення локального показника, взяте по всім вузлам). Окрім того, що глобальна характеристика може бути представлена у формі одного числа, це також може бути представлення у вигляді розподілу значень локальної характеристики вузлів по всій мережі.\n\n### NetworkX\n\nДля аналізу складних мереж і їх спектральних і топологічних характеристик можна скористатися такою бібліотекою як [**NetworkX**](https://networkx.org). \n\nNetworkX дозволяє моделювати, аналізувати та візуалізувати мережі різної природи та складності. Пакет надає класи для представлення декількох типів мереж та реалізацію багатьох алгоритмів, що використовуються в мережевій науці. NetworkX відносно простий у встановленні та використанні і має багато вбудованих функцій, тому він ідеально підходить для вивчення мережевої науки і виконання аналізу малих і середніх мереж.\n\nNetworkX є безкоштовним програмним забезпеченням з відкритим вихідним кодом. Це означає, що вихідний код доступний для читання, модифікації та розповсюдження (за певних умов). Сам код доступний за адресою https://github.com/networkx/networkx. NetworkX був написаний спільнотою з десятків дописувачів. Якщо у вас є ідея щодо нової функції або способу покращення програмного забезпечення, ви можете самостійно її запрограмувати й поділитися нею зі спільнотою.\n\n#### Встановлюємо NetworkX\n\nДля встановлення даної бібліотеки можна скористатися наступною командою:\n\nДалі можемо імпортувати відповідні бібліотеки:\n\nПам'ятайте, що оператори `import` знаходяться у верхній частині вашого коду, вказуючи Python завантажити зовнішній модуль. У цьому випадку ми хочемо завантажити NetworkX, але дамо йому короткий псевдонім `nx`, оскільки нам доведеться вводити його неодноразово, звідси й інструкція `as`.\n\nДавайте перевіримо встановлену версію NetworkX. Ми хочемо переконатися, що не використовуємо застарілий пакет.\n\nДалі виконаємо налаштування формату виведення рисунків:\n\n### Типи мереж\n\nМережі, представлені в цій лабораторній, поки що мають лише найнеобхідніше. Ці мережі називаються простими мережами, тому що вони прості. У NetworkX прості мережі представлені класом `Graph`. Назва `Graph` походить від терміну, що використовується в математиці для опису мереж. Ви можете подумати, що він означає малюнок або креслення, але в даному випадку він просто означає мережу. Математики часто використовують повсякденні слова в дуже специфічними способами, які дуже відрізняються від їх повсякденних значень, наприклад наприклад, \"граф\", \"пучок\" або \"кільце\".\n\n#### Простий граф (ненаправлений та незважений)\n\nІснує багато необов'язкових аргументів для функції draw, щоб налаштувати зовнішній вигляд.\n\n#### Зважена мережа\n\nПовертаючись до випадку неорієнтованих мереж, іноді не всі ребра є рівними. Наприклад, у мережі, що представляє міську систему водопостачання, ребра можуть представляти серію труб, якими вода транспортується з одного місця в інше. Деякі з них можуть мати більшу пропускну здатність, ніж інші. Коли ребра можуть мати різну міцність, мережа називається зваженою, а міцність кількісно вимірюється числом, яке називається вагою. Зваженими можуть бути як орієнтовані, так і неорієнтовані мережі. При візуалізації мережі вагу ребер часто вказують, змінюючи товщину або непрозорість ребра. Ваги ребер можна використовувати для для представлення різних типів атрибутів.\n\n#### Направлений граф\n\nІноді буває корисно додавати трохи більше деталей до мережі. Ребра, які ми бачили попередньо, не враховують звідки одна вершина прямує або куди; Вони просто з'єднують два вузли, тому їх називають **симетричними** або **неорієнтованими**.\n\nУявіть собі мережу, яка являє собою систему доріг (ребер) і перехресть (вузлів). A мережа з ненаправленими ребрами була б гарним представленням, доки ви не натрапили на вулицю з одностороннім рухом. Ненаправлене ребро припускає, що ви можете рухатися в будь-якому напрямку однаково. Хоча в реальності напрям руху по дорожній смузі матиме значення навіть для вашого життя.\n\nКоли напрямок має значення, мережа називається орієнтованою (направленою). В направленій мережі кожне ребро має вузол-джерело і вузол-приймач. Як правило, ребро представляє якийсь потік, наприклад, трафік, від джерела до цілі. Але що, якщо не всі з'єднання є односторонніми? Легко! Двосторонні з'єднання створюються шляхом поєднання двох спрямованих ребер, що йдуть в протилежних напрямках. У спрямованих мережах ребра зображуються стрілками, що вказують на ціль.\n\nОб'єкт граф має деякі властивості та методи, які надають дані про весь граф.\n\nОб'єкти NodeView та EdgeView мають ітератори, тому ми можемо використовувати їх у циклах `for`:\n\nЗверніть увагу, що ребра подано у вигляді 2-кортежів, так само, як ми їх ввели.\n\nМи можемо отримати кількість вершин та ребер у графі за допомогою методів `number_of_`.\n\nДеякі методи роботи з графами приймають ребро або вершину як аргумент. Вони надають властивості графа для даного ребра або вершини. Наприклад, метод `.neighbors()` повертає вершини, пов'язані з даною вершиною:\n\nЗ міркувань продуктивності багато методів для роботи з графами повертають ітератори замість списків. Їх зручно використовувати у циклах:\n\nі ви завжди можете використати конструктор `list` для створення списку з ітератора:\n\nЗверніть увагу на асиметрію в методах роботи з ребрами, таких як `has_edge()`:\n\nЗамість симетричного зв'язку \"сусіди\", вузли в орієнтованих графах мають попередників (successors або \"in-neighbours\") і наступників (predecessors або \"out-neighbours\"):\n\nСпрямовані графи мають вхідні степені вершини (in-degree) та вихідні степені вершини (out-degree), які показують кількість ребер, що ведуть до та від даної вершини, відповідно:\n\nУ NetworkX існує декілька алгоритмів компонування, які можуть бути використані для розміщення вузлів графа у візуалізації, в тому числі\n\n1. `nx.spring_layout()`: Цей алгоритм використовує примусовий підхід до розміщення вершин. Вузли, які з'єднані ребрами, притягуються один до одного, тоді як вузли, які не з'єднані, відштовхуються. Алгоритм намагається мінімізувати енергію системи, регулюючи положення вузлів.\n\n\n2. `nx.circular_layout()`: Цей алгоритм розміщує вузли рівномірно по колу.\n\n\n3. `nx.spectral_layout()`: Цей алгоритм використовує власні вектори матриці суміжності графа для розміщення вершин. Власні вектори використовуються для проектування вершин у простір нижчої розмірності, а положення вершин потім визначаються шляхом оптимізації функції вартості.\n\n\n4. `nx.random_layout()`: Цей алгоритм розміщує вершини випадковим чином у заданій обмежувальній області.\n\n\n5. `nx.shell_layout()`: Цей алгоритм розміщує вершини у вигляді концентричних кіл або оболонок, причому вершини в одній і тій же оболонці мають однакову відстань до центру.\n\n\n6. `nx.kamada_kawai_layout()`: Цей алгоритм використовує ітераційний оптимізаційний підхід для розміщення вузлів. Алгоритм намагається мінімізувати навантаження на систему, змінюючи положення вузлів.\n\n\n7. `nx.fruchterman_reingold_layout()`: Цей алгоритм є варіацією алгоритму `nx.spring_layout()`, і також використовує силовий підхід до розміщення вузлів.\n\nКожен алгоритм компонування має свої сильні та слабкі сторони, і вибір найкращого з них залежить від характеристик графа та цілей візуалізації. NetworkX дозволяє легко застосовувати ці алгоритми до ваших графів і створювати візуалізації, які допоможуть вам зрозуміти і передати структуру мережі.\n\n#### Знакова мережа\n\n#### Мультиграф\n\nМультиграф --- це тип графа в NetworkX, який допускає декілька ребер між парою вузлів. Іншими словами, `MultiGraph` може мати паралельні ребра, в той час як стандартний `Graph` може мати лише одне ребро між будь-якою парою вузлів.\n\nПростіше кажучи, Мультиграф --- це мережа, в якій декілька ребер можуть з'єднувати одні й ті ж вузли.\n\n#### Двочастковий (bipartite) граф\n\nДвочастковий граф --- це тип графа, в якому вершини можна розбити на дві непересічні множини так, що всі ребра з'єднують вершину з однієї множини з вершиною в іншій множині. Іншими словами, не існує ребер, які з'єднують вершини всередині однієї множини.\n\nДвочасткові графи корисні для моделювання відносин між двома різними типами об'єктів, наприклад, покупцями і продавцями на ринку, або акторами і фільмами в кіноіндустрії.\n\nУ NetworkX ви можете створювати і маніпулювати двосторонніми графами за допомогою модуля `bipartite`, який надає різні функції і алгоритми для двосторонніх графів. Крім того, існує декілька методів візуалізації, які можна використовувати для відображення двосторонніх графів, наприклад, двосторонній макет, який розташовує вузли у два окремі рядки.\n\nПриклад акціонерів та акцій:\n\nХоча двочасткові графи корисні для представлення повної структури зв'язків \"багато-до-багатьох\", іноді простіше працювати зі стандартними односторонніми мережами. Це може бути у випадку, якщо аналіз фокусується на певному типі вузлів, або якщо необхідна методика доступна лише для односторонніх (одномодальних) мереж, або якщо методика доступна лише для одномодових мереж, або якщо мережа зв'язків має занадто багато вузлів для чіткої візуалізації. На щастя, можна створити одномодові мережі з з мережі зв'язків за допомогою процесу, який називається \"проекція\". І, як ви могли б очікувати, NetworkX спрощує цей процес.\n\nОдномодові мережі, побудовані з мереж зв'язків, називаються мережами спільної приналежності, тому що вузли з'єднуються ребрами, якщо вони мають спільні зв'язки. Існує кілька типів проекцій, які використовуються для створення спільної приналежності, але всі вони обертаються навколо однієї і тієї ж ідеї: з'єднання вузлів зі спільним сусідом у вихідній мережі приналежності. Найпростіша можлива проекція --- це незважена проекція, яка створює незважене ребро між вузлами з одним або декількома спільними сусідами. У коді наступний код використовує функцію projected_graph() для проектування мережі акціонерів, що мають спільні акції компаній:\n\nУ такий самий спосіб ми можемо побудувати мережу акцій:\n\n### Імпортуємо інформацію про мережу \n\n#### Імпортуємо дані з file.txt та GEXF\n\nЩоб імпортувати інформацію про мережу до NetworkX, ви можете скористатися однією з декількох функцій, залежно від формату ваших даних. Ось кілька прикладів:\n\n1. Імпорт з файлу списку граней:\n\nПрипустимо, у вас є файл списку граней, що мають наступне представлення:\n\n```\nA B\nA C\nB D\nC D\nD E\n```\n\nВи можете імпортувати цей файл у граф NetworkX за допомогою функції `read_edgelist` наступним чином:\n\n2. Імпорт з файлу матриці суміжності:\n\nПрипустимо, що у вас є файл матриці суміжності у наступному форматі:\n\n```\n0 1 1 0 0\n1 0 0 1 0\n1 0 0 1 1\n0 1 1 0 1\n0 0 1 1 0\n```\n\nВи можете імпортувати цей файл у граф NetworkX за допомогою функції `from_numpy_matrix` наступним чином:\n\n3. Імпорт з файлу GEXF:\n\nЯкщо у вас є файл мережі у форматі GEXF, який є популярним форматом для обміну даних про графи між різними програмними пакетами. Ви можете імпортувати його у графік NetworkX за допомогою функції `read_gexf` наступним чином:\n\nПростий граф у форматі GEXF:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<gexf xmlns=\"http://www.gexf.net/1.3\" version=\"1.3\">\n  <meta lastmodifieddate=\"2022-10-01\">\n    <creator>NetworkX</creator>\n    <description>An example graph in GEXF format</description>\n  </meta>\n  <graph mode=\"static\" defaultedgetype=\"undirected\">\n    <nodes>\n      <node id=\"0\" label=\"Node 0\"/>\n      <node id=\"1\" label=\"Node 1\"/>\n      <node id=\"2\" label=\"Node 2\"/>\n    </nodes>\n    <edges>\n      <edge id=\"0\" source=\"0\" target=\"1\"/>\n      <edge id=\"1\" source=\"1\" target=\"2\"/>\n      <edge id=\"2\" source=\"2\" target=\"0\"/>\n    </edges>\n  </graph>\n</gexf>\n```\n\n#### Матриця суміжності\n\nперетворення матриці суміжності у граф за допомогою nx.Graph:\n\n### Графостатистичні показники \n\n#### Степінь вершини\n\nНезалежно від того, чи представляють вузли людей, місця, комп'ютери або атоми, розташування вузла в структурі мережі тісно пов'язане з роллю, яку він відіграє в загальній системі. Різні структури уможливлюють різні ролі. Отже, кількісно оцінюючи структурні властивості вузла, можна зрозуміти роль, яку відіграє цей вузол. Числові міри, які характеризують мережеві властивості вузла, називаються мірами центральності. Центральність часто вводять як міру важливості, але є багато способів, у які вузол може бути важливим. Наприклад, однією з найпростіших мір центральності є **степенева центральність (degree centrality)**. Степенева центральність вузла --- це просто кількість сусідів, які наявні у вузла (в орієнтованій мережі існують як степеневі, так і нестепеневі центральні вузли). У соціальній мережі степенева центральність є мірою популярності, і може бути хорошим способом здогадатися, хто влаштовує найкращі вечірки, хто має найбільшу кількість публікацій або хто є монополістом на ринку праці. Степенева центральність --- це досить елементарний приклад, але далі будуть представлені більш складні міри, які часто використовуються в науці складних мереж. Кожна міра центральності кількісно оцінює різний тип важливості і може бути корисною для відповідей на різні типи питань.\n\nПоказник степеневої центральності тісно пов'язаний із такою мірою як **степінь вершини в мережі (node degree)**, яка визначає кількість ребер, з якими з'єднана конкретна досліджувана вершина. У мережі з $N$ вершин і $M$ ребер, ступінь $k_i$ вершини $i$ визначається як:\n\n$$ k_i = \\sum_{j=1}^M A_{ij} $$\n\nде $A$ --- матриця суміжності мережі, де $A_{ij} = 1$, якщо існує ребро, що з'єднує вершини $i$ та $j$, і $A_{ij} = 0$ в іншому випадку.\n\nОколицею вершини $i$ називається множина вершин, які безпосередньо з'єднані з $i$ ребром. Околиця $i$ позначається як $N_i$ і визначається як:\n\n$$ N_i = \\{j \\mid A_{ij} = 1\\} $$\n\nде $A$ - матриця суміжності мережі, де $A_{ij} = 1$, якщо існує ребро, що з'єднує вершини $i$ та $j$, і $A_{ij} = 0$ в іншому випадку.\n\n#### Тріадичне закриття\n\nМіра, представлена в цьому розділі, стосується зв'язків між сусідами вузла, а не самого вузла. Часто буває корисно розглянути, чи мають сусіди вузла тенденцію бути пов'язаними один з одним. У соціальній мережі це питання зводиться до того, щоб запитати, чи товариш вашого товариша є і вашим товаришом одночасно. Ця властивість відома як **транзитивність**. Результатом таких стосунків є трикутники: три вузли, пов'язані між собою. Тенденція до виникнення таких трикутників називається **кластеризацією**. Сильна кластеризація часто свідчить про надійність і надлишковість мережі --- якщо один ребро зникає, шлях все ще існує через два інших. Кластеризація вимірюється за допомогою коефіцієнта локальної кластеризації, який визначає тенденцію вузлів об'єднуватись у тріади. Глобальний коефіцієнт кластеризації представляє середнє значення по всім локальним кластеризаціям, що були визначені для кожного вузла мережі. \n\n##### Коефіцієнт кластеризації\n\nКоефіцієнт кластеризації вершини $i$ задається формулою:\n\n$$C_i = \\frac{1}{k_i(k_i - 1)}\\sum_{j,k}A_{ij}A_{jk}A_{ki}$$\n\nде $k_i=\\sum_{j}A_{ij}$ --- кількість ребер, що входять у вершину $i$; $A$ позначає матрицю суміжності.\n\n##### Глобальний коефіцієнт кластеризації \n\nБагато спостережуваних соціальних мереж є більш кластеризованими, ніж це могло б виникнути випадковим чином\n\nКоефіцієнт кластеризації мережі є середнім значенням коефіцієнтів кластеризації всіх вузлів:\n\n$$C = \\frac{1}{N}\\sum_{i=1}^{N} C_i$$\n\nде $N$ - загальна кількість вузлів у мережі.\n\n##### Транзитивність\n\nТранзитивність --- це властивість мережі, яка вимірює ймовірність того, що якщо два вузли мережі мають спільного сусіда, то вони також будуть безпосередньо з'єднані один з одним. Іншими словами, вона вимірює тенденцію до утворення \"трикутників\" у мережі.\n\nФормально транзитивність мережі визначається як відношення кількості трикутників у мережі до кількості з'єднаних трійок вузлів (тобто трійок вузлів, які безпосередньо з'єднані один з одним або мають спільного сусіда). У математичній нотації транзитивність мережі позначається як:\n\n$$\nT = \\frac{\\sum_{i,k,j=1}^{N}A_{ik}A_{kj}A_{ji}}{\\sum_{i,k,j=1}^{N}A_{ik}A_{ji}}.\n$$\n\nВисока транзитивність вказує на те, що вузли в мережі мають тенденцію до утворення трикутних кластерів або спільнот, тоді як низька транзитивність вказує на те, що мережа є більш випадковою або децентралізованою структурою. Транзитивність тісно пов'язана з поняттям коефіцієнта кластеризації, який вимірює схильність вузлів до утворення локальних кластерів або спільнот.\n\n#### Шлях\n\nШлях між двома вузлами $A$ та $B$ у мережі - це послідовність вузлів $A, X_1, X_2, ..., X_n, B$ та послідовність ребер $(A, X_1), (X_1, X_2), ..., (X_n, B)$, де кожен вузол та ребро у послідовності є суміжним з попереднім та наступним вузлом або ребром у послідовності.\n\nДовжина шляху --- це кількість ребер у ньому. Шлях довжиною 1 --- це ребро між двома вершинами, шлях довжиною 2 --- послідовність з двох ребер і трьох вершин, і так далі. Найкоротший шлях між двома вершинами --- це шлях мінімальної довжини, який їх з'єднує.\n\n##### Цикл\n\n##### Геодезична лінія\n\nГеодезичний шлях між двома вузлами $A$ і $B$ в мережі --- це найкоротший шлях, який їх з'єднує. Іншими словами, це шлях з мінімальною кількістю ребер, які потрібно пройти, щоб дістатися з вузла $A$ до вузла $B$. Довжина геодезичного шляху --- це кількість ребер у цьому шляху.\n\nПошук геодезичного шляху від вузла i до кожного іншого вузла є обчислювально складним, тому нам потрібен ефективний алгоритм для цього.\n    \nТут ми використовуємо пошук в ширину\n\n##### Зв'язні компоненти\n\nУ простій мережі вище ми бачимо, що для *кожної* пари вершин можна знайти шлях, який їх з'єднує. Це і є визначенням *зв'язного* графа. Ми можемо перевірити цю властивість для заданого графа:\n\nНе кожен граф зв'язний:\n\nА NetworkX видасть помилку, якщо ви запитаєте шлях між вузлами, якого не існує:\n\nВізуально ми можемо ідентифікувати дві пов'язані компоненти на нашому графі. Давайте перевіримо це:\n\nФункція `nx.connected_components()` отримує граф і повертає список наборів імен вершин, по одному такому набору для кожної зв'язної компоненти. Перевірте, чи відповідають дві множини у наступному списку двом зв'язним компонентам на рисунку графа вище:\n\nЯкщо ви не знайомі з множинами у Python, це колекції елементів без дублікатів. Вони корисні для збору імен вузлів, оскільки імена вузлів повинні бути унікальними. Як і у випадку з іншими колекціями, ми можемо отримати кількість елементів у множині за допомогою функції `len`:\n\nНас часто цікавить найбільша зв'язна компонента, яку іноді називають *ядром* мережі. Ми можемо скористатися вбудованою функцією `max` у Python, щоб отримати найбільший зв'язну компоненту. За замовчуванням функція `max` у Python сортує дані у лексикографічному (тобто алфавітному) порядку, що не є корисним у даному випадку. Ми хочемо отримати максимальний зв'язаний компонент при сортуванні в порядку його розміру, тому ми передаємо `len` як ключову функцію:\n\nХоча часто достатньо мати лише список назв вершин, іноді нам потрібен власне підграф, що містить найбільш зв'язну вершину. Один із способів отримати її --- передати список назв вершин у функцію `G.subgraph()`:\n\nТі з вас, хто використовує завершення написання коду за допомогою табуляції, також помітять функцію `nx.connected_component_subgraphs()`. Її також можна використати для отримання основного підграфа, але представлений метод є більш ефективним, якщо вас цікавить лише найбільший зв'язна компонента.\n\n##### Направлені шляхи та компоненти\n\nДавайте поширимо ці ідеї про шляхи та зв'язні компоненти на орієнтовані графи.\n\nМи знаємо, що в орієнтованому графі ребро з довільної вершини $u$ до довільної вершини $v$ не говорить про те, що існує ребро з $v$ до $u$. Тобто, для направленого графу ми спостерігатимемо асиметрію шляхів. Зверніть увагу, що цей граф має шлях від 1 до 4, але не у зворотному напрямку.\n\nІнші функції NetworkX, що працюють зі шляхами, також враховують цю асиметрію:\n\nОскільки немає ребра з 5 в 3, найкоротший шлях з 5 в 2 не може просто пройти назад по найкоротшому шляху з 2 в 5 --- він повинен пройти довшим шляхом через вузли 6 і 4.\n\nНаправлені мережі мають два типи зв'язності. *Сильно зв'язні* означають, що між кожною парою вузлів існує спрямований шлях, тобто з будь-якого вузла ми можемо дістатися до будь-якого іншого вузла, дотримуючись спрямованості ребер. Уявіть собі автомобілі на мережі вулиць з одностороннім рухом: вони не можуть їхати проти потоку транспорту.\n\n*Слабка зв'язність* говорить про те, що між кожною парою вузлів існує шлях, незалежно від напрямку. Подумайте про пішоходів у мережі вулиць з одностороннім рухом: вони ходять по тротуарах, тому їх не хвилює напрямок руху.\n\nЯкщо мережа сильно зв'язана, вона також є і слабко зв'язаною. Зворотне не завжди вірно, як видно з цього прикладу.\n\nФункція `is_connected` для неорієнтованих графів видасть помилку, якщо задано орієнтований граф.\n\nУ випадку направленого графа замість `nx.connected_components` тепер маємо `nx.weak_connected_components` та `nx.strong_connected_components`:\n\n#### Ексцентриситет\n\nЕксцентриситет вершини $u$ в мережі --- це максимальна відстань між $u$ та будь-якою іншою вершиною мережі. Іншими словами, це максимальна довжина найкоротшого шляху між $u$ та будь-якою іншою вершиною. Ексцентриситет мережі --- це максимальний ексцентриситет будь-якого вузла мережі.\n\n#### Центральність\n\nНезалежно від того, чи представляють вузли людей, місця, комп'ютери або атоми, розташування вузла в структурі мережі тісно пов'язане з роллю, яку він відіграє в загальній системі. Різні структури уможливлюють різні ролі. Отже, кількісно оцінюючи структурні властивості вузла, можна зрозуміти роль, яку відіграє цей вузол. Числові міри, які характеризують мережеві властивості вузла, називаються мірами **центральності**. Центральність часто вводять як міру важливості, але є багато способів, у які вузол може бути важливим. Наприклад, однією з найпростіших мір центральності є **степенева центральності**. Степенева центральність вузла --- це просто кількість сусідів, яких він має (у спрямованій мережі є як степеневі, так і нестепеневі сусіди). У соціальній мережі степенева центральність є мірою популярності, і може бути хорошим способом здогадатися, хто влаштовує найкращі вечірки. Степенева центральності є досить примітивним прикладом, але в наступних лабораторних будуть представлені більш складні показники, які часто використовуються в мережевій науці. Кожна міра центральності кількісно вимірює різний тип важливості і може бути корисною для відповідей на різні типи питань.\n\n##### Степенева центральність --- ненаправлені графи\n\nСтепенева центральність --- це міра важливості вузла в мережі, що базується на кількості зв'язків, які він має з іншими вузлами. Степеневу центральність вершини $i$ можна обчислити як:\n\n$$C_D(i) = \\frac{k_i}{n-1}$$\n\nде $k_i$ --- степінь вершини $i$, тобто кількість ребер, інцидентних вершині, а $n$ --- загальна кількість вершин у мережі. Знаменник $n-1$ використовується для того, щоб врахувати той факт, що вершина не може бути з'єднана сама з собою.\n\nСтепенева центральність вузла коливається від 0 до 1, причому більше значення вказує на те, що вузол є більш центральним у мережі. Вузли з високою степеневою центральності, як правило, добре пов'язані з іншими вузлами, і їх видалення з мережі може мати значний вплив на її зв'язність.\n\nРозглянемо деякі показники на прикладі графу **карате-клубу**.\n\n::: {.callout-tip title=\"Відомості про граф карате-клубу\"}\n\nГраф карате-клубу --- це соціальна мережа, що представляє дружбу між 34 членами карате-клубу, як це спостерігав Вейн В. Захарі у 1977 році. Кожна вершина графа представляє члена клубу, а кожне ребро --- дружбу між двома членами. Граф має 34 вершини та 78 ребер.\n\nКарате-клуб є відомим прикладом аналізу соціальних мереж і використовувався для вивчення різних властивостей мережі, таких як структура спільноти і міра центральності. Граф характеризується розколом клубу на дві фракції, очолювані інструкторами клубів: вершина 1 та вершина 34. Цей розкол був спричинений суперечкою між двома лідерами, яка врешті-решт призвела до утворення двох окремих клубів карате.\n\n:::\n\n##### Степенева центральність --- направлені графи\n\n##### Ступінь близькості\n\nМіра, відома як ступінь близькості, є однією з найстаріших мір центральності, що використовується в мережевій науці, запропонована соціологом Алексом Бавеласом у 1950 році. Близькість визначається як зворотна величина до віддаленості. Що таке віддаленість? Більш зрозуміло, віддаленість вузла --- це сума відстаней між цим вузлом і всіма іншими вузлами. Отже, вузол з високою центральністю близькості знаходиться буквально поруч з іншими вузлами. Центральність вузла вимірює, наскільки швидко він може поширювати інформацію або вплив по всій мережі, оскільки вузли з меншою середньою відстанню до всіх інших вузлів можуть спілкуватися більш ефективно. Крім того, вузли з високим показником центральності часто розташовані в центрі мережі, і їх видалення може мати значний вплив на зв'язність мережі.\n\nСтупінь близькості вузла $i$ можна обчислити як:\n\n$$C_C(i) = \\frac{1}{\\sum\\limits_{j \\neq i} d_{ij}}$$\n\nде $d_{ij}$ - найкоротша відстань між вузлами $i$ та $j$. Ступінь близькості вузла коливається від 0 до 1, причому більше значення вказує на меншу середню відстань до всіх інших вузлів мережі.\n\nУ наступному прикладі використовується функція NetworkX `closeness_centrality()` для обчислення значень центральності для мережі карате клубу та відображення 10 найближчих один до одного каратистів:\n\n##### Ступінь посередництва\n\nУ популярній дитячій грі \"Телефон\" один гравець починає з того, що шепоче повідомлення іншому, той шепоче це повідомлення іншому і так далі. Врешті-решт, останній гравець промовляє повідомлення вголос. Як правило, фінальне повідомлення не має нічого спільного з початковим. Так, повідомлення, яке починалося як \"слідуй за фанковою течією\", може закінчитися як \"якби кожна свиняча відбивна була ідеальною, у нас не було б хот-догів\". Кожного разу, коли повідомлення передається від людини до людини, воно може змінюватися, можливо, через те, що його неправильно почули, а можливо, через те, що його навмисно змінили. У більш складних соціальних мережах, таких як організації та громадські рухи, особи, які з'єднують різні частини мережі, мають найбільші можливості фільтрувати, посилювати та змінювати інформацію. Таких людей називають брокерами, а ребра, що з'єднують віддалені частини мережі, --- мостами. Важливість таких вузлів і ребер не обмежується соціальними мережами. У потокових мережах --- таких як залізниці, водопроводи та телекомунікаційні системи --- вузли що з'єднують віддалені частини мережі, можуть діяти як вузькі місця, обмежуючи обсяг потоку. Виявлення таких вузьких місць дає змогу збільшити їхню пропускну здатність і захистити їх від збоїв та атак. Мости і брокери важливі, тому що вони знаходяться між різними частинами мережі. Відповідно, тип центральності, який використовується для визначення мостів і брокерів називається **cтупенем посередництва**.\n\nСтупінь посередництва --- це міра того, наскільки вузол лежить на найкоротших шляхах між іншими вузлами мережі. Ступінь посередництва для вузла $i$ можна обчислити як:\n\n$$C_B(i) = \\sum\\limits_{s \\neq i \\neq t} \\frac{\\sigma_{st}(i)}{\\sigma_{st}}$$\n\nде $s$ і $t$ --- два вузли мережі, $\\sigma_{st}$ --- загальна кількість найкоротших шляхів між $s$ і $t$, а $\\sigma_{st}(i)$ --- кількість найкоротших шляхів між $s$ і $t$, які проходять через вузол $i$. \n\nСтупінь посередництва змінюється від 0 до 1, причому більше значення вказує на більшу кількість найкоротших шляхів, що проходять через вершину. Вузли з високим значенням центральності часто розташовані на \"мостах\" між різними кластерами або спільнотами в мережі, і їх видалення може мати значний вплив на зв'язність мережі.\n\nСтупінь посередництва базується на припущенні, що чим більше найкоротших шляхів проходить через вершину (або ребро), тим більше вона виступає в ролі брокера (або моста). Для ступеня посередництва знаходять найкоротші шляхи між кожною парою вузлів. Значення ступеня посередництва для вузла або ребра --- це просто кількість цих шляхів, що проходять через нього. Тут є кілька застережень. По-перше, за домовленістю, шляхи не вважаються такими, що проходять через їхні кінцеві точки і не враховуються при визначенні посередництва між ними. Крім того, вам може бути цікаво, що станеться, якщо є два найкоротших шляхи однакової довжини. У цьому випадку кожен шлях робить 1/2 внеску в посередництво своїх вершин/ребер (або 1/3, якщо є 3 шляхи, і так далі).\n\nНа наступній діаграмі показано приклад мережі та розраховані значення посередництва для кожної вершини та ребра. Для кожної пари вершин показано найкоротший шлях (за винятком тривіальних шляхів довжиною 1). Посередництво вузла --- це сума шляхів, які проходять через цей вузол. Посередництво ребра --- це кількість нетривіальних шляхів, які проходять через це ребро, плюс 1 для самого ребра:\n\n::: {#fig-betweenness}\n\n![](Images\\lab_13\\betweenness.png)\n\nУсі нетривіальні найкоротші шляхи у прикладі мережі та отримані центри посередництва \n\n:::\n\nСтупінь посередництва між вузлами легко обчислюється в NetworkX за допомогою функції `betweenness_centrality()`. Ця функція повертає словник, який зіставляє позначення вузлів зі значеннями посередництва. Якщо аргумент `normalized` має значення `True` (за замовчуванням), значення ступеня посередництва ділиться на кількість пар вузлів, що може бути корисним для порівняння значень посередництва, що мають різні масштаби. Якщо аргумент `endpoints` має значення `True` (за замовчуванням False), то кінцеві точки шляху будуть включені в розрахунок посередництва.\n\nВидно, що високим рівнем посередництва характеризуються вершини 1, 34 і 33. Високий рівень посередництва між ними свідчить про те, що ці особи є важливими інформаційними посередниками в клубі карате. Можливо, вони є найбільш вправними каратистами. \n\nЦентральність посередництва для ребер --- це міра того, наскільки ребро лежить на найкоротших шляхах між іншими ребрами в мережі. Посередництво ребра $e$ можна обчислити наступним чином:\n\n$$C_B(e) = \\sum_{s \\neq e \\neq t} \\frac{\\sigma_{st}(e)}{\\sigma_{st}}$$\n\nде $s$ і $t$ --- дві вершини мережі, $\\sigma_{st}$ --- загальна кількість найкоротших шляхів між $s$ і $t$, а $\\sigma_{st}(e)$ --- кількість найкоротших шляхів між $s$ і $t$, які проходять через ребро $e$.\n\nСтупінь посередництва ребра змінюється від 0 до 1, причому більше значення вказує на більшу кількість найкоротших шляхів, які проходять через ребро. Ребра з високою посередництвом часто розташовані на \"мостах\" між різними кластерами або спільнотами в мережі, і їх видалення може мати значний вплив на зв'язність мережі.\n\nЯкщо розглядати, наприклад, топ 3 ребер із найбільшим ступенем посередництва, ми побачимо, що, як правило, найкраща комунікація проходить у тренера з учнями під номерами 32, 7, 6, 3 тощо. \n\n##### Ступінь впливовості\n\nУявіть, що у вас є важливе повідомлення, яке потрібно донести до цілої групи (наприклад, до вашого роботодавця або школи), але ви можете передати його лише одній людині. Кому б ви це сказали? Ви б хотіли знайти когось, хто має хороші зв'язки з усією мережею. Ви можете спробувати звернутися до людини з найвищою степеневою центральністю (найбільшою кількістю друзів). Недоліком такого підходу є те, що її друзі можуть бути не дуже добре пов'язані з рештою мережі. Наприклад, у гіпотетичній компанії директор з продажу на східному узбережжі може знати найбільше людей, але не знати, як зв'язатися з іншими відділами чи регіонами. Замість нього краще знайти когось, хто має тісні зв'язки з іншими людьми, які мають тісні зв'язки, наприклад, генерального директора (або, що більш ймовірно, його помічника). Таких людей іноді називають **хабами**, тому що, подібно до центру колеса зі спицями, вони з'єднують між собою багато різних точок. Цю концепцію високозв'язних хабів добре відображає показник, який називається **ступенем впливовості**.\n\nСтупінь впливовості вершини $i$ можна визначити через головний власний вектор матриці суміжності $\\mathbf{A}$ мережі:\n\n$$\\mathbf{Av} = \\lambda \\mathbf{v}$$\n\nде $\\mathbf{v}$ --- власний вектор, що відповідає найбільшому власному значенню $\\lambda$. Ступінь впливовості вершини $i$ задається $i$-им елементом $\\mathbf{v}$.\n\nСтупінь впливовості вузла коливається від 0 до 1, причому більше значення вказує на більшу важливість вузла та його сусідів у мережі. Вузли з високим ступенем впливовості часто розташовані в центрі мережі і добре пов'язані з іншими сильно пов'язаними вузлами, і їх видалення може мати значний вплив на зв'язність мережі.\n\n### Широкомасштабний опис мереж \n\nШирокомасштабні структури можуть сильно відрізнятися від мережі до мережі. Ці відмінності часто вказують на різні типи мереж (наприклад, соціальні та технологічні). Широкомасштабні структури також можуть мати важливі наслідки для функціональних властивостей, таких як як стійкість до збоїв і атак. Розглянемо аналіз структурних показників для мереж різних типів. \n\nЯк ви вже могли переконатися на прикладі графу карате-клубу, NetworkX надає декілька вбудованих наборів мережевих даних, які можна використовувати для тестування та експериментів. Ці набори даних доступні в самій бібліотеці NetworkX і можуть бути завантажені за допомогою функцій, які починаються з префікса `nx.`, за яким слідує назва набору даних.\n\nОсь кілька прикладів вбудованих мережевих наборів даних у NetworkX:\n\n- `nx.karate_club_graph()` - повертає мережу Zachary's Karate Club, соціальну мережу карате-клубу, де кожен вузол представляє члена клубу, а кожне ребро представляє дружні стосунки між членами.\n\n- `nx.les_miserables_graph()` - Повертає мережу персонажів роману Віктора Гюго \"Знедолені\", де кожен вузол представляє персонажа роману, а кожне ребро представляє спільну появу двох персонажів у главі.\n\n- `nx.davis_southern_women_graph()` - Повертає мережу соціальних взаємодій між жінками у містечку на півдні США у 1930-х роках, де кожен вузол представляє жінку, а кожне ребро - соціальні стосунки між двома жінками.\n\nЦе лише кілька прикладів вбудованих мережевих наборів даних в NetworkX. Ви можете знайти більше інформації про доступні набори даних та їх використання в документації NetworkX.\n\nНаступний код візуалізує три приклади мереж:\n\n#### Діаметр і найкоротший шлях\n\nМережі можуть бути охарактеризовані відповідно до розподілу довжини найкоротшого шляху. Наведена нижче функція будує гістограму всіх найкоротших шляхів у мережі:\n\nТепер давайте порівняємо розподіл довжин шляхів для трьох мереж:\n\nУсі три графи мають достатньо малі найкоротші шляхи. Соціальні мережі, як правило, мають короткі шляхи, відомий як феномен малого світу. \n\nХоча розподіл повної довжини шляху є інформативним, він є дещо громіздким, тому корисно використовувати агреговані показники. Однією з таких мір є середня довжина найкоротшого шляху, яку можна обчислити наступним чином:\n\n::: {.callout-warning}\n\nУ роз'єднаній мережі, де мережа може бути розділена на дві або або більше компонентів без ребра між ними, середня довжина шляху стає нескінченною. Цю проблему можна вирішити кількома способами, наприклад використання гармонічного, а не арифметичного середнього, або усереднення середнього значення найкоротших шляхів у межах кожної зв'язної компоненти. Який метод є доречним, залежить від типу мережі, що аналізується.\n\n:::\n\nКрім того, розмір мережі може бути охарактеризований найбільшою довжиною шляху довжиною, яка називається **діаметром**. Діаметри трьох прикладів мереж можна знайти за допомогою функції `diameter()`:\n\nЯк ми можемо бачити результати доволі схожі на попередні. На відміну від середньої довжини найкоротшого шляху, діаметр залежить лише від одного шляху. Як наслідок, один викид може значно збільшити діаметр. Однак у такому разі діаметр може бути гарним показником найгіршої довжини шляху.\n\n#### Вимірювання стійкості мережі\n\nСтійкість --- це здатність системи протистояти збоям і атакам. Наприклад, в електромережі стійкість означає продовження подачі електроенергії, коли лінія електропередач або генератор вийшли з ладу. У дорожньому русі це може означати можливість перенаправляти автомобілі, коли вулиця перекрита через аварію.\n\nСтійкість --- це фундаментальна властивість мережі, оскільки вона зазвичай досягається за допомогою резервних шляхів. Коли один шлях більше не доступний, інші все ще можуть бути використані.\n\nНайпростішим (і найгрубішим) показником стійкості є **щільність мережі**: частка можливих ребер, які існують. Чим більше ребер у мережі, тим більше надлишкових шляхів існує між її вузлами. Наступний код використовує функцію `density()` для обчислення цього значення:\n\nМережа зазвичай вважається розрідженою, якщо кількість ребер близька до $N$ (кількість вузлів), і щільною, якщо кількість ребер близька до $N^2$.\n\nМожна бачити, що найбільш стійкою (щільною) серед усіх трьох графів є мережа жінок. \n\n#### Найменші розрізи\n\nБільш складні показники відмовостійкості базуються на концепції найменших розрізів. **Найменший розріз** або **min-cut** --- це кількість вузлів (або ребер), які потрібно видалити, щоб розділити мережу на дві незв'язані частини. Найменші розрізи можна знайти або між двома конкретними вузлами, або над усіма парами вузлів. \n\nУ NetworkX найменший розріз між двома вузлами знаходять за допомогою функції `minimum_st_node_cut()`. Зауважте, що ця функція знаходиться у пакеті `connectivity` і має бути імпортована окремо на додачу до базового пакету `networkx`. Наступний код знаходить мінімальну довжину шляху між містером Хі та Джоном А. у мережі карате-клубу:\n\nПопередній результат говорить про те, що вузли 2, 8, 12, 19, 30, 31 потрібно видалити, щоб розділити мережу на дві половини, одна з яких містить містера Хі, а інша міститиме Джона А.\n\nАналогічно, найменший розріз ребер може бути знайдений наступним чином:\n\nЯкщо вам потрібно знати лише розмір найменшого розрізу, ви можете скористатися функціями `node_connectivity()` або `edge_connectivity()` у базовому пакеті `networkx`. У наступному прикладі обчислюються ці значення для мережі карате-клубу:\n\n#### Зв'язність\n\nНайменші розрізи можуть бути використані для визначення показників зв'язності для всієї мережі. Ці міри дуже корисні для кількісної оцінки стійкості мережі.\n\nЗв'язність вузлів --- це найменший мінімальний розріз між усіма парами вузлів. Зв'язність ребер визначається аналогічно. Фактичні значення розрізів між вузлами та ребрами можна знайти за допомогою пакету `connection`:\n\nЗв'язність можна обчислити за допомогою функцій `node_connectivity()` та `edge_connectivity()`, не вказуючи вихідні та цільові вузли. У наступному прикладі обчислюється зв'язність вузлів для трьох прикладів мереж:\n\nЗдається, що всі ці мережі, окрім мережі жінок, можна роз'єднати, видаливши лише один вузок. Для мережі жінок потребується видалити два вузли.\n\nПопередня міра зв'язності знаходить розмір найменшого мінімального розрізу, але його видалення не вплине на всі шляхи в мережі. Після видалення вузла або ребра мережа буде розділена, але в кожній половині вузли все ще будуть з'єднані один з одним.\n\nКращий показник надійності можна знайти, усереднивши зв'язність по всіх вузлах або ребрах за допомогою функцій `average_node_connectivity()` і `average_edge_connectivity()`. Зауважте, що обчислення цих значень може зайняти багато часу, навіть для невеликих мереж. Наступний код обчислює середню зв'язність вузлів для досліджуваних мереж:\n\nМережа каратистів та персонажів роману доволі подібні один до одного по зв'язності, але мережа жінок представляється найбільш стійкою або, іншими словами, організованою.\n\n#### Централізація та нерівномірність\n\nМережі також можна класифікувати за ступенем централізації --- наскільки вони зосереджені в одному або декількох вузлах. Нерівномірний розподіл є більш централізованим. Наприклад, найбільш централізованою мережею є мережа, всі вузли якої під'єднані до одного вузла-хабу. Наступний код будує гістограми ступенів впливовості для кожної з мереж:\n\nЗ представлених гістограм видно, що найвищі значення впливовості приходять на мережу жінок. Найгіршою за впливовістю предстає мережа персонажів роману. \n\nВиміряти нерівномірність набору значень можна за допомогою ентропії Шеннона. Концепцію ми вже розглядали в попередніх лабораторних, але достатньо знати, що чим більш рівномірно розподіленим є набір чисел, тим вища його ентропія. Наступна функція повертає ентропію списку чисел:\n\nОбчислення ентропії ступенів впливовості у кожній з мереж дає наступний результат:\n\nНайбільш рівномірно розподіленою в даному випадку представляється мережа персонажів роману. Мережі карате-клубу та жінок мають трохи вищий ступінь централізації. \n\nУ соціальних мережах не всі стосунки є рівними. Ви можете підписати заявку на кредит для свого брата чи сестри, але навряд чи для сажотруса вашого стоматолога стоматолога. У соціології міцність стосунків вимірюється поняттям **міцність зв'язності**. У цьому контексті зв'язність --- це певний вид міжособистісних стосунків, а міцність --- це будь-яка міра того, наскільки інтенсивними чи інтимними є ці стосунки (зв'язності).\n\nУ 1973 році соціолог Марк Грановеттер описав важливість слабких зв'язків для зближення різних спільнот. Якщо всі зв'язки всередині спільноти сильні, то будь-які зв'язки між спільнотами мають бути слабкими. Він назвав це явище силою слабких зв'язків. З'єднуючи різні спільноти, слабкі зв'язки дають змогу знаходити інформацію з віддалених частин мережі. Але як виміряти силу зв'язностей?\n\n#### Сила зв'язності\n\nУ мережі карате-клубів немає ніякої додаткової інформації про міцність ребер, але є відповідні властивості цих ребер, які можна обчислити, наприклад, сила зв'язності. Сила зв'язності зростає зі збільшенням кількості сусідів, які мають спільні вершини. Це мотивовано спостереженням, що близькі друзі, як правило, мають більше спільних друзів, і це часто може дати уявлення про структуру соціальної мережі. Наступний код обчислює силу зв'язку, використовуючи метод `neighbors()` для пошуку сусідів вузлів та множини Python для обчислення кількості спільних сусідів:\n\nТут ми визначили міцність зв'язку як кількість спільних сусідів плюс один. Чому плюс один? Нульова вага умовно означає відсутність ребра, тому без додаткової одиниці ребра між вершинами, які не мають спільних сусідів, не вважатимуться ребрами.\n\n::: {.callout-note}\n\nТут можна поцікаватись, чи існує теоретичне пояснення цього \"додаткового друга\". Якщо у вас з другом немає спільних друзів, є один з його друзів, з яким ви досить добре знайомі --- це ви самі. Отже, додаткову одиницю можна інтерпретувати як таку, що вказує на зв'язність ребра самого із собою.\n\n:::\n\nНаступний код обчислює силу зв'язності кожного ребра і зберігає її в змінну `strength`:\n\n#### Мостовий проліт\n\nМіцність зв'язків також можна оцінити кількісно, розглядаючи ефект видалення ребра з мережі. Вузли, з'єднані ребром, завжди знаходяться на відстані в 1 крок один від одного (у незваженій мережі). Але якщо це ребро видалити, його кінцеві точки можуть знаходитись на відстані в 2 кроки, і навіть до зовсім не з'єднаних між собою. Цю концепцію відображає **мостовий проліт** --- відстань між кінцевими точками ребра, якщо це ребро видалити. Ребра з великим прольотом з'єднують віддалені частини мережі, тому їх можна вважати слабкими зв'язками, незважаючи на те, що вони відіграють важливу роль.\n\nНаступний код обчислює довжину кожного ребра в мережі карате-клубу:\n\n#### Порівняння міцності та прольоту\n\nРозглянемо 10 найміцніших і 10 найслабших ребер у мережі карате-клубів. Наступний код виводить ці ребра:\n\nРезультат вище показує, що ребра з низькою міцністю і великим прольотом, як правило, є зовнішніми, з'єднуючи членів клубу, які розкололися на різні клуби-відколи. З іншого боку, ребра з високою міцністю і малим прольотом є внутрішніми, вони з'єднують членів клубу, які залишилися разом після розколу.\n\n#### Спектральні міри складності\n\nУ теорії графів і комбінаториці є багато теорем, при доказі яких застосовуються спектри графів, хоча вони і не зустрічаються у формулюванні теорем. Отже, використання спектрів грає роль досить важливого методу, який називається спектральним.\n\nСпектром графа $G$ називається множина власних значень матриці, що відповідає даному графу. Відомі декілька підходів встановлення зв'язку між графом $G$ та його спектром. Для випадку регулярних графів (якими є графи часових рядів фондових індексів) \nможна показати, що різні види спектрів еквівалентні, тобто містять однакову кількість інформації про структуру графу $G$.\n\nМи вже згадували, що одним із способів представлення графа у вигляді матриці є матриця суміжності. Матриця Лапласа (Laplacian matrix) $L$ --- також є одним видів подання графа. Вона може бути використана для розрахунку кількості остовних дерев для графа. Для \nзнаходження матриці Кірхгофа використовують формулу: $L=D-A$, де $D$ --- діагональна матриця:\n\n$$\nd_{ij} = \\begin{cases}\n            d_i, & i=j,\\\\\n            0, & i \\neq j, \n        \\end{cases}\n$$\n\nде $d_i$ --- ступінь відповідної вершини графа. Отже, \n\n$$\nl_{ij} = \\begin{cases}\n    d_i, & i=j, \\\\\n    -1, & i \\neq j \\, \\text{і} \\, v_i \\, \\text{суміжна з} \\, v_j, \\\\\n    0 & \\text{в іншому випадку}. \n\\end{cases}\n$$\n\n**Algebraic connectivity** (алгебраїчна зв'язність графу) --- друге найменше власне значення матриці Лапласа. Це власне значення більше 0, тоді і тільки тоді, коли граф  зв'язний. Величина цього значення відображає, наскільки добре граф пов'язує ці компоненти, \nі була використана при аналізі надійності та синхронізації мереж. Бібліотека `NetworkX` містить метод `algebraic_connectivity()` для обчислення даного показника. Бібліотека також надає змогу розрахувати нормалізовану матрицю Лапласа. Сенс нормалізації полягає в тому, що вершина з великим степенем вершини, яку також називають **важкою вершиною**, призводить до того, що в матриці Лапласа з'являється великий діагональний елемент, який домінує у властивостях матриці. Нормалізація спрямована на те, щоб зробити вплив таких вершин більш рівним впливу інших вершин, шляхом ділення елементів матриці Лапласа на степені вершин. Щоб уникнути ділення на нуль, ізольовані вершини з нульовими степенями виключаються з процесу нормалізації.\n\nМожемо бачити, що найбільш зв'язним у даному випадку представляється саме граф жінок. Тобто спілкування та кооперація між ними залишається найбільш тісною. \n\n**Graph energy** (енергія графу) --- це сума  абсолютних значень власних значень матриці суміжності графу. Нехай $G$ є граф з $n$ вершинами. Передбачається, що $G$ --- простий, тобто він не містить петлі чи паралельних ребер. Нехай $A$ --- матриця суміжності графу $G$ і $\\lambda_i$, $i=1,...,n$ --- власні значення матриці $A$. Тоді енергія графу визначається як:\n\n$$\nE(G) = \\sum_{i=1}^{n}\\left| \\lambda_i \\right|.\n$$\n\n\n\nВбудованого методу в `NetworkX` для визначення енергії графу немає, але ми доволі запросто можемо розрахувати спектр власних значень матриці суміжності, а потім скористатися формулою вище. Власні значення матриці $A$ можна знайти за допомогою методу `adjacency_spectrum()`. Далі визначимо наступну функцію для розрахунку енергії графу:\n\nТепер розрахуємо енергію для кожного досліджуваного графа:\n\nНайвище значення енергії графу вказує на найвищу складність мережі або на найвищий ступінь централізованості деяких вузлів. Для наших графів видно, що найвища енергія приходить саме граф персонажів роману. Тобто, тут є декілька персонажів на які приходить найбільша кількість зв'язків (діалогів) у порівнянні з іншими персонажами.\n\n**Спектральний розрив** (spectral gap) --- різниця між найбільшим і другим за величиною власного значення, надає інформацію про те, як швидко досягається синхронний стан. Можемо визначити й прорахувати наступну функцію:\n\n**Спектральний радіус** є найбільшим за модулем власним значенням:\n\n$$\nr(A) = \\max_{\\lambda \\in Spec(A)} \\left| \\lambda \\right|,\n$$\n\nде $Spec(A)$ --- спектр власних значень матриці суміжності. Для розрахунків визначимо наступну функцію:\n\n**Спектральний момент**. Для визначення $k$-ого спектрального моменту використовують матрицю суміжності. Визначимо її наступним чином:\n\n$$\nm_k(A)=\\frac{1}{n}\\sum_{i=1}^{n}\\lambda_{i}^{k},\n$$\n\nде $\\lambda_i$ --- власні значення матриці суміжності $A$, $n$ --- вершини графу $G$. Значення $k$ у нашому випадку випадку буде дорівнювати 3. Тобто, будемо обчислювати спектральний момент 3-го порядку. Визначимо наступну функцію для розрахунку даного показника:\n\nОстанні показники говорять по те, що персонажі роману характеризуються найвищим ступенем складності в порівнянні з іншими графами. Ми показали, що достатня кількість вузлів має досить невисокий найкоротший шлях, але може мати гіршу щільність зв'язності вузлів або рівнорозподіленності ступеня впливовості.\n\n#### Проблема малого світу\n\nУ 1967 році соціальні психологи Джеффрі Треверс і Стенлі Мілґрем надіслали листи групам людей у Вічіті, штат Канзас, та Омасі, штат Небраска. Вони також обрали одну цільову особу в штаті Массачусетс. Кожному отримувачу листа було доручено переслати його знайомому, який, найімовірніше, знав цільову людину. Багато листів дійшли до адресата, і дослідники змогли з'ясувати, скільки кроків було зроблено для цього. Середня кількість кроків становила шість, звідси і поширена фраза \"шість ступенів відокремлення\".\n\n#### Кільцеві мережі\n\nЯк правило, більшість знайомих людини --- це люди, які живуть у тій самій місцевості. Якби кожна людина була знайома лише з тими, хто живе поруч, то можна було б очікувати, що для того, щоб надіслати повідомлення з Канзасу до Массачусетсу, знадобилося б більше шести стрибків, оскільки кожен стрибок міг би подолати лише невелику відстань. Таку мережу можна змоделювати як кільце: вузли, розташовані по колу, причому кожен вузол з'єднаний з найближчими $k/2$ вузлами з кожного боку. Наступний приклад створює та візуалізує чотирикільце за допомогою функції `watts_strogatz_graph()` про яку ми ще поговоримо. \n\nЩоб з'єднати два вузли в попередньому прикладі, потрібно пройти по краю кола, пропускаючи щонайбільше кожен другий вузол. Навіть у цій дуже маленькій мережі типова мережева відстань є досить великою порівняно з шістьма градусами, які знайшли Треверс і Мілграм.\n\nНаступний код знаходить середній найкоротший шлях і середню кластеризацію в більш реалістичному 10-кільці з 4000 вузлів:\n\nЦя мережа має в середньому 200 кроків розділення, що набагато більше, ніж шість! Вона також має досить великий середній коефіцієнт кластеризації 0.67, що показує, що сусіди вузла мають тенденцію бути пов'язаними один з одним.\n\n#### Випадкові мережі\n\nЩоб дослідити цю таємницю, розглянемо інший тип мережі. У цій мережі ми починаємо з $k$-кільця, але випадковим чином переставляємо кінцеві точки кожного ребра. В результаті отримаємо мережу з тією ж кількістю вузлів і ребер, але з випадковою структурою, що демонструється наступним чином:\n\nТепер давайте розглянемо властивості перев'язаного 10-кільця з 4000 вузлів:\n\nСередній найкоротший шлях дуже близький до реальної соціальної мережі, але середня кластеризація тепер майже 0. Поки що моделі, які ми бачили, досягають коротких шляхів або високої кластеризації, але не того й іншого разом.\n\n#### Мережа Воттса-Строгаца\n\nПроблема малого світу полягає в тому, як люди, що живуть на великій відстані один від одного, можуть бути пов'язані короткими шляхами, навіть якщо їхні зв'язки зв'язки є локальними. Дункан Воттс і Стівен Строгац розробили клас мереж для пояснення такої поведінки. Мережі починаються як $k$-кільця: вузли, розміщені по колу, кожен з яких з'єднаний з найближчими $k$ сусідами. Потім, з ймовірністю $p$, ребра кожного вузла перев'язуються з іншим випадково обраним вузлом. Ці перестановки створюють короткі шляхи по всій мережі. Навіть невелика кількість коротких шляхів значно скорочує відстані між вузлами мережі, вирішуючи проблему малого світу. Фактично, це саме те, що робить функція `watts_strogatz_graph()`, яку ми використовували, а третій параметр задає частку ребер, які потрібно перев'язати. Наступний код обчислює середній найкоротший шлях і середню кластеризацію для діапазону ймовірностей перев'язування:\n\nРезультати наступного коду зберігаються у списках `path` та `clustering`. Використовуючи функцію `semilogx()` з `matplotlib.pyplot`, наступний код візуалізує, як ці значення змінюються при зміні ймовірності перев'язування від 0 до 1:\n\n::: {.callout-note}\n\nФункція `semilogx()` використовує логарифмічний масштаб для осі x. Часто в мережевих науках значення змінюються так швидко, що візуалізація їх на лінійній шкалі призводить до того, що початкове значення миттєво падає до кінцевого. Функція semilogx() може виявити поведінку, яка може бути втрачена при використанні лінійної осі. Пакет `pyplot` також пропонує функції `semilogy()` і `loglog()` для використання інших логарифмічних осей.\n\n:::\n\nЯк ми вже бачили, зі збільшенням кількості перев'язувань, як середня кластеризація, так і середній найкоротший шлях зменшуються. Однак цікава річ відбувається при проміжних значеннях. Довжина шляху стає коротшою при дуже низьких значеннях перев'язування, в той час як зменшення кластеризації відбувається лише при більших значеннях перев'язування. Іншими словами, перев'язування дуже малої частки ребер створює \"мости\", які з'єднують віддалені частини мережі і різко скорочують середній найкоротший шлях, не змінюючи при цьому кластеризацію. Можна сказати, що найкращий тип мереж це той, що зберігає як частку впорядкованості, так і частку випадковості. \n\nДалі можемо подивитись, як виглядає мережа Воттса й Строгаца при наступних імовірностях: $p=0$, $p=0.1$ та $p=1$.\n\nУ деяких випадках перев'язування може призвести до того, що дві компоненти в мережі Воттса-Строгаца будуть роз'єднані. Роз'єднана мережа може бути непотрібним ускладненням. Мережа Ньюмана-Воттса-Строгаца --- це варіант, який гарантує, що отримана мережа буде зв'язною. Вона схожа на оригінальну версію, але залишає копію оригінального ребра на місці кожного ребра, що перев'язується. Такі мережі можна створювати за допомогою функції `newman_watts_strogatz_graph()`, як показано нижче:\n\n#### Степеневі закони та переважне приєднання\n\nВід інтернету до поїздок в аеропорт, багато мереж характеризуються кількома вузлами з великою кількістю зв'язків і багатьма вузлами з дуже малою кількістю зв'язків. Такі мережі характеризуються **важкими хвостами**, тому що при побудові гістограми степенів вузлів, вузли з високим рівнем зв'язності утворюють хвіст. \n\nІснує багато способів генерування мереж з важким хвостом, але одним з найпоширеніших є модель **переважного приєднання** Барабаші-Альберта. Модель переважного приєднання імітує процеси, в яких багаті стають багатшими. Кожного разу, коли додається новий вузол, він випадковим чином з'єднується з існуючими вузлами, причому більш вірогідним є з'єднання з вузлами високого ступеня.\n\nУ NetworkX функція `barabasi_albert_graph()`, яка генерує мережі переважного приєднання. У наступному коді показано приклад такої мережі з 35 вузлами:\n\nСтруктура мережі переважного приєднання ще більш очевидна при більшій кількістю вузлів. У наступному прикладі використовується 1000 вузлів:\n\nВажкі хвости цих мереж можна побачити, побудувавши їхні степеневі розподіли. Наступна функція будує розподіл степенів мережі:\n\nВикористовуючи цю функцію, наступний код візуалізує розподіл степенів для 35-вузлової та 1000-вузлових мереж переважного приєднання:\n\nМережі з переважним приєднанням мають одну цікаву властивість: вони **масштабоінваріантні**. Розподіл степенів у масштабоінваріантних мережах підпорядковується степеневому закону, що призводить до схожої структури на різних масштабах. Один із способів побачити це --- порівняти попередні гістограми. Незважаючи на дуже різні масштаби, вони мають схожу форму. Розподіл степенів вершин можна описати степеневою функцією виду:\n\n$$P(k) \\propto k^{-\\gamma}$$\n\nде $k$ --- степінь вузла, $P(k)$ --- ймовірність того, що вузол має степінь $k$, і $\\gamma$ --- показник степеневого закону. Показник $\\gamma$ зазвичай знаходиться в діапазоні від 2 до 3 для більшості реальних мереж.\n\nРозподіл степенів степеневого закону має важливі наслідки для структури та функцій мереж. Наприклад, мережі зі степеневим розподілом часто є більш надійними і стійкими до випадкових збоїв, але більш вразливими до цілеспрямованих атак на вузли з високим степенем.\n\n## Хід роботи\n\nТепер давайте проведемо порівняльний аналіз графів різної складності з використанням деяких із зазначених показників. За допомогою бібліотеки `NetworkX` розглянемо наступні типи графів:\n\n- лінійний граф --- `path_graph()`; \n- циклічний граф --- `cycle_graph()`; \n- граф-зірка --- `star_graph()`; \n- граф Ердеша-Реньї --- `erdos_renyi_graph()`; \n- граф малого світу --- `watts_strogatz_graph()`; \n- граф переважного приєднання --- `barabasi_albert_graph()`. \n\nВізуалізуємо кожен із зазначених графів:\n\nКожен із даних графів може різнитись як за своєю спектральною структурою, так і, очевидно, топологічною: деякі можуть мати вищий ступінь кластеризації, або ступеня вершини, або посередництва тощо. Розглянемо як ранжується ступінь складності кожного графа за досліджуваними нами показниками. \n\nСпочатку збережемо кожен із побудованих графів до одного масиву для ітеративного проведення розрахунків по кожному з них:\n\n### Спектральні міри складності\n\nТепер виконаємо розрахунки спектральних мір складності для кожного графу:\n\nВиведемо результат:\n\nНа рисунку (@fig-spec) можна побачити наступне:\n\n- по-перше, усі спектральні показники залишаються найбільшими саме для графу переважного приєднання, що представляється найбільш складним серед усіх інших графів;\n- по друге, згідно динаміці спектральних показників, найпростішими серед усіх графів є граф лінії, зірки та Ердеша-Реньї. Для лінії зберігається зв'язок тільки між парами послідовних вершин. Для зірки зберігається зв'язок усіх вершин із центром, але самі вони не пов'язані один із одним. \n- по третє, граф малого світу залишається другим по складності майже по всім показникам окрім спектрального розриву. Спектральний розрив говорить, що граф зірки є трохи складнішим за малий світ. Це може бути обумовлене тим, що для зірки ми спостерігаємо достатньо високий ступінь централізації. \n\n### Топологічні міри\n\nРозрахуємо для досліджуваних графів топологічні міри складності. В якості прикладу розглянемо такі міри як \n\n- максимальний ступінь вершини ($d_{max}$);\n- глобальний коефіцієнт кластеризації ($C$);\n- середній ступінь посередництва ($B_{mean}$); \n- середня довжина найкоротшого шляху ($L_{mean}$).\n\nВиводимо результат:\n\nНа рисунку (@fig-topol) можна побачити наступне:\n\n- по-перше, найбільшим максимальним ступенем вершини характеризується саме граф-зірка, центро якої з'єднаний абсолютно з усіма вершинами мережі. Другим по ступеню концентрованності можна поставити граф переважного приєднання, що, як ми вже зазначали, є найкращим представлення реальних соціальних систем. До найпростіших можна віднести графи лінії, кола та Ердеша-Реньї. \n- по-друге, глобальний коефіцієнт кластеризації вказує на те, що найвищий ступінь кластеризації спостерігається саме для графу малого світу. Закономірно за ним іде граф переважного приєднання. Найпростішими знову виявляються графи Ердеша-Реньї, лінії, кола та, цього разу, зірки. Для зірки навіть візуально видно, що всі вершини мають тенденцію слідувати тільки за однією конкретною. \n- по-третє, середній ступінь посередництва є найнижчим для зірки, графу Ердеша-Реньї, малого світу та переважного приєднання. Для цих мереж передача інформації від одного вузла до іншого не займає значну частку часу. Для лінії та кола від одного кінця графу до іншого може знадобитися досить великий проміжок часу для передачі інформації. Схожа ситуація спостерігається й для середньої довжини найкоротшого шляху, оскільки міра посередництва на пряму залежить від значення найкоротшого шляху від одного вузла до іншого.  \n","srcMarkdownNoYaml":"\n\n\n\n\n\n\n**Тема.** Найпростіші мережі та мережні міри складності.\n\n**Мета.** Навчитися використовувати елементи теорії графів для отримання спектральний і топологічних мір складності.\n\n## Теоретичні відомості\n\nДля сучасних складних систем характерна нерегулярність зв'язків і висока чисельність елементів, яка може досягати десятків і сотень тисяч. Таким системам та їх мережним моделям, які володіють нетривіальними топологічними властивостями, найбільше відповідає термін \"комплексні\". Комплексною мережею вважається система, яка \n\n- складається з великої кількості компонентів; \n- допускає «далекосяжні» зв'язки між компонентами;\n- володіє великомасштабною (у тому числі просторово-часовою) мінливістю. \n\nДана мережа є графом з досить великою кількістю вузлів різної природи, що характеризуються багатовимірним кортежем ознак і динамічно мінливими зв’язками; розподіл ознак вузлів і характеристик зв'язків може бути описаний ймовірнісною моделлю (багатомірним розподілом). \n\nОсновною причиною підвищення актуальності розробок у області теорії і практики комплексних мереж є результати сучасних досліджень реальних комп'ютерних, біологічних і соціальних мереж. Властивості багатьох реальних мереж істотно відрізняються від властивостей класичних випадкових графів з рівноймовірними зв’язками між вузлами, які донедавна розглядалися в якості їх базисного математичного модельного прототипу, і тому побудову їх моделей було запропоновано здійснювати з використанням зв'язних структур і степеневих розподілів. \n\nУ теорії комплексних мереж виділяють три основні напрямки: \n\n- дослідження статистичних властивостей, які характеризують поведінку мереж; \n- створення моделей мереж; \n- прогнозування поведінки при зміні структурних властивостей мереж. \n\nКомплексні мережі використовуються для моделювання об’єктів і систем, дослідження яких іншими способами (за допомогою спостереження або активного експерименту) недоцільні або неможливі. Комп'ютерні мережі відносяться до мереж, які постійно ростуть і розвиваються. Серед факторів, що впливають на зростання мережі в першу чергу необхідно відзначити розмір або протяжність локальної мережі, яка визначається відстанню між найвіддаленішими станціями, при якій в нормальному режимі роботи вузлів чітко розпізнаються колізії, і кількість об'єднаних у мережу комп'ютерів. Для Інтернет-мереж цей розмір називається діаметром мережі і складає приблизно 1 км відстані, що дозволяє отримати високу швидкість зв’язку та максимально можливий рівень сервісу. При зростанні мережі збільшується кількість колізій, різко падає її корисна пропускна\nздатність і швидкодія передавання сигналу. Обмеження мережі за довжиною є передумовою вибору структури мережі, розбиття її на окремі частини (сегменти), появи додаткових серверів з новою мережею зв’язків, проблеми генеруються в контексті технологій так званої \"останньої милі\". Спостерігається динаміка зростання мережі, своєрідна кластеризація, сервери виступають центрами утворених кластерів, відбувається просторове позиціонування компонент мережі у вигляді чітких ієрархічних структур. \n\nМережа розглядається як множина сегментів, кожен з яких закінчується точкою розгалуження або кінцевої вершиною мережі. Вершинами мережі є сервери, комутатори й кінцеві користувачі, загальну кількість яких позначимо $N$. Локальні комп’ютерні мережі є об'єктними прототипами графових структур і тому для їх дослідження застосовують методи теорії графів.\n\nМоделювання мереж із використанням апарата теорії графів є важливим напрямком досліджень дискретної математики. В останні роки зросла зацікавленість дослідників до складних мереж з великою кількістю вузлів, зокрема до комп'ютерних мереж, структура яких нерегулярна, складна і динамічно розвивається в часі. Для таких мереж доводиться генерувати стохастичні графи з величезною кількістю вершин. \n\nУ загальному вигляді модель комп'ютерної мережі являє собою випадковий граф, закон взаєморозміщення ребер і вершин для якого задається розподілом ймовірностей.\n\nУ даний час найпоширенішими є два основних підходи до моделювання складних мереж: \n\n- випадкові Пуассонівські графи та узагальнені випадкові графи; \n- модель \"тісного світу\" Ватса і Строґатса та її узагальнення, еволюційна модель \nзростання мережі Барабаші й Альберт.\n\nПерший передбачає генерацію випадкового графа із заздалегідь відомою кількістю вершин і заданими ймовірнісними властивостями. Його ще називають графом **Ердоша-Рені** зі сталою кількістю вершин $N$. Розподіл ступенів вузлів $k$ для цього графа визначається формулою Пуассона $P(k) = \\exp^{-\\left\\langle k \\right\\rangle} \\left\\langle k \\right\\rangle^k / k!$. Побудова графа здійснюється генеруванням, коли до $N$ відокремлених вершин послідовно додаються ребра, що з'єднують випадковим чином довільні пари вершин. Початково граф складатиметься із сукупності малих вершин, які в процесі генерування з часом розростаються до гігантського кластера зв'язаних між собою вершин, число яких є скінченною частиною загальної кількості $N$. При генерації постійно зростає ймовірність зв'язування вершин, яка досягає з часом деякого критичного значення. В результаті процесу, який має характер фазового переходу, граф спонтанно розростається до гігантського кластера вершин, пов’язаних між собою, що нагадує конденсацію краплі води в перенасиченій парі.\n\nМодель **Ваттса-Строґаца** є комп'ютерною моделлю тісного світу. Її побудова зводиться до наступного: розглядається одновимірний, замкнений у кільце, періодичний ланцюг, який складається із $N$ вершин. Спочатку кожну вершину з'єднують з іншими сусідніми, які знаходяться від неї на відстані, не більшій за $k$, а потім кожне ребро з певною ймовірністю $m$ перез'єднується з довільною вершиною, що призводить до трансформації регулярного ланцюга у граф тісного світу (@fig-watts-strogatz). Оскільки в цій моделі кількість ребер є сталою, а ймовірності реалізації графів --- різні, то вона зводиться до канонічного ансамблю графів і описує реально існуючі мережі, топологія яких не є ані цілком регулярною, ані цілком випадковою.\n\n::: {#fig-watts-strogatz}\n\n![](Images\\lab_13\\Watts-Strogatz-model.jpg)\n\nТрансформація регулярного ланцюга у граф тісного світу і далі у випадковий граф \n\n:::\n\nБільшість реальних графів підпорядковуються степеневому закону розподілу $P(k)$. Ці графи побудови мереж описуються моделлю переважного приєднання Барабаші-Альберт. Через далекоглядні взаємодії у системи не існує масштабу зміни характерних величин. Ріст і переважне приєднання є основними механізмами побудови безмасштабних (масштабно-інваріантних) мереж. \n\nНехай вузол $i$ має $k_i$ зв'язків і він може бути приєднаним (зв'язаним) до інших вузлів $k_i$. Ймовірність приєднання нового вузла до вузла $i$ залежить від ступеня $k_i$ вузла $i$. Величину $W(k_i) = k_i/\\sum_{j}k_j$ називають переважним приєднанням (preferential attachment). Не всі вузли мають однакову кількість зв'язків, тому вони характеризуються функцією розподілу $P(k)$, що визначає ймовірність того, що випадково вибраний вузол має $k$ зв'язків. Для комплексних мереж функція $P(k)$ відрізняється від розподілу Пуассона для випадкових графів. Для переважної більшості комплексних мереж спостерігається степенева залежність $P(k)\\propto k^{-\\gamma}$.\n\nУ попередній роботі ми вже ввели деякі з мір складності. Зараз же зробимо це систематично і покажемо, яким чином у межах єдиного алгоритму розрахувати і проаналізувати основні **спектральні** і **топологічні** властивості найпростіших графів. \nДля аналізу мережі досліджують характеристики окремих вузлів (локальні), характеристики мережі в цілому (глобальні), та характеристики мережних підструктур. Числові показники деяких глобальних характеристик мережі можуть бути представлені у вигляді аналітичних узагальнень її локальних характеристик (наприклад --- найменше, найбільше, середнє значення локального показника, взяте по всім вузлам). Окрім того, що глобальна характеристика може бути представлена у формі одного числа, це також може бути представлення у вигляді розподілу значень локальної характеристики вузлів по всій мережі.\n\n### NetworkX\n\nДля аналізу складних мереж і їх спектральних і топологічних характеристик можна скористатися такою бібліотекою як [**NetworkX**](https://networkx.org). \n\nNetworkX дозволяє моделювати, аналізувати та візуалізувати мережі різної природи та складності. Пакет надає класи для представлення декількох типів мереж та реалізацію багатьох алгоритмів, що використовуються в мережевій науці. NetworkX відносно простий у встановленні та використанні і має багато вбудованих функцій, тому він ідеально підходить для вивчення мережевої науки і виконання аналізу малих і середніх мереж.\n\nNetworkX є безкоштовним програмним забезпеченням з відкритим вихідним кодом. Це означає, що вихідний код доступний для читання, модифікації та розповсюдження (за певних умов). Сам код доступний за адресою https://github.com/networkx/networkx. NetworkX був написаний спільнотою з десятків дописувачів. Якщо у вас є ідея щодо нової функції або способу покращення програмного забезпечення, ви можете самостійно її запрограмувати й поділитися нею зі спільнотою.\n\n#### Встановлюємо NetworkX\n\nДля встановлення даної бібліотеки можна скористатися наступною командою:\n\nДалі можемо імпортувати відповідні бібліотеки:\n\nПам'ятайте, що оператори `import` знаходяться у верхній частині вашого коду, вказуючи Python завантажити зовнішній модуль. У цьому випадку ми хочемо завантажити NetworkX, але дамо йому короткий псевдонім `nx`, оскільки нам доведеться вводити його неодноразово, звідси й інструкція `as`.\n\nДавайте перевіримо встановлену версію NetworkX. Ми хочемо переконатися, що не використовуємо застарілий пакет.\n\nДалі виконаємо налаштування формату виведення рисунків:\n\n### Типи мереж\n\nМережі, представлені в цій лабораторній, поки що мають лише найнеобхідніше. Ці мережі називаються простими мережами, тому що вони прості. У NetworkX прості мережі представлені класом `Graph`. Назва `Graph` походить від терміну, що використовується в математиці для опису мереж. Ви можете подумати, що він означає малюнок або креслення, але в даному випадку він просто означає мережу. Математики часто використовують повсякденні слова в дуже специфічними способами, які дуже відрізняються від їх повсякденних значень, наприклад наприклад, \"граф\", \"пучок\" або \"кільце\".\n\n#### Простий граф (ненаправлений та незважений)\n\nІснує багато необов'язкових аргументів для функції draw, щоб налаштувати зовнішній вигляд.\n\n#### Зважена мережа\n\nПовертаючись до випадку неорієнтованих мереж, іноді не всі ребра є рівними. Наприклад, у мережі, що представляє міську систему водопостачання, ребра можуть представляти серію труб, якими вода транспортується з одного місця в інше. Деякі з них можуть мати більшу пропускну здатність, ніж інші. Коли ребра можуть мати різну міцність, мережа називається зваженою, а міцність кількісно вимірюється числом, яке називається вагою. Зваженими можуть бути як орієнтовані, так і неорієнтовані мережі. При візуалізації мережі вагу ребер часто вказують, змінюючи товщину або непрозорість ребра. Ваги ребер можна використовувати для для представлення різних типів атрибутів.\n\n#### Направлений граф\n\nІноді буває корисно додавати трохи більше деталей до мережі. Ребра, які ми бачили попередньо, не враховують звідки одна вершина прямує або куди; Вони просто з'єднують два вузли, тому їх називають **симетричними** або **неорієнтованими**.\n\nУявіть собі мережу, яка являє собою систему доріг (ребер) і перехресть (вузлів). A мережа з ненаправленими ребрами була б гарним представленням, доки ви не натрапили на вулицю з одностороннім рухом. Ненаправлене ребро припускає, що ви можете рухатися в будь-якому напрямку однаково. Хоча в реальності напрям руху по дорожній смузі матиме значення навіть для вашого життя.\n\nКоли напрямок має значення, мережа називається орієнтованою (направленою). В направленій мережі кожне ребро має вузол-джерело і вузол-приймач. Як правило, ребро представляє якийсь потік, наприклад, трафік, від джерела до цілі. Але що, якщо не всі з'єднання є односторонніми? Легко! Двосторонні з'єднання створюються шляхом поєднання двох спрямованих ребер, що йдуть в протилежних напрямках. У спрямованих мережах ребра зображуються стрілками, що вказують на ціль.\n\nОб'єкт граф має деякі властивості та методи, які надають дані про весь граф.\n\nОб'єкти NodeView та EdgeView мають ітератори, тому ми можемо використовувати їх у циклах `for`:\n\nЗверніть увагу, що ребра подано у вигляді 2-кортежів, так само, як ми їх ввели.\n\nМи можемо отримати кількість вершин та ребер у графі за допомогою методів `number_of_`.\n\nДеякі методи роботи з графами приймають ребро або вершину як аргумент. Вони надають властивості графа для даного ребра або вершини. Наприклад, метод `.neighbors()` повертає вершини, пов'язані з даною вершиною:\n\nЗ міркувань продуктивності багато методів для роботи з графами повертають ітератори замість списків. Їх зручно використовувати у циклах:\n\nі ви завжди можете використати конструктор `list` для створення списку з ітератора:\n\nЗверніть увагу на асиметрію в методах роботи з ребрами, таких як `has_edge()`:\n\nЗамість симетричного зв'язку \"сусіди\", вузли в орієнтованих графах мають попередників (successors або \"in-neighbours\") і наступників (predecessors або \"out-neighbours\"):\n\nСпрямовані графи мають вхідні степені вершини (in-degree) та вихідні степені вершини (out-degree), які показують кількість ребер, що ведуть до та від даної вершини, відповідно:\n\nУ NetworkX існує декілька алгоритмів компонування, які можуть бути використані для розміщення вузлів графа у візуалізації, в тому числі\n\n1. `nx.spring_layout()`: Цей алгоритм використовує примусовий підхід до розміщення вершин. Вузли, які з'єднані ребрами, притягуються один до одного, тоді як вузли, які не з'єднані, відштовхуються. Алгоритм намагається мінімізувати енергію системи, регулюючи положення вузлів.\n\n\n2. `nx.circular_layout()`: Цей алгоритм розміщує вузли рівномірно по колу.\n\n\n3. `nx.spectral_layout()`: Цей алгоритм використовує власні вектори матриці суміжності графа для розміщення вершин. Власні вектори використовуються для проектування вершин у простір нижчої розмірності, а положення вершин потім визначаються шляхом оптимізації функції вартості.\n\n\n4. `nx.random_layout()`: Цей алгоритм розміщує вершини випадковим чином у заданій обмежувальній області.\n\n\n5. `nx.shell_layout()`: Цей алгоритм розміщує вершини у вигляді концентричних кіл або оболонок, причому вершини в одній і тій же оболонці мають однакову відстань до центру.\n\n\n6. `nx.kamada_kawai_layout()`: Цей алгоритм використовує ітераційний оптимізаційний підхід для розміщення вузлів. Алгоритм намагається мінімізувати навантаження на систему, змінюючи положення вузлів.\n\n\n7. `nx.fruchterman_reingold_layout()`: Цей алгоритм є варіацією алгоритму `nx.spring_layout()`, і також використовує силовий підхід до розміщення вузлів.\n\nКожен алгоритм компонування має свої сильні та слабкі сторони, і вибір найкращого з них залежить від характеристик графа та цілей візуалізації. NetworkX дозволяє легко застосовувати ці алгоритми до ваших графів і створювати візуалізації, які допоможуть вам зрозуміти і передати структуру мережі.\n\n#### Знакова мережа\n\n#### Мультиграф\n\nМультиграф --- це тип графа в NetworkX, який допускає декілька ребер між парою вузлів. Іншими словами, `MultiGraph` може мати паралельні ребра, в той час як стандартний `Graph` може мати лише одне ребро між будь-якою парою вузлів.\n\nПростіше кажучи, Мультиграф --- це мережа, в якій декілька ребер можуть з'єднувати одні й ті ж вузли.\n\n#### Двочастковий (bipartite) граф\n\nДвочастковий граф --- це тип графа, в якому вершини можна розбити на дві непересічні множини так, що всі ребра з'єднують вершину з однієї множини з вершиною в іншій множині. Іншими словами, не існує ребер, які з'єднують вершини всередині однієї множини.\n\nДвочасткові графи корисні для моделювання відносин між двома різними типами об'єктів, наприклад, покупцями і продавцями на ринку, або акторами і фільмами в кіноіндустрії.\n\nУ NetworkX ви можете створювати і маніпулювати двосторонніми графами за допомогою модуля `bipartite`, який надає різні функції і алгоритми для двосторонніх графів. Крім того, існує декілька методів візуалізації, які можна використовувати для відображення двосторонніх графів, наприклад, двосторонній макет, який розташовує вузли у два окремі рядки.\n\nПриклад акціонерів та акцій:\n\nХоча двочасткові графи корисні для представлення повної структури зв'язків \"багато-до-багатьох\", іноді простіше працювати зі стандартними односторонніми мережами. Це може бути у випадку, якщо аналіз фокусується на певному типі вузлів, або якщо необхідна методика доступна лише для односторонніх (одномодальних) мереж, або якщо методика доступна лише для одномодових мереж, або якщо мережа зв'язків має занадто багато вузлів для чіткої візуалізації. На щастя, можна створити одномодові мережі з з мережі зв'язків за допомогою процесу, який називається \"проекція\". І, як ви могли б очікувати, NetworkX спрощує цей процес.\n\nОдномодові мережі, побудовані з мереж зв'язків, називаються мережами спільної приналежності, тому що вузли з'єднуються ребрами, якщо вони мають спільні зв'язки. Існує кілька типів проекцій, які використовуються для створення спільної приналежності, але всі вони обертаються навколо однієї і тієї ж ідеї: з'єднання вузлів зі спільним сусідом у вихідній мережі приналежності. Найпростіша можлива проекція --- це незважена проекція, яка створює незважене ребро між вузлами з одним або декількома спільними сусідами. У коді наступний код використовує функцію projected_graph() для проектування мережі акціонерів, що мають спільні акції компаній:\n\nУ такий самий спосіб ми можемо побудувати мережу акцій:\n\n### Імпортуємо інформацію про мережу \n\n#### Імпортуємо дані з file.txt та GEXF\n\nЩоб імпортувати інформацію про мережу до NetworkX, ви можете скористатися однією з декількох функцій, залежно від формату ваших даних. Ось кілька прикладів:\n\n1. Імпорт з файлу списку граней:\n\nПрипустимо, у вас є файл списку граней, що мають наступне представлення:\n\n```\nA B\nA C\nB D\nC D\nD E\n```\n\nВи можете імпортувати цей файл у граф NetworkX за допомогою функції `read_edgelist` наступним чином:\n\n2. Імпорт з файлу матриці суміжності:\n\nПрипустимо, що у вас є файл матриці суміжності у наступному форматі:\n\n```\n0 1 1 0 0\n1 0 0 1 0\n1 0 0 1 1\n0 1 1 0 1\n0 0 1 1 0\n```\n\nВи можете імпортувати цей файл у граф NetworkX за допомогою функції `from_numpy_matrix` наступним чином:\n\n3. Імпорт з файлу GEXF:\n\nЯкщо у вас є файл мережі у форматі GEXF, який є популярним форматом для обміну даних про графи між різними програмними пакетами. Ви можете імпортувати його у графік NetworkX за допомогою функції `read_gexf` наступним чином:\n\nПростий граф у форматі GEXF:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<gexf xmlns=\"http://www.gexf.net/1.3\" version=\"1.3\">\n  <meta lastmodifieddate=\"2022-10-01\">\n    <creator>NetworkX</creator>\n    <description>An example graph in GEXF format</description>\n  </meta>\n  <graph mode=\"static\" defaultedgetype=\"undirected\">\n    <nodes>\n      <node id=\"0\" label=\"Node 0\"/>\n      <node id=\"1\" label=\"Node 1\"/>\n      <node id=\"2\" label=\"Node 2\"/>\n    </nodes>\n    <edges>\n      <edge id=\"0\" source=\"0\" target=\"1\"/>\n      <edge id=\"1\" source=\"1\" target=\"2\"/>\n      <edge id=\"2\" source=\"2\" target=\"0\"/>\n    </edges>\n  </graph>\n</gexf>\n```\n\n#### Матриця суміжності\n\nперетворення матриці суміжності у граф за допомогою nx.Graph:\n\n### Графостатистичні показники \n\n#### Степінь вершини\n\nНезалежно від того, чи представляють вузли людей, місця, комп'ютери або атоми, розташування вузла в структурі мережі тісно пов'язане з роллю, яку він відіграє в загальній системі. Різні структури уможливлюють різні ролі. Отже, кількісно оцінюючи структурні властивості вузла, можна зрозуміти роль, яку відіграє цей вузол. Числові міри, які характеризують мережеві властивості вузла, називаються мірами центральності. Центральність часто вводять як міру важливості, але є багато способів, у які вузол може бути важливим. Наприклад, однією з найпростіших мір центральності є **степенева центральність (degree centrality)**. Степенева центральність вузла --- це просто кількість сусідів, які наявні у вузла (в орієнтованій мережі існують як степеневі, так і нестепеневі центральні вузли). У соціальній мережі степенева центральність є мірою популярності, і може бути хорошим способом здогадатися, хто влаштовує найкращі вечірки, хто має найбільшу кількість публікацій або хто є монополістом на ринку праці. Степенева центральність --- це досить елементарний приклад, але далі будуть представлені більш складні міри, які часто використовуються в науці складних мереж. Кожна міра центральності кількісно оцінює різний тип важливості і може бути корисною для відповідей на різні типи питань.\n\nПоказник степеневої центральності тісно пов'язаний із такою мірою як **степінь вершини в мережі (node degree)**, яка визначає кількість ребер, з якими з'єднана конкретна досліджувана вершина. У мережі з $N$ вершин і $M$ ребер, ступінь $k_i$ вершини $i$ визначається як:\n\n$$ k_i = \\sum_{j=1}^M A_{ij} $$\n\nде $A$ --- матриця суміжності мережі, де $A_{ij} = 1$, якщо існує ребро, що з'єднує вершини $i$ та $j$, і $A_{ij} = 0$ в іншому випадку.\n\nОколицею вершини $i$ називається множина вершин, які безпосередньо з'єднані з $i$ ребром. Околиця $i$ позначається як $N_i$ і визначається як:\n\n$$ N_i = \\{j \\mid A_{ij} = 1\\} $$\n\nде $A$ - матриця суміжності мережі, де $A_{ij} = 1$, якщо існує ребро, що з'єднує вершини $i$ та $j$, і $A_{ij} = 0$ в іншому випадку.\n\n#### Тріадичне закриття\n\nМіра, представлена в цьому розділі, стосується зв'язків між сусідами вузла, а не самого вузла. Часто буває корисно розглянути, чи мають сусіди вузла тенденцію бути пов'язаними один з одним. У соціальній мережі це питання зводиться до того, щоб запитати, чи товариш вашого товариша є і вашим товаришом одночасно. Ця властивість відома як **транзитивність**. Результатом таких стосунків є трикутники: три вузли, пов'язані між собою. Тенденція до виникнення таких трикутників називається **кластеризацією**. Сильна кластеризація часто свідчить про надійність і надлишковість мережі --- якщо один ребро зникає, шлях все ще існує через два інших. Кластеризація вимірюється за допомогою коефіцієнта локальної кластеризації, який визначає тенденцію вузлів об'єднуватись у тріади. Глобальний коефіцієнт кластеризації представляє середнє значення по всім локальним кластеризаціям, що були визначені для кожного вузла мережі. \n\n##### Коефіцієнт кластеризації\n\nКоефіцієнт кластеризації вершини $i$ задається формулою:\n\n$$C_i = \\frac{1}{k_i(k_i - 1)}\\sum_{j,k}A_{ij}A_{jk}A_{ki}$$\n\nде $k_i=\\sum_{j}A_{ij}$ --- кількість ребер, що входять у вершину $i$; $A$ позначає матрицю суміжності.\n\n##### Глобальний коефіцієнт кластеризації \n\nБагато спостережуваних соціальних мереж є більш кластеризованими, ніж це могло б виникнути випадковим чином\n\nКоефіцієнт кластеризації мережі є середнім значенням коефіцієнтів кластеризації всіх вузлів:\n\n$$C = \\frac{1}{N}\\sum_{i=1}^{N} C_i$$\n\nде $N$ - загальна кількість вузлів у мережі.\n\n##### Транзитивність\n\nТранзитивність --- це властивість мережі, яка вимірює ймовірність того, що якщо два вузли мережі мають спільного сусіда, то вони також будуть безпосередньо з'єднані один з одним. Іншими словами, вона вимірює тенденцію до утворення \"трикутників\" у мережі.\n\nФормально транзитивність мережі визначається як відношення кількості трикутників у мережі до кількості з'єднаних трійок вузлів (тобто трійок вузлів, які безпосередньо з'єднані один з одним або мають спільного сусіда). У математичній нотації транзитивність мережі позначається як:\n\n$$\nT = \\frac{\\sum_{i,k,j=1}^{N}A_{ik}A_{kj}A_{ji}}{\\sum_{i,k,j=1}^{N}A_{ik}A_{ji}}.\n$$\n\nВисока транзитивність вказує на те, що вузли в мережі мають тенденцію до утворення трикутних кластерів або спільнот, тоді як низька транзитивність вказує на те, що мережа є більш випадковою або децентралізованою структурою. Транзитивність тісно пов'язана з поняттям коефіцієнта кластеризації, який вимірює схильність вузлів до утворення локальних кластерів або спільнот.\n\n#### Шлях\n\nШлях між двома вузлами $A$ та $B$ у мережі - це послідовність вузлів $A, X_1, X_2, ..., X_n, B$ та послідовність ребер $(A, X_1), (X_1, X_2), ..., (X_n, B)$, де кожен вузол та ребро у послідовності є суміжним з попереднім та наступним вузлом або ребром у послідовності.\n\nДовжина шляху --- це кількість ребер у ньому. Шлях довжиною 1 --- це ребро між двома вершинами, шлях довжиною 2 --- послідовність з двох ребер і трьох вершин, і так далі. Найкоротший шлях між двома вершинами --- це шлях мінімальної довжини, який їх з'єднує.\n\n##### Цикл\n\n##### Геодезична лінія\n\nГеодезичний шлях між двома вузлами $A$ і $B$ в мережі --- це найкоротший шлях, який їх з'єднує. Іншими словами, це шлях з мінімальною кількістю ребер, які потрібно пройти, щоб дістатися з вузла $A$ до вузла $B$. Довжина геодезичного шляху --- це кількість ребер у цьому шляху.\n\nПошук геодезичного шляху від вузла i до кожного іншого вузла є обчислювально складним, тому нам потрібен ефективний алгоритм для цього.\n    \nТут ми використовуємо пошук в ширину\n\n##### Зв'язні компоненти\n\nУ простій мережі вище ми бачимо, що для *кожної* пари вершин можна знайти шлях, який їх з'єднує. Це і є визначенням *зв'язного* графа. Ми можемо перевірити цю властивість для заданого графа:\n\nНе кожен граф зв'язний:\n\nА NetworkX видасть помилку, якщо ви запитаєте шлях між вузлами, якого не існує:\n\nВізуально ми можемо ідентифікувати дві пов'язані компоненти на нашому графі. Давайте перевіримо це:\n\nФункція `nx.connected_components()` отримує граф і повертає список наборів імен вершин, по одному такому набору для кожної зв'язної компоненти. Перевірте, чи відповідають дві множини у наступному списку двом зв'язним компонентам на рисунку графа вище:\n\nЯкщо ви не знайомі з множинами у Python, це колекції елементів без дублікатів. Вони корисні для збору імен вузлів, оскільки імена вузлів повинні бути унікальними. Як і у випадку з іншими колекціями, ми можемо отримати кількість елементів у множині за допомогою функції `len`:\n\nНас часто цікавить найбільша зв'язна компонента, яку іноді називають *ядром* мережі. Ми можемо скористатися вбудованою функцією `max` у Python, щоб отримати найбільший зв'язну компоненту. За замовчуванням функція `max` у Python сортує дані у лексикографічному (тобто алфавітному) порядку, що не є корисним у даному випадку. Ми хочемо отримати максимальний зв'язаний компонент при сортуванні в порядку його розміру, тому ми передаємо `len` як ключову функцію:\n\nХоча часто достатньо мати лише список назв вершин, іноді нам потрібен власне підграф, що містить найбільш зв'язну вершину. Один із способів отримати її --- передати список назв вершин у функцію `G.subgraph()`:\n\nТі з вас, хто використовує завершення написання коду за допомогою табуляції, також помітять функцію `nx.connected_component_subgraphs()`. Її також можна використати для отримання основного підграфа, але представлений метод є більш ефективним, якщо вас цікавить лише найбільший зв'язна компонента.\n\n##### Направлені шляхи та компоненти\n\nДавайте поширимо ці ідеї про шляхи та зв'язні компоненти на орієнтовані графи.\n\nМи знаємо, що в орієнтованому графі ребро з довільної вершини $u$ до довільної вершини $v$ не говорить про те, що існує ребро з $v$ до $u$. Тобто, для направленого графу ми спостерігатимемо асиметрію шляхів. Зверніть увагу, що цей граф має шлях від 1 до 4, але не у зворотному напрямку.\n\nІнші функції NetworkX, що працюють зі шляхами, також враховують цю асиметрію:\n\nОскільки немає ребра з 5 в 3, найкоротший шлях з 5 в 2 не може просто пройти назад по найкоротшому шляху з 2 в 5 --- він повинен пройти довшим шляхом через вузли 6 і 4.\n\nНаправлені мережі мають два типи зв'язності. *Сильно зв'язні* означають, що між кожною парою вузлів існує спрямований шлях, тобто з будь-якого вузла ми можемо дістатися до будь-якого іншого вузла, дотримуючись спрямованості ребер. Уявіть собі автомобілі на мережі вулиць з одностороннім рухом: вони не можуть їхати проти потоку транспорту.\n\n*Слабка зв'язність* говорить про те, що між кожною парою вузлів існує шлях, незалежно від напрямку. Подумайте про пішоходів у мережі вулиць з одностороннім рухом: вони ходять по тротуарах, тому їх не хвилює напрямок руху.\n\nЯкщо мережа сильно зв'язана, вона також є і слабко зв'язаною. Зворотне не завжди вірно, як видно з цього прикладу.\n\nФункція `is_connected` для неорієнтованих графів видасть помилку, якщо задано орієнтований граф.\n\nУ випадку направленого графа замість `nx.connected_components` тепер маємо `nx.weak_connected_components` та `nx.strong_connected_components`:\n\n#### Ексцентриситет\n\nЕксцентриситет вершини $u$ в мережі --- це максимальна відстань між $u$ та будь-якою іншою вершиною мережі. Іншими словами, це максимальна довжина найкоротшого шляху між $u$ та будь-якою іншою вершиною. Ексцентриситет мережі --- це максимальний ексцентриситет будь-якого вузла мережі.\n\n#### Центральність\n\nНезалежно від того, чи представляють вузли людей, місця, комп'ютери або атоми, розташування вузла в структурі мережі тісно пов'язане з роллю, яку він відіграє в загальній системі. Різні структури уможливлюють різні ролі. Отже, кількісно оцінюючи структурні властивості вузла, можна зрозуміти роль, яку відіграє цей вузол. Числові міри, які характеризують мережеві властивості вузла, називаються мірами **центральності**. Центральність часто вводять як міру важливості, але є багато способів, у які вузол може бути важливим. Наприклад, однією з найпростіших мір центральності є **степенева центральності**. Степенева центральність вузла --- це просто кількість сусідів, яких він має (у спрямованій мережі є як степеневі, так і нестепеневі сусіди). У соціальній мережі степенева центральність є мірою популярності, і може бути хорошим способом здогадатися, хто влаштовує найкращі вечірки. Степенева центральності є досить примітивним прикладом, але в наступних лабораторних будуть представлені більш складні показники, які часто використовуються в мережевій науці. Кожна міра центральності кількісно вимірює різний тип важливості і може бути корисною для відповідей на різні типи питань.\n\n##### Степенева центральність --- ненаправлені графи\n\nСтепенева центральність --- це міра важливості вузла в мережі, що базується на кількості зв'язків, які він має з іншими вузлами. Степеневу центральність вершини $i$ можна обчислити як:\n\n$$C_D(i) = \\frac{k_i}{n-1}$$\n\nде $k_i$ --- степінь вершини $i$, тобто кількість ребер, інцидентних вершині, а $n$ --- загальна кількість вершин у мережі. Знаменник $n-1$ використовується для того, щоб врахувати той факт, що вершина не може бути з'єднана сама з собою.\n\nСтепенева центральність вузла коливається від 0 до 1, причому більше значення вказує на те, що вузол є більш центральним у мережі. Вузли з високою степеневою центральності, як правило, добре пов'язані з іншими вузлами, і їх видалення з мережі може мати значний вплив на її зв'язність.\n\nРозглянемо деякі показники на прикладі графу **карате-клубу**.\n\n::: {.callout-tip title=\"Відомості про граф карате-клубу\"}\n\nГраф карате-клубу --- це соціальна мережа, що представляє дружбу між 34 членами карате-клубу, як це спостерігав Вейн В. Захарі у 1977 році. Кожна вершина графа представляє члена клубу, а кожне ребро --- дружбу між двома членами. Граф має 34 вершини та 78 ребер.\n\nКарате-клуб є відомим прикладом аналізу соціальних мереж і використовувався для вивчення різних властивостей мережі, таких як структура спільноти і міра центральності. Граф характеризується розколом клубу на дві фракції, очолювані інструкторами клубів: вершина 1 та вершина 34. Цей розкол був спричинений суперечкою між двома лідерами, яка врешті-решт призвела до утворення двох окремих клубів карате.\n\n:::\n\n##### Степенева центральність --- направлені графи\n\n##### Ступінь близькості\n\nМіра, відома як ступінь близькості, є однією з найстаріших мір центральності, що використовується в мережевій науці, запропонована соціологом Алексом Бавеласом у 1950 році. Близькість визначається як зворотна величина до віддаленості. Що таке віддаленість? Більш зрозуміло, віддаленість вузла --- це сума відстаней між цим вузлом і всіма іншими вузлами. Отже, вузол з високою центральністю близькості знаходиться буквально поруч з іншими вузлами. Центральність вузла вимірює, наскільки швидко він може поширювати інформацію або вплив по всій мережі, оскільки вузли з меншою середньою відстанню до всіх інших вузлів можуть спілкуватися більш ефективно. Крім того, вузли з високим показником центральності часто розташовані в центрі мережі, і їх видалення може мати значний вплив на зв'язність мережі.\n\nСтупінь близькості вузла $i$ можна обчислити як:\n\n$$C_C(i) = \\frac{1}{\\sum\\limits_{j \\neq i} d_{ij}}$$\n\nде $d_{ij}$ - найкоротша відстань між вузлами $i$ та $j$. Ступінь близькості вузла коливається від 0 до 1, причому більше значення вказує на меншу середню відстань до всіх інших вузлів мережі.\n\nУ наступному прикладі використовується функція NetworkX `closeness_centrality()` для обчислення значень центральності для мережі карате клубу та відображення 10 найближчих один до одного каратистів:\n\n##### Ступінь посередництва\n\nУ популярній дитячій грі \"Телефон\" один гравець починає з того, що шепоче повідомлення іншому, той шепоче це повідомлення іншому і так далі. Врешті-решт, останній гравець промовляє повідомлення вголос. Як правило, фінальне повідомлення не має нічого спільного з початковим. Так, повідомлення, яке починалося як \"слідуй за фанковою течією\", може закінчитися як \"якби кожна свиняча відбивна була ідеальною, у нас не було б хот-догів\". Кожного разу, коли повідомлення передається від людини до людини, воно може змінюватися, можливо, через те, що його неправильно почули, а можливо, через те, що його навмисно змінили. У більш складних соціальних мережах, таких як організації та громадські рухи, особи, які з'єднують різні частини мережі, мають найбільші можливості фільтрувати, посилювати та змінювати інформацію. Таких людей називають брокерами, а ребра, що з'єднують віддалені частини мережі, --- мостами. Важливість таких вузлів і ребер не обмежується соціальними мережами. У потокових мережах --- таких як залізниці, водопроводи та телекомунікаційні системи --- вузли що з'єднують віддалені частини мережі, можуть діяти як вузькі місця, обмежуючи обсяг потоку. Виявлення таких вузьких місць дає змогу збільшити їхню пропускну здатність і захистити їх від збоїв та атак. Мости і брокери важливі, тому що вони знаходяться між різними частинами мережі. Відповідно, тип центральності, який використовується для визначення мостів і брокерів називається **cтупенем посередництва**.\n\nСтупінь посередництва --- це міра того, наскільки вузол лежить на найкоротших шляхах між іншими вузлами мережі. Ступінь посередництва для вузла $i$ можна обчислити як:\n\n$$C_B(i) = \\sum\\limits_{s \\neq i \\neq t} \\frac{\\sigma_{st}(i)}{\\sigma_{st}}$$\n\nде $s$ і $t$ --- два вузли мережі, $\\sigma_{st}$ --- загальна кількість найкоротших шляхів між $s$ і $t$, а $\\sigma_{st}(i)$ --- кількість найкоротших шляхів між $s$ і $t$, які проходять через вузол $i$. \n\nСтупінь посередництва змінюється від 0 до 1, причому більше значення вказує на більшу кількість найкоротших шляхів, що проходять через вершину. Вузли з високим значенням центральності часто розташовані на \"мостах\" між різними кластерами або спільнотами в мережі, і їх видалення може мати значний вплив на зв'язність мережі.\n\nСтупінь посередництва базується на припущенні, що чим більше найкоротших шляхів проходить через вершину (або ребро), тим більше вона виступає в ролі брокера (або моста). Для ступеня посередництва знаходять найкоротші шляхи між кожною парою вузлів. Значення ступеня посередництва для вузла або ребра --- це просто кількість цих шляхів, що проходять через нього. Тут є кілька застережень. По-перше, за домовленістю, шляхи не вважаються такими, що проходять через їхні кінцеві точки і не враховуються при визначенні посередництва між ними. Крім того, вам може бути цікаво, що станеться, якщо є два найкоротших шляхи однакової довжини. У цьому випадку кожен шлях робить 1/2 внеску в посередництво своїх вершин/ребер (або 1/3, якщо є 3 шляхи, і так далі).\n\nНа наступній діаграмі показано приклад мережі та розраховані значення посередництва для кожної вершини та ребра. Для кожної пари вершин показано найкоротший шлях (за винятком тривіальних шляхів довжиною 1). Посередництво вузла --- це сума шляхів, які проходять через цей вузол. Посередництво ребра --- це кількість нетривіальних шляхів, які проходять через це ребро, плюс 1 для самого ребра:\n\n::: {#fig-betweenness}\n\n![](Images\\lab_13\\betweenness.png)\n\nУсі нетривіальні найкоротші шляхи у прикладі мережі та отримані центри посередництва \n\n:::\n\nСтупінь посередництва між вузлами легко обчислюється в NetworkX за допомогою функції `betweenness_centrality()`. Ця функція повертає словник, який зіставляє позначення вузлів зі значеннями посередництва. Якщо аргумент `normalized` має значення `True` (за замовчуванням), значення ступеня посередництва ділиться на кількість пар вузлів, що може бути корисним для порівняння значень посередництва, що мають різні масштаби. Якщо аргумент `endpoints` має значення `True` (за замовчуванням False), то кінцеві точки шляху будуть включені в розрахунок посередництва.\n\nВидно, що високим рівнем посередництва характеризуються вершини 1, 34 і 33. Високий рівень посередництва між ними свідчить про те, що ці особи є важливими інформаційними посередниками в клубі карате. Можливо, вони є найбільш вправними каратистами. \n\nЦентральність посередництва для ребер --- це міра того, наскільки ребро лежить на найкоротших шляхах між іншими ребрами в мережі. Посередництво ребра $e$ можна обчислити наступним чином:\n\n$$C_B(e) = \\sum_{s \\neq e \\neq t} \\frac{\\sigma_{st}(e)}{\\sigma_{st}}$$\n\nде $s$ і $t$ --- дві вершини мережі, $\\sigma_{st}$ --- загальна кількість найкоротших шляхів між $s$ і $t$, а $\\sigma_{st}(e)$ --- кількість найкоротших шляхів між $s$ і $t$, які проходять через ребро $e$.\n\nСтупінь посередництва ребра змінюється від 0 до 1, причому більше значення вказує на більшу кількість найкоротших шляхів, які проходять через ребро. Ребра з високою посередництвом часто розташовані на \"мостах\" між різними кластерами або спільнотами в мережі, і їх видалення може мати значний вплив на зв'язність мережі.\n\nЯкщо розглядати, наприклад, топ 3 ребер із найбільшим ступенем посередництва, ми побачимо, що, як правило, найкраща комунікація проходить у тренера з учнями під номерами 32, 7, 6, 3 тощо. \n\n##### Ступінь впливовості\n\nУявіть, що у вас є важливе повідомлення, яке потрібно донести до цілої групи (наприклад, до вашого роботодавця або школи), але ви можете передати його лише одній людині. Кому б ви це сказали? Ви б хотіли знайти когось, хто має хороші зв'язки з усією мережею. Ви можете спробувати звернутися до людини з найвищою степеневою центральністю (найбільшою кількістю друзів). Недоліком такого підходу є те, що її друзі можуть бути не дуже добре пов'язані з рештою мережі. Наприклад, у гіпотетичній компанії директор з продажу на східному узбережжі може знати найбільше людей, але не знати, як зв'язатися з іншими відділами чи регіонами. Замість нього краще знайти когось, хто має тісні зв'язки з іншими людьми, які мають тісні зв'язки, наприклад, генерального директора (або, що більш ймовірно, його помічника). Таких людей іноді називають **хабами**, тому що, подібно до центру колеса зі спицями, вони з'єднують між собою багато різних точок. Цю концепцію високозв'язних хабів добре відображає показник, який називається **ступенем впливовості**.\n\nСтупінь впливовості вершини $i$ можна визначити через головний власний вектор матриці суміжності $\\mathbf{A}$ мережі:\n\n$$\\mathbf{Av} = \\lambda \\mathbf{v}$$\n\nде $\\mathbf{v}$ --- власний вектор, що відповідає найбільшому власному значенню $\\lambda$. Ступінь впливовості вершини $i$ задається $i$-им елементом $\\mathbf{v}$.\n\nСтупінь впливовості вузла коливається від 0 до 1, причому більше значення вказує на більшу важливість вузла та його сусідів у мережі. Вузли з високим ступенем впливовості часто розташовані в центрі мережі і добре пов'язані з іншими сильно пов'язаними вузлами, і їх видалення може мати значний вплив на зв'язність мережі.\n\n### Широкомасштабний опис мереж \n\nШирокомасштабні структури можуть сильно відрізнятися від мережі до мережі. Ці відмінності часто вказують на різні типи мереж (наприклад, соціальні та технологічні). Широкомасштабні структури також можуть мати важливі наслідки для функціональних властивостей, таких як як стійкість до збоїв і атак. Розглянемо аналіз структурних показників для мереж різних типів. \n\nЯк ви вже могли переконатися на прикладі графу карате-клубу, NetworkX надає декілька вбудованих наборів мережевих даних, які можна використовувати для тестування та експериментів. Ці набори даних доступні в самій бібліотеці NetworkX і можуть бути завантажені за допомогою функцій, які починаються з префікса `nx.`, за яким слідує назва набору даних.\n\nОсь кілька прикладів вбудованих мережевих наборів даних у NetworkX:\n\n- `nx.karate_club_graph()` - повертає мережу Zachary's Karate Club, соціальну мережу карате-клубу, де кожен вузол представляє члена клубу, а кожне ребро представляє дружні стосунки між членами.\n\n- `nx.les_miserables_graph()` - Повертає мережу персонажів роману Віктора Гюго \"Знедолені\", де кожен вузол представляє персонажа роману, а кожне ребро представляє спільну появу двох персонажів у главі.\n\n- `nx.davis_southern_women_graph()` - Повертає мережу соціальних взаємодій між жінками у містечку на півдні США у 1930-х роках, де кожен вузол представляє жінку, а кожне ребро - соціальні стосунки між двома жінками.\n\nЦе лише кілька прикладів вбудованих мережевих наборів даних в NetworkX. Ви можете знайти більше інформації про доступні набори даних та їх використання в документації NetworkX.\n\nНаступний код візуалізує три приклади мереж:\n\n#### Діаметр і найкоротший шлях\n\nМережі можуть бути охарактеризовані відповідно до розподілу довжини найкоротшого шляху. Наведена нижче функція будує гістограму всіх найкоротших шляхів у мережі:\n\nТепер давайте порівняємо розподіл довжин шляхів для трьох мереж:\n\nУсі три графи мають достатньо малі найкоротші шляхи. Соціальні мережі, як правило, мають короткі шляхи, відомий як феномен малого світу. \n\nХоча розподіл повної довжини шляху є інформативним, він є дещо громіздким, тому корисно використовувати агреговані показники. Однією з таких мір є середня довжина найкоротшого шляху, яку можна обчислити наступним чином:\n\n::: {.callout-warning}\n\nУ роз'єднаній мережі, де мережа може бути розділена на дві або або більше компонентів без ребра між ними, середня довжина шляху стає нескінченною. Цю проблему можна вирішити кількома способами, наприклад використання гармонічного, а не арифметичного середнього, або усереднення середнього значення найкоротших шляхів у межах кожної зв'язної компоненти. Який метод є доречним, залежить від типу мережі, що аналізується.\n\n:::\n\nКрім того, розмір мережі може бути охарактеризований найбільшою довжиною шляху довжиною, яка називається **діаметром**. Діаметри трьох прикладів мереж можна знайти за допомогою функції `diameter()`:\n\nЯк ми можемо бачити результати доволі схожі на попередні. На відміну від середньої довжини найкоротшого шляху, діаметр залежить лише від одного шляху. Як наслідок, один викид може значно збільшити діаметр. Однак у такому разі діаметр може бути гарним показником найгіршої довжини шляху.\n\n#### Вимірювання стійкості мережі\n\nСтійкість --- це здатність системи протистояти збоям і атакам. Наприклад, в електромережі стійкість означає продовження подачі електроенергії, коли лінія електропередач або генератор вийшли з ладу. У дорожньому русі це може означати можливість перенаправляти автомобілі, коли вулиця перекрита через аварію.\n\nСтійкість --- це фундаментальна властивість мережі, оскільки вона зазвичай досягається за допомогою резервних шляхів. Коли один шлях більше не доступний, інші все ще можуть бути використані.\n\nНайпростішим (і найгрубішим) показником стійкості є **щільність мережі**: частка можливих ребер, які існують. Чим більше ребер у мережі, тим більше надлишкових шляхів існує між її вузлами. Наступний код використовує функцію `density()` для обчислення цього значення:\n\nМережа зазвичай вважається розрідженою, якщо кількість ребер близька до $N$ (кількість вузлів), і щільною, якщо кількість ребер близька до $N^2$.\n\nМожна бачити, що найбільш стійкою (щільною) серед усіх трьох графів є мережа жінок. \n\n#### Найменші розрізи\n\nБільш складні показники відмовостійкості базуються на концепції найменших розрізів. **Найменший розріз** або **min-cut** --- це кількість вузлів (або ребер), які потрібно видалити, щоб розділити мережу на дві незв'язані частини. Найменші розрізи можна знайти або між двома конкретними вузлами, або над усіма парами вузлів. \n\nУ NetworkX найменший розріз між двома вузлами знаходять за допомогою функції `minimum_st_node_cut()`. Зауважте, що ця функція знаходиться у пакеті `connectivity` і має бути імпортована окремо на додачу до базового пакету `networkx`. Наступний код знаходить мінімальну довжину шляху між містером Хі та Джоном А. у мережі карате-клубу:\n\nПопередній результат говорить про те, що вузли 2, 8, 12, 19, 30, 31 потрібно видалити, щоб розділити мережу на дві половини, одна з яких містить містера Хі, а інша міститиме Джона А.\n\nАналогічно, найменший розріз ребер може бути знайдений наступним чином:\n\nЯкщо вам потрібно знати лише розмір найменшого розрізу, ви можете скористатися функціями `node_connectivity()` або `edge_connectivity()` у базовому пакеті `networkx`. У наступному прикладі обчислюються ці значення для мережі карате-клубу:\n\n#### Зв'язність\n\nНайменші розрізи можуть бути використані для визначення показників зв'язності для всієї мережі. Ці міри дуже корисні для кількісної оцінки стійкості мережі.\n\nЗв'язність вузлів --- це найменший мінімальний розріз між усіма парами вузлів. Зв'язність ребер визначається аналогічно. Фактичні значення розрізів між вузлами та ребрами можна знайти за допомогою пакету `connection`:\n\nЗв'язність можна обчислити за допомогою функцій `node_connectivity()` та `edge_connectivity()`, не вказуючи вихідні та цільові вузли. У наступному прикладі обчислюється зв'язність вузлів для трьох прикладів мереж:\n\nЗдається, що всі ці мережі, окрім мережі жінок, можна роз'єднати, видаливши лише один вузок. Для мережі жінок потребується видалити два вузли.\n\nПопередня міра зв'язності знаходить розмір найменшого мінімального розрізу, але його видалення не вплине на всі шляхи в мережі. Після видалення вузла або ребра мережа буде розділена, але в кожній половині вузли все ще будуть з'єднані один з одним.\n\nКращий показник надійності можна знайти, усереднивши зв'язність по всіх вузлах або ребрах за допомогою функцій `average_node_connectivity()` і `average_edge_connectivity()`. Зауважте, що обчислення цих значень може зайняти багато часу, навіть для невеликих мереж. Наступний код обчислює середню зв'язність вузлів для досліджуваних мереж:\n\nМережа каратистів та персонажів роману доволі подібні один до одного по зв'язності, але мережа жінок представляється найбільш стійкою або, іншими словами, організованою.\n\n#### Централізація та нерівномірність\n\nМережі також можна класифікувати за ступенем централізації --- наскільки вони зосереджені в одному або декількох вузлах. Нерівномірний розподіл є більш централізованим. Наприклад, найбільш централізованою мережею є мережа, всі вузли якої під'єднані до одного вузла-хабу. Наступний код будує гістограми ступенів впливовості для кожної з мереж:\n\nЗ представлених гістограм видно, що найвищі значення впливовості приходять на мережу жінок. Найгіршою за впливовістю предстає мережа персонажів роману. \n\nВиміряти нерівномірність набору значень можна за допомогою ентропії Шеннона. Концепцію ми вже розглядали в попередніх лабораторних, але достатньо знати, що чим більш рівномірно розподіленим є набір чисел, тим вища його ентропія. Наступна функція повертає ентропію списку чисел:\n\nОбчислення ентропії ступенів впливовості у кожній з мереж дає наступний результат:\n\nНайбільш рівномірно розподіленою в даному випадку представляється мережа персонажів роману. Мережі карате-клубу та жінок мають трохи вищий ступінь централізації. \n\nУ соціальних мережах не всі стосунки є рівними. Ви можете підписати заявку на кредит для свого брата чи сестри, але навряд чи для сажотруса вашого стоматолога стоматолога. У соціології міцність стосунків вимірюється поняттям **міцність зв'язності**. У цьому контексті зв'язність --- це певний вид міжособистісних стосунків, а міцність --- це будь-яка міра того, наскільки інтенсивними чи інтимними є ці стосунки (зв'язності).\n\nУ 1973 році соціолог Марк Грановеттер описав важливість слабких зв'язків для зближення різних спільнот. Якщо всі зв'язки всередині спільноти сильні, то будь-які зв'язки між спільнотами мають бути слабкими. Він назвав це явище силою слабких зв'язків. З'єднуючи різні спільноти, слабкі зв'язки дають змогу знаходити інформацію з віддалених частин мережі. Але як виміряти силу зв'язностей?\n\n#### Сила зв'язності\n\nУ мережі карате-клубів немає ніякої додаткової інформації про міцність ребер, але є відповідні властивості цих ребер, які можна обчислити, наприклад, сила зв'язності. Сила зв'язності зростає зі збільшенням кількості сусідів, які мають спільні вершини. Це мотивовано спостереженням, що близькі друзі, як правило, мають більше спільних друзів, і це часто може дати уявлення про структуру соціальної мережі. Наступний код обчислює силу зв'язку, використовуючи метод `neighbors()` для пошуку сусідів вузлів та множини Python для обчислення кількості спільних сусідів:\n\nТут ми визначили міцність зв'язку як кількість спільних сусідів плюс один. Чому плюс один? Нульова вага умовно означає відсутність ребра, тому без додаткової одиниці ребра між вершинами, які не мають спільних сусідів, не вважатимуться ребрами.\n\n::: {.callout-note}\n\nТут можна поцікаватись, чи існує теоретичне пояснення цього \"додаткового друга\". Якщо у вас з другом немає спільних друзів, є один з його друзів, з яким ви досить добре знайомі --- це ви самі. Отже, додаткову одиницю можна інтерпретувати як таку, що вказує на зв'язність ребра самого із собою.\n\n:::\n\nНаступний код обчислює силу зв'язності кожного ребра і зберігає її в змінну `strength`:\n\n#### Мостовий проліт\n\nМіцність зв'язків також можна оцінити кількісно, розглядаючи ефект видалення ребра з мережі. Вузли, з'єднані ребром, завжди знаходяться на відстані в 1 крок один від одного (у незваженій мережі). Але якщо це ребро видалити, його кінцеві точки можуть знаходитись на відстані в 2 кроки, і навіть до зовсім не з'єднаних між собою. Цю концепцію відображає **мостовий проліт** --- відстань між кінцевими точками ребра, якщо це ребро видалити. Ребра з великим прольотом з'єднують віддалені частини мережі, тому їх можна вважати слабкими зв'язками, незважаючи на те, що вони відіграють важливу роль.\n\nНаступний код обчислює довжину кожного ребра в мережі карате-клубу:\n\n#### Порівняння міцності та прольоту\n\nРозглянемо 10 найміцніших і 10 найслабших ребер у мережі карате-клубів. Наступний код виводить ці ребра:\n\nРезультат вище показує, що ребра з низькою міцністю і великим прольотом, як правило, є зовнішніми, з'єднуючи членів клубу, які розкололися на різні клуби-відколи. З іншого боку, ребра з високою міцністю і малим прольотом є внутрішніми, вони з'єднують членів клубу, які залишилися разом після розколу.\n\n#### Спектральні міри складності\n\nУ теорії графів і комбінаториці є багато теорем, при доказі яких застосовуються спектри графів, хоча вони і не зустрічаються у формулюванні теорем. Отже, використання спектрів грає роль досить важливого методу, який називається спектральним.\n\nСпектром графа $G$ називається множина власних значень матриці, що відповідає даному графу. Відомі декілька підходів встановлення зв'язку між графом $G$ та його спектром. Для випадку регулярних графів (якими є графи часових рядів фондових індексів) \nможна показати, що різні види спектрів еквівалентні, тобто містять однакову кількість інформації про структуру графу $G$.\n\nМи вже згадували, що одним із способів представлення графа у вигляді матриці є матриця суміжності. Матриця Лапласа (Laplacian matrix) $L$ --- також є одним видів подання графа. Вона може бути використана для розрахунку кількості остовних дерев для графа. Для \nзнаходження матриці Кірхгофа використовують формулу: $L=D-A$, де $D$ --- діагональна матриця:\n\n$$\nd_{ij} = \\begin{cases}\n            d_i, & i=j,\\\\\n            0, & i \\neq j, \n        \\end{cases}\n$$\n\nде $d_i$ --- ступінь відповідної вершини графа. Отже, \n\n$$\nl_{ij} = \\begin{cases}\n    d_i, & i=j, \\\\\n    -1, & i \\neq j \\, \\text{і} \\, v_i \\, \\text{суміжна з} \\, v_j, \\\\\n    0 & \\text{в іншому випадку}. \n\\end{cases}\n$$\n\n**Algebraic connectivity** (алгебраїчна зв'язність графу) --- друге найменше власне значення матриці Лапласа. Це власне значення більше 0, тоді і тільки тоді, коли граф  зв'язний. Величина цього значення відображає, наскільки добре граф пов'язує ці компоненти, \nі була використана при аналізі надійності та синхронізації мереж. Бібліотека `NetworkX` містить метод `algebraic_connectivity()` для обчислення даного показника. Бібліотека також надає змогу розрахувати нормалізовану матрицю Лапласа. Сенс нормалізації полягає в тому, що вершина з великим степенем вершини, яку також називають **важкою вершиною**, призводить до того, що в матриці Лапласа з'являється великий діагональний елемент, який домінує у властивостях матриці. Нормалізація спрямована на те, щоб зробити вплив таких вершин більш рівним впливу інших вершин, шляхом ділення елементів матриці Лапласа на степені вершин. Щоб уникнути ділення на нуль, ізольовані вершини з нульовими степенями виключаються з процесу нормалізації.\n\nМожемо бачити, що найбільш зв'язним у даному випадку представляється саме граф жінок. Тобто спілкування та кооперація між ними залишається найбільш тісною. \n\n**Graph energy** (енергія графу) --- це сума  абсолютних значень власних значень матриці суміжності графу. Нехай $G$ є граф з $n$ вершинами. Передбачається, що $G$ --- простий, тобто він не містить петлі чи паралельних ребер. Нехай $A$ --- матриця суміжності графу $G$ і $\\lambda_i$, $i=1,...,n$ --- власні значення матриці $A$. Тоді енергія графу визначається як:\n\n$$\nE(G) = \\sum_{i=1}^{n}\\left| \\lambda_i \\right|.\n$$\n\n\n\nВбудованого методу в `NetworkX` для визначення енергії графу немає, але ми доволі запросто можемо розрахувати спектр власних значень матриці суміжності, а потім скористатися формулою вище. Власні значення матриці $A$ можна знайти за допомогою методу `adjacency_spectrum()`. Далі визначимо наступну функцію для розрахунку енергії графу:\n\nТепер розрахуємо енергію для кожного досліджуваного графа:\n\nНайвище значення енергії графу вказує на найвищу складність мережі або на найвищий ступінь централізованості деяких вузлів. Для наших графів видно, що найвища енергія приходить саме граф персонажів роману. Тобто, тут є декілька персонажів на які приходить найбільша кількість зв'язків (діалогів) у порівнянні з іншими персонажами.\n\n**Спектральний розрив** (spectral gap) --- різниця між найбільшим і другим за величиною власного значення, надає інформацію про те, як швидко досягається синхронний стан. Можемо визначити й прорахувати наступну функцію:\n\n**Спектральний радіус** є найбільшим за модулем власним значенням:\n\n$$\nr(A) = \\max_{\\lambda \\in Spec(A)} \\left| \\lambda \\right|,\n$$\n\nде $Spec(A)$ --- спектр власних значень матриці суміжності. Для розрахунків визначимо наступну функцію:\n\n**Спектральний момент**. Для визначення $k$-ого спектрального моменту використовують матрицю суміжності. Визначимо її наступним чином:\n\n$$\nm_k(A)=\\frac{1}{n}\\sum_{i=1}^{n}\\lambda_{i}^{k},\n$$\n\nде $\\lambda_i$ --- власні значення матриці суміжності $A$, $n$ --- вершини графу $G$. Значення $k$ у нашому випадку випадку буде дорівнювати 3. Тобто, будемо обчислювати спектральний момент 3-го порядку. Визначимо наступну функцію для розрахунку даного показника:\n\nОстанні показники говорять по те, що персонажі роману характеризуються найвищим ступенем складності в порівнянні з іншими графами. Ми показали, що достатня кількість вузлів має досить невисокий найкоротший шлях, але може мати гіршу щільність зв'язності вузлів або рівнорозподіленності ступеня впливовості.\n\n#### Проблема малого світу\n\nУ 1967 році соціальні психологи Джеффрі Треверс і Стенлі Мілґрем надіслали листи групам людей у Вічіті, штат Канзас, та Омасі, штат Небраска. Вони також обрали одну цільову особу в штаті Массачусетс. Кожному отримувачу листа було доручено переслати його знайомому, який, найімовірніше, знав цільову людину. Багато листів дійшли до адресата, і дослідники змогли з'ясувати, скільки кроків було зроблено для цього. Середня кількість кроків становила шість, звідси і поширена фраза \"шість ступенів відокремлення\".\n\n#### Кільцеві мережі\n\nЯк правило, більшість знайомих людини --- це люди, які живуть у тій самій місцевості. Якби кожна людина була знайома лише з тими, хто живе поруч, то можна було б очікувати, що для того, щоб надіслати повідомлення з Канзасу до Массачусетсу, знадобилося б більше шести стрибків, оскільки кожен стрибок міг би подолати лише невелику відстань. Таку мережу можна змоделювати як кільце: вузли, розташовані по колу, причому кожен вузол з'єднаний з найближчими $k/2$ вузлами з кожного боку. Наступний приклад створює та візуалізує чотирикільце за допомогою функції `watts_strogatz_graph()` про яку ми ще поговоримо. \n\nЩоб з'єднати два вузли в попередньому прикладі, потрібно пройти по краю кола, пропускаючи щонайбільше кожен другий вузол. Навіть у цій дуже маленькій мережі типова мережева відстань є досить великою порівняно з шістьма градусами, які знайшли Треверс і Мілграм.\n\nНаступний код знаходить середній найкоротший шлях і середню кластеризацію в більш реалістичному 10-кільці з 4000 вузлів:\n\nЦя мережа має в середньому 200 кроків розділення, що набагато більше, ніж шість! Вона також має досить великий середній коефіцієнт кластеризації 0.67, що показує, що сусіди вузла мають тенденцію бути пов'язаними один з одним.\n\n#### Випадкові мережі\n\nЩоб дослідити цю таємницю, розглянемо інший тип мережі. У цій мережі ми починаємо з $k$-кільця, але випадковим чином переставляємо кінцеві точки кожного ребра. В результаті отримаємо мережу з тією ж кількістю вузлів і ребер, але з випадковою структурою, що демонструється наступним чином:\n\nТепер давайте розглянемо властивості перев'язаного 10-кільця з 4000 вузлів:\n\nСередній найкоротший шлях дуже близький до реальної соціальної мережі, але середня кластеризація тепер майже 0. Поки що моделі, які ми бачили, досягають коротких шляхів або високої кластеризації, але не того й іншого разом.\n\n#### Мережа Воттса-Строгаца\n\nПроблема малого світу полягає в тому, як люди, що живуть на великій відстані один від одного, можуть бути пов'язані короткими шляхами, навіть якщо їхні зв'язки зв'язки є локальними. Дункан Воттс і Стівен Строгац розробили клас мереж для пояснення такої поведінки. Мережі починаються як $k$-кільця: вузли, розміщені по колу, кожен з яких з'єднаний з найближчими $k$ сусідами. Потім, з ймовірністю $p$, ребра кожного вузла перев'язуються з іншим випадково обраним вузлом. Ці перестановки створюють короткі шляхи по всій мережі. Навіть невелика кількість коротких шляхів значно скорочує відстані між вузлами мережі, вирішуючи проблему малого світу. Фактично, це саме те, що робить функція `watts_strogatz_graph()`, яку ми використовували, а третій параметр задає частку ребер, які потрібно перев'язати. Наступний код обчислює середній найкоротший шлях і середню кластеризацію для діапазону ймовірностей перев'язування:\n\nРезультати наступного коду зберігаються у списках `path` та `clustering`. Використовуючи функцію `semilogx()` з `matplotlib.pyplot`, наступний код візуалізує, як ці значення змінюються при зміні ймовірності перев'язування від 0 до 1:\n\n::: {.callout-note}\n\nФункція `semilogx()` використовує логарифмічний масштаб для осі x. Часто в мережевих науках значення змінюються так швидко, що візуалізація їх на лінійній шкалі призводить до того, що початкове значення миттєво падає до кінцевого. Функція semilogx() може виявити поведінку, яка може бути втрачена при використанні лінійної осі. Пакет `pyplot` також пропонує функції `semilogy()` і `loglog()` для використання інших логарифмічних осей.\n\n:::\n\nЯк ми вже бачили, зі збільшенням кількості перев'язувань, як середня кластеризація, так і середній найкоротший шлях зменшуються. Однак цікава річ відбувається при проміжних значеннях. Довжина шляху стає коротшою при дуже низьких значеннях перев'язування, в той час як зменшення кластеризації відбувається лише при більших значеннях перев'язування. Іншими словами, перев'язування дуже малої частки ребер створює \"мости\", які з'єднують віддалені частини мережі і різко скорочують середній найкоротший шлях, не змінюючи при цьому кластеризацію. Можна сказати, що найкращий тип мереж це той, що зберігає як частку впорядкованості, так і частку випадковості. \n\nДалі можемо подивитись, як виглядає мережа Воттса й Строгаца при наступних імовірностях: $p=0$, $p=0.1$ та $p=1$.\n\nУ деяких випадках перев'язування може призвести до того, що дві компоненти в мережі Воттса-Строгаца будуть роз'єднані. Роз'єднана мережа може бути непотрібним ускладненням. Мережа Ньюмана-Воттса-Строгаца --- це варіант, який гарантує, що отримана мережа буде зв'язною. Вона схожа на оригінальну версію, але залишає копію оригінального ребра на місці кожного ребра, що перев'язується. Такі мережі можна створювати за допомогою функції `newman_watts_strogatz_graph()`, як показано нижче:\n\n#### Степеневі закони та переважне приєднання\n\nВід інтернету до поїздок в аеропорт, багато мереж характеризуються кількома вузлами з великою кількістю зв'язків і багатьма вузлами з дуже малою кількістю зв'язків. Такі мережі характеризуються **важкими хвостами**, тому що при побудові гістограми степенів вузлів, вузли з високим рівнем зв'язності утворюють хвіст. \n\nІснує багато способів генерування мереж з важким хвостом, але одним з найпоширеніших є модель **переважного приєднання** Барабаші-Альберта. Модель переважного приєднання імітує процеси, в яких багаті стають багатшими. Кожного разу, коли додається новий вузол, він випадковим чином з'єднується з існуючими вузлами, причому більш вірогідним є з'єднання з вузлами високого ступеня.\n\nУ NetworkX функція `barabasi_albert_graph()`, яка генерує мережі переважного приєднання. У наступному коді показано приклад такої мережі з 35 вузлами:\n\nСтруктура мережі переважного приєднання ще більш очевидна при більшій кількістю вузлів. У наступному прикладі використовується 1000 вузлів:\n\nВажкі хвости цих мереж можна побачити, побудувавши їхні степеневі розподіли. Наступна функція будує розподіл степенів мережі:\n\nВикористовуючи цю функцію, наступний код візуалізує розподіл степенів для 35-вузлової та 1000-вузлових мереж переважного приєднання:\n\nМережі з переважним приєднанням мають одну цікаву властивість: вони **масштабоінваріантні**. Розподіл степенів у масштабоінваріантних мережах підпорядковується степеневому закону, що призводить до схожої структури на різних масштабах. Один із способів побачити це --- порівняти попередні гістограми. Незважаючи на дуже різні масштаби, вони мають схожу форму. Розподіл степенів вершин можна описати степеневою функцією виду:\n\n$$P(k) \\propto k^{-\\gamma}$$\n\nде $k$ --- степінь вузла, $P(k)$ --- ймовірність того, що вузол має степінь $k$, і $\\gamma$ --- показник степеневого закону. Показник $\\gamma$ зазвичай знаходиться в діапазоні від 2 до 3 для більшості реальних мереж.\n\nРозподіл степенів степеневого закону має важливі наслідки для структури та функцій мереж. Наприклад, мережі зі степеневим розподілом часто є більш надійними і стійкими до випадкових збоїв, але більш вразливими до цілеспрямованих атак на вузли з високим степенем.\n\n## Хід роботи\n\nТепер давайте проведемо порівняльний аналіз графів різної складності з використанням деяких із зазначених показників. За допомогою бібліотеки `NetworkX` розглянемо наступні типи графів:\n\n- лінійний граф --- `path_graph()`; \n- циклічний граф --- `cycle_graph()`; \n- граф-зірка --- `star_graph()`; \n- граф Ердеша-Реньї --- `erdos_renyi_graph()`; \n- граф малого світу --- `watts_strogatz_graph()`; \n- граф переважного приєднання --- `barabasi_albert_graph()`. \n\nВізуалізуємо кожен із зазначених графів:\n\nКожен із даних графів може різнитись як за своєю спектральною структурою, так і, очевидно, топологічною: деякі можуть мати вищий ступінь кластеризації, або ступеня вершини, або посередництва тощо. Розглянемо як ранжується ступінь складності кожного графа за досліджуваними нами показниками. \n\nСпочатку збережемо кожен із побудованих графів до одного масиву для ітеративного проведення розрахунків по кожному з них:\n\n### Спектральні міри складності\n\nТепер виконаємо розрахунки спектральних мір складності для кожного графу:\n\nВиведемо результат:\n\nНа рисунку (@fig-spec) можна побачити наступне:\n\n- по-перше, усі спектральні показники залишаються найбільшими саме для графу переважного приєднання, що представляється найбільш складним серед усіх інших графів;\n- по друге, згідно динаміці спектральних показників, найпростішими серед усіх графів є граф лінії, зірки та Ердеша-Реньї. Для лінії зберігається зв'язок тільки між парами послідовних вершин. Для зірки зберігається зв'язок усіх вершин із центром, але самі вони не пов'язані один із одним. \n- по третє, граф малого світу залишається другим по складності майже по всім показникам окрім спектрального розриву. Спектральний розрив говорить, що граф зірки є трохи складнішим за малий світ. Це може бути обумовлене тим, що для зірки ми спостерігаємо достатньо високий ступінь централізації. \n\n### Топологічні міри\n\nРозрахуємо для досліджуваних графів топологічні міри складності. В якості прикладу розглянемо такі міри як \n\n- максимальний ступінь вершини ($d_{max}$);\n- глобальний коефіцієнт кластеризації ($C$);\n- середній ступінь посередництва ($B_{mean}$); \n- середня довжина найкоротшого шляху ($L_{mean}$).\n\nВиводимо результат:\n\nНа рисунку (@fig-topol) можна побачити наступне:\n\n- по-перше, найбільшим максимальним ступенем вершини характеризується саме граф-зірка, центро якої з'єднаний абсолютно з усіма вершинами мережі. Другим по ступеню концентрованності можна поставити граф переважного приєднання, що, як ми вже зазначали, є найкращим представлення реальних соціальних систем. До найпростіших можна віднести графи лінії, кола та Ердеша-Реньї. \n- по-друге, глобальний коефіцієнт кластеризації вказує на те, що найвищий ступінь кластеризації спостерігається саме для графу малого світу. Закономірно за ним іде граф переважного приєднання. Найпростішими знову виявляються графи Ердеша-Реньї, лінії, кола та, цього разу, зірки. Для зірки навіть візуально видно, що всі вершини мають тенденцію слідувати тільки за однією конкретною. \n- по-третє, середній ступінь посередництва є найнижчим для зірки, графу Ердеша-Реньї, малого світу та переважного приєднання. Для цих мереж передача інформації від одного вузла до іншого не займає значну частку часу. Для лінії та кола від одного кінця графу до іншого може знадобитися досить великий проміжок часу для передачі інформації. Схожа ситуація спостерігається й для середньої довжини найкоротшого шляху, оскільки міра посередництва на пряму залежить від значення найкоротшого шляху від одного вузла до іншого.  \n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":true,"highlight-style":"arrow","css":["style.css"],"output-file":"lab_13.html"},"language":{"toc-title-document":"Зміст","toc-title-website":"На цій сторінці","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Анотація","section-title-appendices":"Додатки","section-title-footnotes":"Зноски","section-title-references":"Використана література","section-title-reuse":"Повторне використання","section-title-copyright":"Copyright","section-title-citation":"Цитата","appendix-attribution-cite-as":"Будь-ласка, цитуйте цю роботу як:","appendix-attribution-bibtex":"BibTeX:","title-block-author-single":"Автор","title-block-author-plural":"Автори","title-block-affiliation-single":"Приналежність","title-block-affiliation-plural":"Приналежності","title-block-published":"Дата публікації","title-block-modified":"Змінено","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Код","code-tools-menu-caption":"Код","code-tools-show-all-code":"Розгорнути код","code-tools-hide-all-code":"Приховати код","code-tools-view-source":"Переглянути код","code-tools-source-code":"Вихідний код","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Копіювати","copy-button-tooltip-success":"Скопійовано!","repo-action-links-edit":"Редагувати сторінку","repo-action-links-source":"Переглянути код","repo-action-links-issue":"Повідомити про проблему","back-to-top":"Back to top","search-no-results-text":"Пошук не дав результату","search-matching-documents-text":"Результати пошуку","search-copy-link-title":"Скопіюйте посилання для пошуку","search-hide-matches-text":"Приховати додаткові результати","search-more-match-text":"Додатковий результат у цьому документі","search-more-matches-text":"Додаткові результати у цьому документі","search-clear-button-title":"Очистити","search-detached-cancel-button-title":"Скасувати","search-submit-button-title":"Надіслати","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Рис.","crossref-tbl-title":"Таблиця","crossref-lst-title":"Список","crossref-thm-title":"Теорема","crossref-lem-title":"Лема","crossref-cor-title":"Наслідок","crossref-prp-title":"Твердження","crossref-cnj-title":"Гіпотеза","crossref-def-title":"Визначення","crossref-exm-title":"Приклад","crossref-exr-title":"Завдання","crossref-ch-prefix":"Глава","crossref-apx-prefix":"Додаток","crossref-sec-prefix":"Розділ","crossref-eq-prefix":"Рівняння","crossref-lof-title":"Список Рисунків","crossref-lot-title":"Список Таблиць","crossref-lol-title":"Список Каталогів","environment-proof-title":"Доведення","environment-remark-title":"Зауваження","environment-solution-title":"Рішення","listing-page-order-by":"Сортувати по","listing-page-order-by-default":"попередньо вибраний","listing-page-order-by-date-asc":"Найновіші","listing-page-order-by-date-desc":"Найстріші","listing-page-order-by-number-desc":"За спаданням","listing-page-order-by-number-asc":"За зростанням","listing-page-field-date":"Дата","listing-page-field-title":"Заголовок","listing-page-field-description":"Опис","listing-page-field-author":"Автор","listing-page-field-filename":"Ім'я файлу","listing-page-field-filemodified":"Змінено","listing-page-field-subtitle":"Підзаголовок","listing-page-field-readingtime":"Час читання","listing-page-field-categories":"Категорії","listing-page-minutes-compact":"{0} хвилин","listing-page-category-all":"Все","listing-page-no-matches":"Немає відповідних елементів"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.433","bibliography":["references.bib"],"csl":"physics-letters-b.csl","callout-appearance":"default","grid":{"body-width":"1050px"},"page-layout":"full","theme":{"light":"cosmo","dark":"superhero"},"title":"Лабораторна робота № 13"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":true,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","toc":true,"number-sections":true,"output-file":"lab_13.pdf"},"language":{"toc-title-document":"Зміст","toc-title-website":"На цій сторінці","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Анотація","section-title-appendices":"Додатки","section-title-footnotes":"Зноски","section-title-references":"Використана література","section-title-reuse":"Повторне використання","section-title-copyright":"Copyright","section-title-citation":"Цитата","appendix-attribution-cite-as":"Будь-ласка, цитуйте цю роботу як:","appendix-attribution-bibtex":"BibTeX:","title-block-author-single":"Автор","title-block-author-plural":"Автори","title-block-affiliation-single":"Приналежність","title-block-affiliation-plural":"Приналежності","title-block-published":"Дата публікації","title-block-modified":"Змінено","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Код","code-tools-menu-caption":"Код","code-tools-show-all-code":"Розгорнути код","code-tools-hide-all-code":"Приховати код","code-tools-view-source":"Переглянути код","code-tools-source-code":"Вихідний код","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Копіювати","copy-button-tooltip-success":"Скопійовано!","repo-action-links-edit":"Редагувати сторінку","repo-action-links-source":"Переглянути код","repo-action-links-issue":"Повідомити про проблему","back-to-top":"Back to top","search-no-results-text":"Пошук не дав результату","search-matching-documents-text":"Результати пошуку","search-copy-link-title":"Скопіюйте посилання для пошуку","search-hide-matches-text":"Приховати додаткові результати","search-more-match-text":"Додатковий результат у цьому документі","search-more-matches-text":"Додаткові результати у цьому документі","search-clear-button-title":"Очистити","search-detached-cancel-button-title":"Скасувати","search-submit-button-title":"Надіслати","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Рис.","crossref-tbl-title":"Таблиця","crossref-lst-title":"Список","crossref-thm-title":"Теорема","crossref-lem-title":"Лема","crossref-cor-title":"Наслідок","crossref-prp-title":"Твердження","crossref-cnj-title":"Гіпотеза","crossref-def-title":"Визначення","crossref-exm-title":"Приклад","crossref-exr-title":"Завдання","crossref-ch-prefix":"Глава","crossref-apx-prefix":"Додаток","crossref-sec-prefix":"Розділ","crossref-eq-prefix":"Рівняння","crossref-lof-title":"Список Рисунків","crossref-lot-title":"Список Таблиць","crossref-lol-title":"Список Каталогів","environment-proof-title":"Доведення","environment-remark-title":"Зауваження","environment-solution-title":"Рішення","listing-page-order-by":"Сортувати по","listing-page-order-by-default":"попередньо вибраний","listing-page-order-by-date-asc":"Найновіші","listing-page-order-by-date-desc":"Найстріші","listing-page-order-by-number-desc":"За спаданням","listing-page-order-by-number-asc":"За зростанням","listing-page-field-date":"Дата","listing-page-field-title":"Заголовок","listing-page-field-description":"Опис","listing-page-field-author":"Автор","listing-page-field-filename":"Ім'я файлу","listing-page-field-filemodified":"Змінено","listing-page-field-subtitle":"Підзаголовок","listing-page-field-readingtime":"Час читання","listing-page-field-categories":"Категорії","listing-page-minutes-compact":"{0} хвилин","listing-page-category-all":"Все","listing-page-no-matches":"Немає відповідних елементів"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"csl":"physics-letters-b.csl","callout-appearance":"default","documentclass":"report","title":"Лабораторна робота № 13"},"extensions":{"book":{"selfContainedOutput":true}}},"docx":{"identifier":{"display-name":"MS Word","target-format":"docx","base-format":"docx"},"execute":{"fig-width":5,"fig-height":4,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"docx","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"page-width":6.5},"pandoc":{"default-image-extension":"png","to":"docx","toc":true,"number-sections":true,"output-file":"lab_13.docx"},"language":{"toc-title-document":"Зміст","toc-title-website":"На цій сторінці","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Анотація","section-title-appendices":"Додатки","section-title-footnotes":"Зноски","section-title-references":"Використана література","section-title-reuse":"Повторне використання","section-title-copyright":"Copyright","section-title-citation":"Цитата","appendix-attribution-cite-as":"Будь-ласка, цитуйте цю роботу як:","appendix-attribution-bibtex":"BibTeX:","title-block-author-single":"Автор","title-block-author-plural":"Автори","title-block-affiliation-single":"Приналежність","title-block-affiliation-plural":"Приналежності","title-block-published":"Дата публікації","title-block-modified":"Змінено","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Код","code-tools-menu-caption":"Код","code-tools-show-all-code":"Розгорнути код","code-tools-hide-all-code":"Приховати код","code-tools-view-source":"Переглянути код","code-tools-source-code":"Вихідний код","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Копіювати","copy-button-tooltip-success":"Скопійовано!","repo-action-links-edit":"Редагувати сторінку","repo-action-links-source":"Переглянути код","repo-action-links-issue":"Повідомити про проблему","back-to-top":"Back to top","search-no-results-text":"Пошук не дав результату","search-matching-documents-text":"Результати пошуку","search-copy-link-title":"Скопіюйте посилання для пошуку","search-hide-matches-text":"Приховати додаткові результати","search-more-match-text":"Додатковий результат у цьому документі","search-more-matches-text":"Додаткові результати у цьому документі","search-clear-button-title":"Очистити","search-detached-cancel-button-title":"Скасувати","search-submit-button-title":"Надіслати","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Рис.","crossref-tbl-title":"Таблиця","crossref-lst-title":"Список","crossref-thm-title":"Теорема","crossref-lem-title":"Лема","crossref-cor-title":"Наслідок","crossref-prp-title":"Твердження","crossref-cnj-title":"Гіпотеза","crossref-def-title":"Визначення","crossref-exm-title":"Приклад","crossref-exr-title":"Завдання","crossref-ch-prefix":"Глава","crossref-apx-prefix":"Додаток","crossref-sec-prefix":"Розділ","crossref-eq-prefix":"Рівняння","crossref-lof-title":"Список Рисунків","crossref-lot-title":"Список Таблиць","crossref-lol-title":"Список Каталогів","environment-proof-title":"Доведення","environment-remark-title":"Зауваження","environment-solution-title":"Рішення","listing-page-order-by":"Сортувати по","listing-page-order-by-default":"попередньо вибраний","listing-page-order-by-date-asc":"Найновіші","listing-page-order-by-date-desc":"Найстріші","listing-page-order-by-number-desc":"За спаданням","listing-page-order-by-number-asc":"За зростанням","listing-page-field-date":"Дата","listing-page-field-title":"Заголовок","listing-page-field-description":"Опис","listing-page-field-author":"Автор","listing-page-field-filename":"Ім'я файлу","listing-page-field-filemodified":"Змінено","listing-page-field-subtitle":"Підзаголовок","listing-page-field-readingtime":"Час читання","listing-page-field-categories":"Категорії","listing-page-minutes-compact":"{0} хвилин","listing-page-category-all":"Все","listing-page-no-matches":"Немає відповідних елементів"},"metadata":{"bibliography":["references.bib"],"csl":"physics-letters-b.csl","callout-appearance":"default","title":"Лабораторна робота № 13"},"extensions":{"book":{"selfContainedOutput":true}}},"epub":{"identifier":{"display-name":"ePub","target-format":"epub","base-format":"epub"},"execute":{"fig-width":5,"fig-height":4,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"epub","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":false,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"default-image-extension":"png","html-math-method":"mathml","to":"epub","toc":true,"number-sections":true,"output-file":"lab_13.epub"},"language":{"toc-title-document":"Зміст","toc-title-website":"На цій сторінці","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Анотація","section-title-appendices":"Додатки","section-title-footnotes":"Зноски","section-title-references":"Використана література","section-title-reuse":"Повторне використання","section-title-copyright":"Copyright","section-title-citation":"Цитата","appendix-attribution-cite-as":"Будь-ласка, цитуйте цю роботу як:","appendix-attribution-bibtex":"BibTeX:","title-block-author-single":"Автор","title-block-author-plural":"Автори","title-block-affiliation-single":"Приналежність","title-block-affiliation-plural":"Приналежності","title-block-published":"Дата публікації","title-block-modified":"Змінено","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Код","code-tools-menu-caption":"Код","code-tools-show-all-code":"Розгорнути код","code-tools-hide-all-code":"Приховати код","code-tools-view-source":"Переглянути код","code-tools-source-code":"Вихідний код","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Копіювати","copy-button-tooltip-success":"Скопійовано!","repo-action-links-edit":"Редагувати сторінку","repo-action-links-source":"Переглянути код","repo-action-links-issue":"Повідомити про проблему","back-to-top":"Back to top","search-no-results-text":"Пошук не дав результату","search-matching-documents-text":"Результати пошуку","search-copy-link-title":"Скопіюйте посилання для пошуку","search-hide-matches-text":"Приховати додаткові результати","search-more-match-text":"Додатковий результат у цьому документі","search-more-matches-text":"Додаткові результати у цьому документі","search-clear-button-title":"Очистити","search-detached-cancel-button-title":"Скасувати","search-submit-button-title":"Надіслати","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Рис.","crossref-tbl-title":"Таблиця","crossref-lst-title":"Список","crossref-thm-title":"Теорема","crossref-lem-title":"Лема","crossref-cor-title":"Наслідок","crossref-prp-title":"Твердження","crossref-cnj-title":"Гіпотеза","crossref-def-title":"Визначення","crossref-exm-title":"Приклад","crossref-exr-title":"Завдання","crossref-ch-prefix":"Глава","crossref-apx-prefix":"Додаток","crossref-sec-prefix":"Розділ","crossref-eq-prefix":"Рівняння","crossref-lof-title":"Список Рисунків","crossref-lot-title":"Список Таблиць","crossref-lol-title":"Список Каталогів","environment-proof-title":"Доведення","environment-remark-title":"Зауваження","environment-solution-title":"Рішення","listing-page-order-by":"Сортувати по","listing-page-order-by-default":"попередньо вибраний","listing-page-order-by-date-asc":"Найновіші","listing-page-order-by-date-desc":"Найстріші","listing-page-order-by-number-desc":"За спаданням","listing-page-order-by-number-asc":"За зростанням","listing-page-field-date":"Дата","listing-page-field-title":"Заголовок","listing-page-field-description":"Опис","listing-page-field-author":"Автор","listing-page-field-filename":"Ім'я файлу","listing-page-field-filemodified":"Змінено","listing-page-field-subtitle":"Підзаголовок","listing-page-field-readingtime":"Час читання","listing-page-field-categories":"Категорії","listing-page-minutes-compact":"{0} хвилин","listing-page-category-all":"Все","listing-page-no-matches":"Немає відповідних елементів"},"metadata":{"bibliography":["references.bib"],"csl":"physics-letters-b.csl","callout-appearance":"default","title":"Лабораторна робота № 13"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf","docx","epub"]}