<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Моделювання складних систем у Python - 8&nbsp; Лабораторна робота № 7</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./lab_11.html" rel="next">
<link href="./lab_6.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "Пошук не дав результату",
    "search-matching-documents-text": "Результати пошуку",
    "search-copy-link-title": "Скопіюйте посилання для пошуку",
    "search-hide-matches-text": "Приховати додаткові результати",
    "search-more-match-text": "Додатковий результат у цьому документі",
    "search-more-matches-text": "Додаткові результати у цьому документі",
    "search-clear-button-title": "Очистити",
    "search-detached-cancel-button-title": "Скасувати",
    "search-submit-button-title": "Надіслати",
    "search-label": "Поиск"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="style.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Переключить боковую панель навигации" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./lab_7.html"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Лабораторна робота № 7</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Переключить боковую панель навигации" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Моделювання складних систем у Python</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/Butman2099/Complex-systems-book" rel="" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Переключить темный режим"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Поиск"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Передмова</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Вступ</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Лабораторна робота № 1</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Лабораторна робота № 2</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Лабораторна робота № 3</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Лабораторна робота № 4</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Лабораторна робота № 5</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Лабораторна робота № 6</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_7.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Лабораторна робота № 7</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Лабораторна робота № 11</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab_12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Лабораторна робота № 12</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Додатки</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Переключить раздел">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./appa.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Інструкція зі встановлення Anaconda Navigator</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./appb.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Вступ до мови програмування Python</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./appc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Основи Jupyter Notebook</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Зміст</h2>
   
  <ul>
  <li><a href="#теоретичні-відомості" id="toc-теоретичні-відомості" class="nav-link active" data-scroll-target="#теоретичні-відомості"><span class="header-section-number">8.1</span> Теоретичні відомості</a>
  <ul class="collapse">
  <li><a href="#означення-мультифракталів" id="toc-означення-мультифракталів" class="nav-link" data-scroll-target="#означення-мультифракталів"><span class="header-section-number">8.1.1</span> Означення мультифракталів</a></li>
  <li><a href="#узагальнені-фрактальні-розмірності-d_q" id="toc-узагальнені-фрактальні-розмірності-d_q" class="nav-link" data-scroll-target="#узагальнені-фрактальні-розмірності-d_q"><span class="header-section-number">8.1.2</span> Узагальнені фрактальні розмірності <span class="math inline">\(D_{q}\)</span></a></li>
  <li><a href="#функція-мультифрактального-спектра-falpha" id="toc-функція-мультифрактального-спектра-falpha" class="nav-link" data-scroll-target="#функція-мультифрактального-спектра-falpha"><span class="header-section-number">8.1.3</span> Функція мультифрактального спектра <span class="math inline">\(f(\alpha)\)</span></a></li>
  <li><a href="#мультифрактальний-аналіз-детрендованих-флуктуацій" id="toc-мультифрактальний-аналіз-детрендованих-флуктуацій" class="nav-link" data-scroll-target="#мультифрактальний-аналіз-детрендованих-флуктуацій"><span class="header-section-number">8.1.4</span> Мультифрактальний аналіз детрендованих флуктуацій</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.dev/Butman2099/Complex-systems-book/blob/main/lab_7.ipynb" class="toc-action">Редагувати сторінку</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Лабораторна робота № 7</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p><strong>Тема.</strong> Мультифрактальний аналіз складних систем.</p>
<p><strong>Мета.</strong> Навчитися використовувати мультифрактальний аналіз детрендованих флуктуацій для отримання індикаторів нелінійних змін у системі.</p>
<section id="теоретичні-відомості" class="level2" data-number="8.1">
<h2 data-number="8.1" class="anchored" data-anchor-id="теоретичні-відомості"><span class="header-section-number">8.1</span> Теоретичні відомості</h2>
<section id="означення-мультифракталів" class="level3" data-number="8.1.1">
<h3 data-number="8.1.1" class="anchored" data-anchor-id="означення-мультифракталів"><span class="header-section-number">8.1.1</span> Означення мультифракталів</h3>
<p>У цій лабораторній ми викладемо основи теорії мультифракталів — <strong>неоднорідних фрактальних об’єктів</strong>, для повного опису яких, на відміну від регулярних фракталів, недостатньо введення лише однієї величини, його фрактальної розмірності <span class="math inline">\(D\)</span>, а потрібен цілий спектр таких розмірностей, кількість яких, взагалі кажучи, нескінченна. Причина цього полягає в тому, що поряд із суто геометричними характеристиками, які визначаються величиною <span class="math inline">\(D\)</span>, такі фрактали характеризуються й деякими специфічними статистичними властивостями.</p>
<div id="fig-triangle" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="Images\lab_7\triangle.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;8.1: Трикутник Серпинського, області якого згенеровані з нерівномірними ймовірностями</figcaption>
</figure>
</div>
<p>Простіше всього пояснити, що розуміється під “неоднорідним фракталом” на прикладі трикутника Серпинського, отриманого за допомогою методу випадкових ітерацій.</p>
<p>Припустімо, однак, що в методі випадкових ітерацій ми тепер із якоїсь причини віддали перевагу одній із вершин трикутника, наприклад, вершині А, і стали вибирати її з імовірністю 90%. Дві ж інші вершини В і С для нас рівноцінні, але на їхню частку тепер припадає всього лише по 5%. Результат такої несиметричної гри” зображено нижче на рисунку вище.</p>
<p>Видно, що точки всередині трикутника АВС розподілені тепер вкрай нерівномірно. Більша їх частина перебуває біля вершини А та її прообразів. Водночас у вершин В і С (і їхніх прообразів) їх є вкрай мало. Проте, за звичайною термінологією, ця множина точок (за умови прагнення числа ітерацій до нескінченності) є фракталом, тому що збереглася основна властивість фракта — самоподібність. Дійсно, трикутник DFC, хоча в ньому у 20 разів менше точок, за своїми статистичними і геометричними властивостями повністю подібний до великого трикутника АВС. Так само, як і у великому трикутнику, точки в ньому концентруються здебільшого поблизу вершини D — аналогу вершини А.</p>
<div id="fig-dist-serp" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="Images\lab_7\distribution_of_points.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;8.2: Розподіл точок по трикутнику Серпинського, представленого на попередньому рисунку</figcaption>
</figure>
</div>
<p><a href="#fig-dist-serp">Рисунок&nbsp;<span>8.2</span></a> більш детально демонструє результуючий розподіл точок по трикутнику Серпинського. Цифри в кожному з маленьких трикутників показують його відносну заселеність точками множини.</p>
<p>Однак, не дивлячись на нерівномірність розподілу точок фрактала, його фрактальна розмірність залишилась при цьому такою ж, <span class="math inline">\(D=\frac{\ln{3}}{\ln{2}}\)</span>. Покриття цієї множини все меншими трикутниками можна здійснити по тому ж алгоритму, що й раніше. Таке співпадіння змушує замислитись над пошуком нових кількісних характеристик, котрі могли б відрізнити нерівномірний розподіл точок від рівномірного.</p>
<p>Інший, складніший приклад неоднорідного фрактала, який ми б хотіли ще навести, показано на наступному рисунку. Ліворуч продемонстровано великий квадрат зі стороною, що дорівнює одиниці, який на цьому (нульовому) етапі повністю покриває собою деяку фрактальну множину точок <span class="math inline">\(M\)</span>. На наступному (першому) етапі, у центрі малюнка, показано, як ту саму множину можна покрити трьома меншими квадратами зі сторонами <span class="math inline">\(l_1=1/2, \ l_2=l_3=5/16\)</span>, у яких, відповідно, міститься частка <span class="math inline">\(p_1=1/2, \ p_2=1/3\)</span> та <span class="math inline">\(p_3=1/6\)</span> усіх точок.</p>
<div id="fig-dist-square" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="Images\lab_7\square_fractal.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;8.3: Приклад мультифрактала, що підкоряється ренормалізаційній схемі</figcaption>
</figure>
</div>
<p>Наступний етап покриття (зображений на рисунку праворуч) містить уже 9 квадратів зі сторонами <span class="math inline">\(l_{1}^{2}=1/4, \ l_{1}l_{2}=l_{1}l_{3}=5/32\)</span> (у нижньому правому куті) і <span class="math inline">\(l_{2}l_{1}=5/32, \ l_{2}^{2}=l_{2}l_{3}=25/256\)</span> (угорі праворуч і ліворуч). Відносна заселеність цих квадратів точками множини показана на рисунку. Вона відповідає добутку чинників заселеності (імовірностей): <span class="math inline">\(p_{1}^{2}=1/4, \ p_{1}p_{2}=1/6, \ p_{1}p_{3}=1/12\)</span> — для нижньої правої групи, <span class="math inline">\(p_{2}p_{1}=1/6, \ p_{2}^{2}=1/9, \ p_{2}p_{3} = 1/18\)</span> — для верхньої лівої та <span class="math inline">\(p_{3}p_{1}=1/12, \ p_{3}p_{2}=1/18, \ p_{3}^{2}=1/36\)</span> — для верхньої правої групи. Зазначимо, що є чітка відповідність між заселеністю квадрата <span class="math inline">\(p_{j}p_{i}\)</span> і його розмірами <span class="math inline">\(l_{i}l_{i}\)</span>.</p>
<p>Подальший процес розбиття і покриття множини <span class="math inline">\(M\)</span> здійснюється згідно із цією ренормалізаційною схемою. Кожен квадрат, що має на <span class="math inline">\(n\)</span>-му кроці розмір <span class="math inline">\(l\)</span> і заселеність <span class="math inline">\(р\)</span>, замінюється на <span class="math inline">\(n+1\)</span> кроці трьома квадратами з розмірами <span class="math inline">\(ll_{1}, \ ll_{2}, \ ll_{3}\)</span> і заселеностями <span class="math inline">\(pp_{1}, \ pp_{2}, \ pp_{3}\)</span> відповідно, розміщеними таким самим чином відносно один одного, як показано на попередньому посередні рисунку.</p>
<p>Двоє розглянутих вище випадки являють собою приклади неоднорідних фракталів. Під словом “неоднорідний” ми тут розуміємо нерівномірний розподіл точок множини по фракталу або нерівномірний розподіл малих та великих флуктуацій у часовому ряді. Причина неоднорідності в попередніх випадках одна й та сама — різні ймовірності заповнення геометрично однакових елементів фрактала, або в загальному випадку невідповідність імовірностей заповнення геометричним розмірам відповідних областей. Такі неоднорідні фрактальні об’єкти в літературі називають мультифракталами, і їх вивченням ми й займемося надалі.</p>
</section>
<section id="узагальнені-фрактальні-розмірності-d_q" class="level3" data-number="8.1.2">
<h3 data-number="8.1.2" class="anchored" data-anchor-id="узагальнені-фрактальні-розмірності-d_q"><span class="header-section-number">8.1.2</span> Узагальнені фрактальні розмірності <span class="math inline">\(D_{q}\)</span></h3>
<p>Дамо загальне визначення мультифрактала. Розглянемо фрактальний об’єкт, що займає якусь обмежену ділянку <span class="math inline">\(\Omega\)</span> розміру <span class="math inline">\(L\)</span> у Евклідовому просторі з розмірністю <span class="math inline">\(d\)</span>. Нехай на якомусь етапі його побудови він являє собою множину з <span class="math inline">\(N \gg 1\)</span> точок, якось розподілених у цій області. Ми будемо припускати, що врешті-решт <span class="math inline">\(N \to \infty\)</span>. Прикладом такої множини може слугувати трикутник Серпінського, побудований методом випадкових ітерацій. Кожен крок ітераційної процедури додає до цієї множини одну нову точку.</p>
<p>Розіб’ємо всю область <span class="math inline">\(\Omega\)</span> на кубічні клітинки зі стороною <span class="math inline">\(\varepsilon \ll L\)</span> та об’ємом <span class="math inline">\(\varepsilon^{d}\)</span>. Далі нас будуть цікавити тільки зайняті клітинки, у яких міститься хоча б одна точка. Нехай номер зайнятих комірок <span class="math inline">\(i\)</span> змінюється в межах <span class="math inline">\(і=1, 2,..., N(\varepsilon)\)</span>, де <span class="math inline">\(N(\varepsilon)\)</span> — сумарна кількість зайнятих клітинок, яка, звісно, залежить від розміру клітинки <span class="math inline">\(\varepsilon\)</span>.</p>
<p>Нехай <span class="math inline">\(n_{i}(\varepsilon)\)</span> представляє собою кількість точок у клітинці з номером <span class="math inline">\(i\)</span>, тоді величина</p>
<p><span class="math display">\[
p_{i}(\varepsilon) = \lim_{N\to\infty}\frac{n_{i}(\varepsilon)}{N}
\]</span></p>
<p>представляє собою ймовірність того, що навмання взята точка з нашої множини знаходиться в комірці <span class="math inline">\(i\)</span>. Інакше кажучи, ймовірності <span class="math inline">\(р_{i}\)</span> характеризують відносну заселеність комірок. З умови нормування ймовірності випливає, що</p>
<p><span class="math display">\[
\sum_{i=1}^{N(\varepsilon)}p_{i}(\varepsilon)=1.
\]</span></p>
<p>Уведемо тепер у розгляд <strong>узагальнену статистичну суму</strong> <span class="math inline">\(Z(q,\varepsilon)\)</span>, що характеризується показником ступеня <span class="math inline">\(q\)</span>, який може набувати будь-яких значень в інтервалі <span class="math inline">\(-\infty&lt;q&lt;+\infty\)</span></p>
<p><span class="math display">\[
Z(q,\varepsilon)=\sum_{i=1}^{N(\varepsilon)}p_{i}^{q}(\varepsilon).
\]</span></p>
<p>Спектр <strong>узагальнених фрактальних розмірностей</strong> <span class="math inline">\(D_{q}\)</span>, що характеризує даний розподіл точок в області <span class="math inline">\(\Omega\)</span>, визначається за допомогою співвідношення</p>
<p><span class="math display">\[
D_{q} = \frac{\tau(q)}{q-1},
\]</span></p>
<p>де функція <span class="math inline">\(\tau(q)\)</span> має вид</p>
<p><span class="math display">\[
\tau(q)=\lim_{\varepsilon\to 0}\frac{\ln{Z(q,\varepsilon)}}{\ln{\varepsilon}}.
\]</span></p>
<p>Як ми покажемо нижче, якщо <span class="math inline">\(D_{q}=D=\text{const}\)</span>, тобто не залежить від <span class="math inline">\(q\)</span>, то дана множина точок являє собою звичайний, регулярний фрактал, який характеризується лише однією величиною — фрактальною розмірністю <span class="math inline">\(D\)</span>. Навпаки, якщо функція <span class="math inline">\(D_{q}\)</span> якось змінюється з <span class="math inline">\(q\)</span>, то розглянута множина точок представляє мультифрактал.</p>
<p>Таким чином, мультифрактал у загальному випадку характеризується деякою <strong>нелінійною</strong> функцією <span class="math inline">\(\tau(q)\)</span>, що визначає поведінку статистичної суми <span class="math inline">\(Z(q,\varepsilon)\)</span> при <span class="math inline">\(\varepsilon\to 0\)</span></p>
<p><span class="math display">\[\tag{1}
Z(q,\varepsilon)=\sum_{i=1}^{N(\varepsilon)}p_{i}^{q}(\varepsilon) \approx \varepsilon^{\tau(q)}.
\]</span></p>
<p>Слід мати на увазі, що в реальній ситуації ми завжди маємо скінченне, хоча й дуже велике число дискретних точок <span class="math inline">\(N\)</span>, тому при комп’ютерному моделювані конкретної множини граничний перехід <span class="math inline">\(\varepsilon\to 0\)</span> треба виконувати з обережністю, пам’ятаючи, що йому завжди передує ліміт <span class="math inline">\(N \to 0\)</span>.</p>
<p>Покажемо тепер, як поводиться узагальнена статистична сума у випадку звичайного регулярного фрактала з фрактальною розмірністю <span class="math inline">\(D\)</span>. У цьому випадку в усіх зайнятих комірках міститься однакова кількість точок</p>
<p><span class="math display">\[
n_{i}(\varepsilon)=\frac{N}{N(\varepsilon)},
\]</span></p>
<p>тобто фрактал представляється <strong>однорідним</strong>. Тоді очевидно, що відносні населеності клітинок, <span class="math inline">\(p_{i}(\varepsilon)=1/N(\varepsilon)\)</span>, також однакові, і узагальнена статистична сума набуває вигляду</p>
<p><span class="math display">\[\tag{2}
Z(q,\varepsilon) = N^{1-q}(\varepsilon).
\]</span></p>
<p>Врахуємо тепер, що, згідно визначеню фрактальної розмірності <span class="math inline">\(D\)</span>, кількість зайнятих клітинок при достатньо малому <span class="math inline">\(\varepsilon\)</span> поводить себе наступним чином:</p>
<p><span class="math display">\[\tag{3}
N(\varepsilon) \approx \varepsilon^{-D}.
\]</span></p>
<p>Підставляючи (3) у формулу (2), і порівнюючи з (1), отримуємо</p>
<p><span class="math display">\[\tag{4}
\varepsilon^{\tau(q)} = \varepsilon^{-D(1-q)} \to \tau(q)=(q-1)D.
\]</span></p>
<p>Ми приходимо до висновку, що у випадку звичайного фрактала функція (4) є лінійною. Тоді всі <span class="math inline">\(D_{q}\)</span> дійсно не залежать від <span class="math inline">\(q\)</span>. Фрактал у якого всі узагальнені фрактальні розмірності <span class="math inline">\(D_{q}\)</span> співпадають називається <strong>монофракталом</strong>.</p>
<p>Якщо розподіл точок по клітинкам неоднаковий, тоді фрактал називається неоднорідним, тобто представляє із себе мультифрактал, і для його характеристики необхідний цілий спектр узагальнених фрактальних розмірностей <span class="math inline">\(D_{q}\)</span>, кількість котрих, у загальному випадку, нескінченна.</p>
<p>Так, наприклад, при <span class="math inline">\(q \to +\infty\)</span> основний внесок в узагальнену статистичну суму (1) вносять комірки, що містять найбільшу кількість частинок <span class="math inline">\(n_{i}\)</span> у них і, відповідно, що характеризуються найбільшою ймовірністю їх заповнення <span class="math inline">\(p_{i}\)</span>. Навпаки, при <span class="math inline">\(q \to -\infty\)</span> основний внесок в узагальнену статистичну суму вносять найбільш розрідженні комірки з найменшою ймовірністю їх заповнення <span class="math inline">\(p_{i}\)</span>. Таким чином, функція <span class="math inline">\(D_{q}\)</span> показує, наскільки неоднорідним представляється досліджувана множина точок <span class="math inline">\(\Omega\)</span>.</p>
<p>У подальшому для характеристики розподілу точок необхідно знати не тільки функцію <span class="math inline">\(\tau(q)\)</span>, але і її похідну:</p>
<p><span class="math display">\[
\frac{d\tau(q)}{dq} = \lim_{\varepsilon\to 0}\frac{\sum_{i=1}^{N(\varepsilon)}p_{i}^{q}\ln{p_{i}}}{\left( \sum_{i=1}^{N(\varepsilon)}p_{i}^{q} \right)\ln{\varepsilon}}.
\]</span></p>
<p>Ця похідна має важливий фізичний зміст, який буде продемонстровано пізніше. Зараз знову зазначимо, що для мультифрактальної системи вона не залишається константною і змінюється з <span class="math inline">\(q\)</span>.</p>
</section>
<section id="функція-мультифрактального-спектра-falpha" class="level3" data-number="8.1.3">
<h3 data-number="8.1.3" class="anchored" data-anchor-id="функція-мультифрактального-спектра-falpha"><span class="header-section-number">8.1.3</span> Функція мультифрактального спектра <span class="math inline">\(f(\alpha)\)</span></h3>
<section id="спектр-фрактальних-розмірностей" class="level4" data-number="8.1.3.1">
<h4 data-number="8.1.3.1" class="anchored" data-anchor-id="спектр-фрактальних-розмірностей"><span class="header-section-number">8.1.3.1</span> Спектр фрактальних розмірностей</h4>
<p>У попередньому пункті ми ввели поняття мультифрактала — об’єкта, що представляє собою неоднорідний фрактал. Для його опису ми ввели множину узагальнених фрактальних розмірностей <span class="math inline">\(D_{q}\)</span>, де <span class="math inline">\(q\)</span> приймає будь-які значення в інтервалі <span class="math inline">\(-\infty&lt;q&lt;+\infty\)</span>. Однак величини <span class="math inline">\(D_{q}\)</span> не є, строго кажучи, фрактальними розмірностями в загальному розумінні цього слова.</p>
<p>Тому часто поряд із ними для характеристики мультифрактальної множини використовують так звану <strong>функцію мультифрактального спектра</strong> <span class="math inline">\(f(\alpha)\)</span> (спектр сингулярностей мультифрактала), до якої, як ми побачимо надалі, більше підходить термін фрактальна розмірність. Ми покажемо, що величина <span class="math inline">\(f(\alpha)\)</span> фактично дорівнює хаусдорфовій розмірності якоїсь однорідної фрактальної підмножини із вихідної множини <span class="math inline">\(\Omega\)</span>, що дає домінантний внесок у статистичну суму при заданій величині <span class="math inline">\(q\)</span>.</p>
<p>Однією з основних характеристик мультифрактала є набір імовірностей <span class="math inline">\(р_{i}\)</span>, що показують відносну заселеність клітинок <span class="math inline">\(\varepsilon\)</span>, якими ми покриваємо цю множину. Чим менший розмір клітинки, тим менша величина її заселеності. Для самоподібних множин залежність <span class="math inline">\(p_{i}\)</span> від розміру клітинки <span class="math inline">\(\varepsilon\)</span> має степеневий характер:</p>
<p><span class="math display">\[
p_{i}(\varepsilon) \approx \varepsilon^{\alpha_{i}},
\]</span></p>
<p>де <span class="math inline">\(\alpha_{i}\)</span> являє собою деякий показник ступеня (різний для різнок клітинок <span class="math inline">\(i\)</span>). Відомо, що для регулярного (однорідного) фрактала всі показники ступеня <span class="math inline">\(\alpha_{i}\)</span> однакові й рівні фрактальній розмірності <span class="math inline">\(D\)</span>:</p>
<p><span class="math display">\[
p_{i} = \frac{1}{N(\varepsilon)} \approx \varepsilon^{D}.
\]</span></p>
<p>У даному випадку статистична сума (1) приймає наступний вигляд:</p>
<p><span class="math display">\[
Z(q,\varepsilon) = \sum_{i=1}^{N(\varepsilon)}p_{i}^{q}(\varepsilon) = N(\varepsilon)\varepsilon^{Dq}=\varepsilon^{-D}\varepsilon^{Dq} \approx \varepsilon^{D(q-1)}.
\]</span></p>
<p>Тому <span class="math inline">\(\tau(q)=D(q-1)\)</span> і всі узагальнені фрактальні розмірності <span class="math inline">\(D_{q}=D\)</span> у цьому випадку співпадають та не залежать від <span class="math inline">\(q\)</span>.</p>
<p>Однак, для такого складного об’єкта, як мультифрактал, унаслідок його неоднорідності, ймовірності заповнення клітинок <span class="math inline">\(p_{i}\)</span> у загальному випадку різняться, і показник ступеня <span class="math inline">\(\alpha_{i}\)</span> для різних клітинок може приймати різні значення. Достатньо типовою є ситуація, коли ці значення неперервно заповнюють деякий закритий інтервал <span class="math inline">\(\left( \alpha_{min}, \alpha_{max} \right)\)</span>, причому</p>
<p><span class="math display">\[
p_{min} \approx \varepsilon^{\alpha_{max}}, \; \text{a} \; p_{max} \approx \varepsilon^{\alpha_{min}}.
\]</span></p>
<p>Тепер перейдемо до питання о розподілі ймовірностей різних значень <span class="math inline">\(\alpha_{i}\)</span>. Нехай <span class="math inline">\(n(\alpha)d\alpha\)</span> є ймовірністю того, що <span class="math inline">\(\alpha_{i}\)</span> знаходиться в інтервалі від <span class="math inline">\(\alpha\)</span> до <span class="math inline">\(\alpha+d\alpha\)</span>. Іншими словами, <span class="math inline">\(n(\alpha)d\alpha\)</span> представляє собою відносну кількість клітинок <span class="math inline">\(i\)</span>, що характеризуються однією і тією самою мірою <span class="math inline">\(p_{i}\)</span> з <span class="math inline">\(\alpha_{i}\)</span>, що лежать у цьому інтервалі. У випадку монофрактала, для котрого всі <span class="math inline">\(\alpha_{i}\)</span> однакові (і рівні фрактальній розмірності <span class="math inline">\(D\)</span>), це число, очевидно, пропорційно повній кількості клітинок <span class="math inline">\(N(\varepsilon) \approx \varepsilon^{-D}\)</span>, степеневим чином залежних від розміру клітинки <span class="math inline">\(\varepsilon\)</span>. Показник ступеня в цьому співвідношені визначається фрактальною розмірністю множини <span class="math inline">\(D\)</span>.</p>
<p>Для мультифрактала, однак, це не так, і різні значення <span class="math inline">\(\alpha_{i}\)</span> зустрічаються з ймовірністю, що характеризується не однією і тією ж величиною <span class="math inline">\(D\)</span>, а різними (в залежності від <span class="math inline">\(\alpha\)</span>) значеннями показниками ступеня <span class="math inline">\(f(\alpha)\)</span>,</p>
<p><span class="math display">\[\tag{5}
n(\alpha) \approx \varepsilon^{-f(\alpha)}.
\]</span></p>
<p>Таким чином, фізичний сенс функції <span class="math inline">\(f(\alpha)\)</span> полягає в тому, що вона представляє собою розмірність хаусдорфа деякої однорідної підмножини <span class="math inline">\(\Omega_{\alpha}\)</span> із вихідної множини <span class="math inline">\(\Omega\)</span>, що характеризується однаковими ймовірностями заповнення клітинок <span class="math inline">\(p_{i} \approx \varepsilon^{\alpha}\)</span>. Оскільки фрактальна розмірність підмножини очевидно завжди менша або рівна фрактальній розмірності вихідної множини <span class="math inline">\(D_{0}\)</span>, має місце важлива нерівність для функції <span class="math inline">\(f(\alpha)\)</span>:</p>
<p><span class="math display">\[
f(\alpha) \leq D_{0}.
\]</span></p>
<p>У результаті можна зробити висновок, що множина різних значень функції <span class="math inline">\(f(\alpha)\)</span> (при різних <span class="math inline">\(\alpha\)</span>) представляє собою <strong>спектр фрактальних розмірностей</strong> однорідних підмножин <span class="math inline">\(\Omega_{\alpha}\)</span>, на які можна розбити вихідну множину <span class="math inline">\(\Omega\)</span>, кожна з яких характеризується власним значенням фрактальної розмірності <span class="math inline">\(f(\alpha)\)</span>.</p>
<p>Оскільки будь-якій підмножині належить лише частина загальної кількості клітинок <span class="math inline">\(N(\varepsilon)\)</span>, на котрі ми розділили вихідну множину <span class="math inline">\(\Omega\)</span>, умова нормування ймовірностей, очевидно, не виконується при підсумовуванні тільки по цій підмножині. Сума цих імовірностей стає менше одиниці. Тому й самі ймовірності <span class="math inline">\(p_i\)</span> з одним і тим самим значенням <span class="math inline">\(\alpha_i\)</span> очевидно менше (або в крайньому випадку одного порядку), ніж величина <span class="math inline">\(\varepsilon^{f(\alpha_i)}\)</span>, яка обернено пропорційна кількості наявних клітинок, що покривають дану підмножину (нагадаємо, що у випадку монофрактала <span class="math inline">\(p_i \approx 1/N(\varepsilon)\)</span>). У результаті ми приходимо до наступної важливої нерівності для функції <span class="math inline">\(f(\alpha)\)</span>. А саме, при всіх значеннях <span class="math inline">\(\alpha\)</span></p>
<p><span class="math display">\[
f(\alpha) \leq \alpha.
\]</span></p>
<p>Знак рівності має місце, наприклад, для повністю однорідного фрактала, де <span class="math inline">\(f(\alpha)=\alpha=D\)</span>.</p>
</section>
<section id="перетворення-лежандра" class="level4" data-number="8.1.3.2">
<h4 data-number="8.1.3.2" class="anchored" data-anchor-id="перетворення-лежандра"><span class="header-section-number">8.1.3.2</span> Перетворення Лежандра</h4>
<p>Встановимо зв’язок функції <span class="math inline">\(f(\alpha)\)</span> із введенною раніше функцією <span class="math inline">\(\tau(q)\)</span>. Обчислимо для цього статистичну суму <span class="math inline">\(Z(q,\varepsilon)\)</span>. Підставляє у статистичну суму ймовірності <span class="math inline">\(p_i \approx \varepsilon^{\alpha_i}\)</span>, та переходячи від підсумовування по <span class="math inline">\(i\)</span> до інтегрування по <span class="math inline">\(\alpha\)</span> з плотністю ймовірностей (5), ми отримаємо</p>
<p><span class="math display">\[\tag{6}
Z(q,\varepsilon) = \sum_{i=1}^{N(\varepsilon)} p_{i}^{q}(\varepsilon) \approx \int d\alpha n(\alpha)\varepsilon^{q\alpha} \approx \int d\alpha\varepsilon^{q\alpha-f(\alpha)}.
\]</span></p>
<p>Так як величина <span class="math inline">\(\varepsilon\)</span> дуже мала, основний внесок у цей інтеграл вноситимуть ті значення <span class="math inline">\(\alpha(q)\)</span>, при яких показник ступеня <span class="math inline">\(q\alpha-f(\alpha)\)</span> виявляється мінімальним (а підінтегральна функція — максимальною). Цей вклад буде пропорційним значенню підінтегральної функції у точці максимума. Саме ж значення <span class="math inline">\(\alpha(q)\)</span> визначається при цьому з наступної умови:</p>
<p><span class="math display">\[
\left. \frac{d}{d\alpha}[ q\alpha-f(\alpha) ] \right \vert_{\alpha=\alpha(q)} = 0.
\]</span></p>
<p>Також, з умови мінімуму ми маємо</p>
<p><span class="math display">\[
\left. \frac{d^{2}}{d\alpha^{2}}[ q\alpha-f(\alpha) ] \right \vert_{\alpha=\alpha(q)} &gt; 0.
\]</span></p>
<p>У результаті отримуємо, що залежність <span class="math inline">\(\alpha(q)\)</span> неявним чином визначається з рівняння</p>
<p><span class="math display">\[\tag{7}
q = \frac{df(\alpha)}{d\alpha}
\]</span></p>
<p>і що функція <span class="math inline">\(f(\alpha)\)</span> усюди є випуклою</p>
<p><span class="math display">\[
f^{''}(\alpha)&gt;0.
\]</span></p>
<p>Це значить, що величина <span class="math inline">\(f(\alpha(q))\)</span> дійсно визначає фрактальну розмірність підмножини <span class="math inline">\(\Omega_{\alpha(q)}\)</span>, що має найбільший домінуючий внесок у статистичну суму (6) при заданій величині показника ступеня <span class="math inline">\(q\)</span>.</p>
<p>Оскільки <span class="math inline">\(Z(q,\varepsilon)=\tau(q)\)</span>, приходимо до висновку, що</p>
<p><span class="math display">\[
\tau(q) = q\alpha(q) - f(\alpha(q)).
\]</span></p>
<p>Пам’ятаючи, що <span class="math inline">\(\tau(q)=D(q-1)\)</span>, можемо віднайти функцію <span class="math inline">\(D_{q}\)</span>:</p>
<p><span class="math display">\[\tag{8}
D_{q} = \frac{1}{q-1}[ q\alpha(q)-f(\alpha(q)) ].
\]</span></p>
<p>Таким чином, якщо ми знаємо функцію мультифрактального спектра <span class="math inline">\(f(\alpha)\)</span>, то з домомогою співвідношень (7) та (8) ми можемо знайти функцію <span class="math inline">\(D_{q}\)</span>. Навпаки, знаючи <span class="math inline">\(D_{q}\)</span>, ми можемо знайти залежність <span class="math inline">\(\alpha(q)\)</span> з допомогою рівняння</p>
<p><span class="math display">\[\tag{9}
\alpha(q) = \frac{d}{dq}[(q-1)D_{q}]
\]</span></p>
<p>і після цього знайти із (8) залежність <span class="math inline">\(f(\alpha(q))\)</span>. Ці два рівняння і визначають функцію <span class="math inline">\(f(\alpha)\)</span>.</p>
<p><span class="math display">\[
\frac{d\tau}{dq}\frac{dq}{d\alpha} = q + \alpha\frac{dq}{d\alpha} - \frac{df}{d\alpha}.
\]</span></p>
<p>Приймаючи до уваги те, що <span class="math inline">\(q=df/d\alpha\)</span>, і скорочуючи це рівняння на <span class="math inline">\(dq/d\alpha\)</span>, приходимо до співвідношення</p>
<p><span class="math display">\[
\alpha = \frac{d\tau(q)}{dq},
\]</span></p>
<p>що еквівалентне виразу (9).</p>
<p>Вирази для <span class="math inline">\(\tau(q)\)</span> та <span class="math inline">\(\alpha(q)\)</span> задають <strong>перетворення Лежандра</strong> від змінних <span class="math inline">\(\{ q, \tau(q) \}\)</span> до змінних <span class="math inline">\(\{\alpha, f(\alpha)\}\)</span>:</p>
<p><span class="math display">\[\tag{10}
\alpha = \frac{d\tau}{dq}
\]</span></p>
<p>та</p>
<p><span class="math display">\[\tag{11}
f(\alpha) = q\frac{d\tau}{dq} - \tau.
\]</span></p>
<p>Як відомо, для однорідного фрактала <span class="math inline">\(D_{q}=D=\text{const}\)</span>. Тому <span class="math inline">\(\alpha=d\tau/dq=D\)</span> і <span class="math inline">\(f(\alpha)=q\alpha-\tau(q)=qD-D(q-1)=D\)</span>. У цьому випадку “графік” функції <span class="math inline">\(f(\alpha)\)</span> на площині <span class="math inline">\(\left( \alpha, f(\alpha) \right)\)</span> складається лише з однієї точки <span class="math inline">\(\left( D, D \right)\)</span>.</p>
</section>
</section>
<section id="мультифрактальний-аналіз-детрендованих-флуктуацій" class="level3" data-number="8.1.4">
<h3 data-number="8.1.4" class="anchored" data-anchor-id="мультифрактальний-аналіз-детрендованих-флуктуацій"><span class="header-section-number">8.1.4</span> Мультифрактальний аналіз детрендованих флуктуацій</h3>
<p>Монофрактальні та мультифрактальні структури фінансових сигналів є особливим різновидом масштабно-інваріантних структур. Найчастіше монофрактальна структура фінансових часових рядів визначається одним степеневим показником і передбачає, що масштабо-інваріантність не залежить від часу і простору. Однак, часто ми маємо змогу спостерігати просторово-часову варіацію масштабно-інваріантної структури досліджуваної складної системи. Ці просторово-часові варіації вказують на мультифрактальність фінансового сигналу, яка визначається мультифрактальним спектром. Ширина і форма мультифрактального спектра можуть також допомогти диференціювати варіативність серцевого ритму у пацієнтів із серцевими захворюваннями, такими як шлуночкова тахікардія, фібриляція шлуночків і застійна серцева недостатність. Мультифрактальний спектр може допомогти кількісно визначити асиметрію підйомів та спадів на фондовому чи криптовалютному ринках, передбачити фінансову кризу, що поступово наближується, і, таким чином, сприяти успішності подальших торгівельних рішень. Основна мета цього розділу — представити одну з найточніших процедур для визначення множини фрактальних показників — <strong>мультифрактальний аналіз детрендованих флуктуацій</strong> (multifractal detrended fluctuation analysis, MFDFA).</p>
<p>Побудова MFDFA складається з восьми кроків: Розділ <em>“Шум і випадкові блукання у часовому ряді”</em> представляє метод приведення часового ряду до такого, що подібний до випадкового блукання, що є попереднім кроком для MFDFA. Розділ <em>“Обчислення середньоквадратичної варіації часового ряду”</em> представляє середньоквадратичну варіацію, яка є основною процедурою для подальших обчислень в MFDFA і типовим способом обчислення середньої варіації часових рядів різної природи. Розділ <em>“Локальна середньоквадратична варіація часового ряду”</em> представляє обчислення локальної варіації часового ряду як середньоквадратичного відхилення часового ряду в межах сегментів, що можуть як перекриватися, так і не перекриватися. У розділі <em>“Локальне детрендування часового ряду”</em> таке ж локальне середньоквадратичне відхилення обчислюється навколо трендів, які часто зустрічаються у фінансових часових рядах. У розділі <em>“Монофрактальний аналіз детрендованих флуктуацій”</em> амплітуди локальних середніх квадратичних відхилень підсумовуються в узагальнене середнє квадратичне відхилення. У сумарному середньоквадратичному відхиленні для сегментів з малими розмірами вибірки переважають швидкі флуктуації часового ряду. На противагу цьому, у сумарному середньоквадратичному відхиленні для сегментів з великими розмірами вибірки переважають повільні коливання. Степенева залежність між загальним середнім квадратичним відхиленням для декількох розмірів вибірки (тобто масштабів) визначається за допомогою монофрактального аналізу дентрендованих флуктуацій (monofractal detrended fluctuation analysis, DFA) і називається показником Херста (Hurst exponent, <span class="math inline">\(H\)</span>). У розділі <em>“Мультифрактальний аналіз детрендованих флуктуацій”</em> MFDFA отримують шляхом розширення на <span class="math inline">\(q\)</span>-й порядок узагальненого середньоквадратичного відхилення. Середньоквадратичне відхилення <span class="math inline">\(q\)</span>-го порядку може розрізняти сегменти з малими та великими флуктуаціями. Степенева залежність між середньоквадратичним відхиленням <span class="math inline">\(q\)</span>-го порядку чисельно визначається як показник Херста <span class="math inline">\(q\)</span>-го порядку. У розділі <em>“Мультифрактальний спектр часових рядів”</em> на основі показника Херста <span class="math inline">\(q\)</span>-го порядку обчислено декілька мультифрактальних спектрів.</p>
<p>Для подальшої візуалізації кожного кроку процедури MFDFA імпортуємо наступні модулі:</p>
<div class="cell" data-execution_count="264">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> neurokit2 <span class="im">as</span> nk</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> yfinance <span class="im">as</span> yf</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scienceplots</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tqdm <span class="im">import</span> tqdm</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">'ignore'</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>І виконаємо налаштування рисунків для виведення:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>plt.style.use([<span class="st">'science'</span>, <span class="st">'notebook'</span>, <span class="st">'grid'</span>]) <span class="co"># стиль, що використовуватиметься</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>                                               <span class="co"># для виведення рисунків</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>params <span class="op">=</span> {</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'figure.figsize'</span>: (<span class="dv">8</span>, <span class="dv">6</span>),         <span class="co"># встановлюємо ширину та висоту рисунків за замовчуванням</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'font.size'</span>: <span class="dv">22</span>,                  <span class="co"># розмір фонтів рисунку</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'lines.linewidth'</span>: <span class="dv">2</span>,             <span class="co"># товщина ліній</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'axes.titlesize'</span>: <span class="st">'small'</span>,        <span class="co"># розмір титулки над рисунком</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"font.family"</span>: <span class="st">"sans-serif"</span>,      <span class="co"># сімейство стилів підписів </span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">"font.serif"</span>: [<span class="st">"Times"</span>],          <span class="co"># стиль підпису</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">'savefig.dpi'</span>: <span class="dv">300</span>                <span class="co"># якість збережених зображень</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>plt.rcParams.update(params)           <span class="co"># оновлення стилю згідно налаштувань</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Цього разу розглянему можливість побудови індикаторів або індикаторів-передвісників на прикладі індексу сирої нафти West Texas Intermediate (WTI). При описі процедури MFDFA порівнюватимемо мультифрактальність даного ряду зі штучно зненерованими монофрактальними рядами складність яких має представлятися меншою у порівняні з нафтою.</p>
<p>Сам сайт Yahoo! Finance містить досить коротку історію щодених цін на нафту даної марки. Цього разу, в якості альтернативного прикладу, будемо послуговуватись альтернативним джерелом фінансових даних — <a href="https://fred.stlouisfed.org">федеральним резервом економічних даних федерального резервного банку Сент-Луїса</a> (Federal Reserve Economic Data of the Federal Reserve Bank of St.&nbsp;Louis, FRED). На Python було створено бібліотеку для вивантаження даних із даного джерела — <code>pandas-datareader</code>. Для її встановлення достатньо прописати наступну команду:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>pip install pandas<span class="op">-</span>datareader</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Тепер імпортуємо відповідну бібліотеку:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas_datareader.data <span class="im">as</span> web</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>та виконаємо зчитування індексу з FRED, використовуючи функціонал даної бібліотеки. Завантажимо дані за весь період, що нам буде доступний:</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>symbol <span class="op">=</span> <span class="st">'DCOILWTICO'</span>    <span class="co"># cимвол індексу, як указано на сайті FRED</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> <span class="st">"1986-01-01"</span>     <span class="co"># Дата початку зчитування даних</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> <span class="st">"2023-01-21"</span>       <span class="co"># Дата закінчення зчитування даних</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>wti <span class="op">=</span> web.DataReader(symbol, <span class="st">'fred'</span>, start, end) <span class="co"># зчитуємо значення ряду </span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>time_ser <span class="op">=</span> wti[symbol].copy()                    <span class="co"># зберігаємо саме ціни закриття</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>xlabel <span class="op">=</span> <span class="st">'time, days'</span>    <span class="co"># підпис по вісі Ох </span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>ylabel <span class="op">=</span> symbol          <span class="co"># підпис по вісі Оу</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Виведемо досліджуваний ряд:</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()                   <span class="co"># Створюємо порожній графік</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>ax.plot(time_ser.index, time_ser.values)   <span class="co"># Додаємо дані до графіку</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>ax.legend([symbol])                        <span class="co"># Додаємо легенду</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(xlabel)                      <span class="co"># Встановимо підпис по вісі Ох</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(ylabel)                      <span class="co"># Встановимо підпис по вісі Oy</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">45</span>)                    <span class="co"># оберт позначок по осі Ох на 45 градусів</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="ss">f'</span><span class="sc">{</span>symbol<span class="sc">}</span><span class="ss">.jpg'</span>)               <span class="co"># Зберігаємо графік </span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>plt.show()<span class="op">;</span>                                <span class="co"># Виводимо графік</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-wti-init" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="lab_7_files/figure-html/fig-wti-init-output-1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;8.4: Динаміка щоденних змін індексу сирої нафти WTI</figcaption>
</figure>
</div>
</div>
</div>
<p>Розглянемо опис нашого масиву даних:</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>time_ser.describe()</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>count    9336.000000
mean       46.078743
std        29.597897
min       -36.980000
25%        19.990000
50%        35.955000
75%        67.242500
max       145.310000
Name: DCOILWTICO, dtype: float64</code></pre>
</div>
</div>
<p>На представленому рисунку видно, що в значеннях досліджуваного індексу існують пропуски та негативні значення на ціну нафти. Для того, щоб позбутися від’ємного значення, можна виконати заміну значення на таке, що близьке до нуля. Для видалення значень <code>NaN</code> достатньо скористатися методом <code>dropna()</code> бібліотеки <code>pandas</code>.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>time_ser <span class="op">=</span> time_ser.dropna()    <span class="co"># видаляємо значення NaN</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>time_ser[time_ser.values<span class="op">&lt;</span><span class="dv">0</span>] <span class="op">=</span> <span class="dv">5</span> <span class="co"># замінюємо від'ємне значення на 5</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Знову візуалізуємо результат:</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()                   <span class="co"># Створюємо порожній графік</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>ax.plot(time_ser.index, time_ser.values)   <span class="co"># Додаємо дані до графіку</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>ax.legend([symbol])                        <span class="co"># Додаємо легенду</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(xlabel)                      <span class="co"># Встановимо підпис по вісі Ох</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(ylabel)                      <span class="co"># Встановимо підпис по вісі Oy</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">45</span>)                    <span class="co"># оберт позначок по осі Ох на 45 градусів</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="ss">f'</span><span class="sc">{</span>symbol<span class="sc">}</span><span class="ss">_filtered.jpg'</span>)      <span class="co"># Зберігаємо графік </span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>plt.show()<span class="op">;</span>                                <span class="co"># Виводимо графік</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-wti-corrected" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="lab_7_files/figure-html/fig-wti-corrected-output-1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;8.5: Динаміка щоденних змін індексу сирої нафти WTI (із видаленими NaN та заміненим від’ємним значенням)</figcaption>
</figure>
</div>
</div>
</div>
<p>Останнє, що нам залишається, це приведення вихідного ряду до прибутковостей. Для цього визначимо функцію <code>transformation()</code> та знайдемо з її допомогою прибутковості:</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transformation(signal, ret_type):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    for_rec <span class="op">=</span> signal.copy()</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ret_type <span class="op">==</span> <span class="dv">1</span>:       <span class="co"># Зважаючи на вид ряду, виконуємо</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>                            <span class="co"># необхідні перетворення</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> ret_type <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        for_rec <span class="op">=</span> for_rec.diff()</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> ret_type <span class="op">==</span> <span class="dv">3</span>:</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        for_rec <span class="op">=</span> for_rec.pct_change()</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> ret_type <span class="op">==</span> <span class="dv">4</span>:</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        for_rec <span class="op">=</span> for_rec.pct_change()</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        for_rec <span class="op">-=</span> for_rec.mean()</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        for_rec <span class="op">/=</span> for_rec.std()</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> ret_type <span class="op">==</span> <span class="dv">5</span>: </span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        for_rec <span class="op">=</span> for_rec.pct_change()</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        for_rec <span class="op">-=</span> for_rec.mean()</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        for_rec <span class="op">/=</span> for_rec.std()</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        for_rec <span class="op">=</span> for_rec.<span class="bu">abs</span>()</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> ret_type <span class="op">==</span> <span class="dv">6</span>:</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        for_rec <span class="op">-=</span> for_rec.mean()</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>        for_rec <span class="op">/=</span> for_rec.std()</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    for_rec <span class="op">=</span> for_rec.dropna().values</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> for_rec</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>signal <span class="op">=</span> time_ser.copy()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>ret_type <span class="op">=</span> <span class="dv">4</span>    <span class="co"># вид ряду: 1 - вихідний, </span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                <span class="co"># 2 - детрендований (різниця між теп. значенням та попереднім)</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>                <span class="co"># 3 - прибутковості звичайні, </span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>                <span class="co"># 4 - стандартизовані прибутковості, </span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>                <span class="co"># 5 - абсолютні значення (волатильності)</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>                <span class="co"># 6 - стандартизований ряд</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>wti_ret <span class="op">=</span> transformation(signal, ret_type) <span class="co"># знаходимо прибутковості </span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>wti_length <span class="op">=</span> <span class="bu">len</span>(wti_ret)                  <span class="co"># визначаємо довжину прибутковостей</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Як вже зазначалося, при описі процедури MFDFA, ми будемо послуговуватись для порівняння і монофрактальними сигналами. Для подальших розрахунків згенеруємо сигнал білого та рожевого шумів. У цьому нам може допомогти функція <code>signal_noise()</code> бібліотеки <code>neurokit2</code>. Ця функція генерує чистий гаусовий <code>(1/f)**beta</code> шум. Спектр потужності згенерованого шуму пропорційний <code>S(f) = (1/f)**beta</code>. Було описано наступні категорії шуму:</p>
<ul>
<li>фіолетовий шум: beta = -2</li>
<li>синій шум: beta = -1</li>
<li>білий шум: beta = 0</li>
<li>флікер / рожевий шум: beta = 1</li>
<li>коричневий шум: beta = 2</li>
</ul>
<p>Її синтаксис виглядає наступним чином:</p>
<p><strong><code>signal_noise(duration=10, sampling_rate=1000, beta=1, random_state=None)</code></strong></p>
<p><strong>Параметри</strong></p>
<ul>
<li><strong>duration</strong> (<em>float</em>) — бажана тривалість (у секундах).</li>
<li><strong>sampling_rate</strong> (<em>int</em>) — бажана частота дискретизації (у Гц, тобто відліків на секунду).</li>
<li><strong>beta</strong> (<em>float</em>) — експонента шуму.</li>
<li><strong>random_state</strong> (<em>None, int, numpy.random.RandomState або numpy.random.Generator</em>) — початкове значення (зерно) для генератора випадкових чисел.</li>
</ul>
<p><strong>Повертає</strong></p>
<ul>
<li><strong>noise</strong> (<em>array</em>) — сигнал чистого шуму.</li>
</ul>
<p>Тепер можемо згенерувати 2 види шумів:</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>white_noise <span class="op">=</span> nk.signal_noise(duration<span class="op">=</span>wti_length, <span class="co"># генеруємо білий шум </span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>                              sampling_rate<span class="op">=</span><span class="dv">1</span>, </span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>                              beta<span class="op">=</span><span class="dv">0</span>, </span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>                              random_state<span class="op">=</span><span class="dv">123</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>pink_noise <span class="op">=</span> nk.signal_noise(duration<span class="op">=</span>wti_length,  <span class="co"># генеруємо рожевий шум </span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>                              sampling_rate<span class="op">=</span><span class="dv">1</span>, </span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>                              beta<span class="op">=</span><span class="dv">1</span>, </span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>                              random_state<span class="op">=</span><span class="dv">123</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>І тепер приступаємо до подальшої роботи.</p>
<section id="шум-і-випадкові-блукання-у-часовому-ряді" class="level4" data-number="8.1.4.1">
<h4 data-number="8.1.4.1" class="anchored" data-anchor-id="шум-і-випадкові-блукання-у-часовому-ряді"><span class="header-section-number">8.1.4.1</span> Шум і випадкові блукання у часовому ряді</h4>
<p>Мультифрактальний аналіз детрендованих флуктуацій базується на класичному аналізі детрендованих флуктуацій (DFA). Класичний DFA застосовується до часових рядів зі структурою, подібною до випадкових блукань. Однак більшість фінансових часових рядів мають коливання, які більш схожі на прирости випадкових блукань. Якщо фінансовий часовий ряд має структуру, подібну до шуму, як у прибутковостей, його слід перетворити на випадково-блукаючий часовий ряд перед застосуванням DFA. Шуми можна перетворити на випадкові блукання шляхом віднімання середнього значення та інтегрування часового ряду (знаходження його кумулятивної суми). Часовий ряд з білим шумом, монофрактал (рожевий шум) і мультифрактал є шумовими часовими рядами і перетворюються на випадкові блукання за допомогою коду, що наведеного нижче:</p>
<div class="cell" data-execution_count="293">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>RW1 <span class="op">=</span> np.cumsum(white_noise<span class="op">-</span>np.mean(white_noise)) <span class="co"># випадкове блукання білого шуму</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>RW2 <span class="op">=</span> np.cumsum(pink_noise<span class="op">-</span>np.mean(pink_noise))   <span class="co"># випадкове блукання монофракталу</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>RW3 <span class="op">=</span> np.cumsum(wti_ret<span class="op">-</span>np.mean(wti_ret))         <span class="co"># випадкове блукання нафти</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="294">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>), sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(time_ser.index[<span class="dv">1</span>:], wti_ret)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(time_ser.index[<span class="dv">1</span>:], RW3, <span class="st">'r'</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].grid(<span class="va">False</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].margins(x<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">'Мультифрактальний часовий ряд'</span>)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(time_ser.index[<span class="dv">1</span>:], pink_noise, label<span class="op">=</span><span class="st">'Шумоподібний часовий ряд'</span>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(time_ser.index[<span class="dv">1</span>:], RW2, <span class="st">'r'</span>, label<span class="op">=</span><span class="st">'Випадкове блукання'</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].grid(<span class="va">False</span>)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].margins(x<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">'Монофрактальний часовий ряд'</span>)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].legend()</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(time_ser.index[<span class="dv">1</span>:], white_noise)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(time_ser.index[<span class="dv">1</span>:], RW1, <span class="st">'r'</span>)</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].grid(<span class="va">False</span>)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].margins(x<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_title(<span class="st">'Білий шум'</span>)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>plt.show()<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-step-1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="lab_7_files/figure-html/fig-step-1-output-1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;8.6: Мультифрактальний (верхня панель), монофрактальний (середня панель) та подібний до білого шуму (нижня панель) часові ряди</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="обчислення-середньоквадратичної-варіації-часового-ряду" class="level4" data-number="8.1.4.2">
<h4 data-number="8.1.4.2" class="anchored" data-anchor-id="обчислення-середньоквадратичної-варіації-часового-ряду"><span class="header-section-number">8.1.4.2</span> Обчислення середньоквадратичної варіації часового ряду</h4>
<p>Традиційний аналіз варіації часових рядів полягає в обчисленні середнього значення варіації як середньоквадратичного відхилення. Читач може скористатися наведеним нижче кодом для обчислення середньоквадратичного відхилення для часових рядів з білим шумом, монофрактальних і мультифрактальних даних:</p>
<div class="cell" data-execution_count="291">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>RMS_ordinary <span class="op">=</span> np.sqrt(np.mean(white_noise<span class="op">**</span><span class="dv">2</span>))    <span class="co"># середньоквадратична варіація білого шуму</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>RMS_monofractal <span class="op">=</span> np.sqrt(np.mean(pink_noise<span class="op">**</span><span class="dv">2</span>))  <span class="co"># середньоквадратична варіація монофрактала</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>RMS_multifractal <span class="op">=</span> np.sqrt(np.mean(wti_ret<span class="op">**</span><span class="dv">2</span>))    <span class="co"># середньоквадратична варіація мультифрактала</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="292">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>), sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(time_ser.index[<span class="dv">1</span>:], wti_ret, label<span class="op">=</span><span class="st">'Шумоподібний часовий ряд'</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].axhline(y<span class="op">=</span>np.mean(wti_ret), c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'Середнє'</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].axhline(y<span class="op">=</span>np.mean(wti_ret)<span class="op">+</span>RMS_multifractal, c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, label<span class="op">=</span><span class="st">'+/- 1 RMS'</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].axhline(y<span class="op">=</span>np.mean(wti_ret)<span class="op">-</span>RMS_multifractal, c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylim(<span class="op">-</span><span class="dv">20</span>, <span class="dv">20</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].grid(<span class="va">False</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].margins(x<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">'Мультифрактальний часовий ряд'</span>)</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(time_ser.index[<span class="dv">1</span>:], pink_noise)</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].axhline(y<span class="op">=</span>np.mean(pink_noise), c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].axhline(y<span class="op">=</span>np.mean(pink_noise)<span class="op">+</span>RMS_monofractal, c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>)</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].axhline(y<span class="op">=</span>np.mean(pink_noise)<span class="op">-</span>RMS_monofractal, c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>)</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].grid(<span class="va">False</span>)</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].margins(x<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">'Монофрактальний часовий ряд'</span>)</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(time_ser.index[<span class="dv">1</span>:], white_noise)</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].axhline(y<span class="op">=</span>np.mean(white_noise), c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].axhline(y<span class="op">=</span>np.mean(white_noise)<span class="op">+</span>RMS_ordinary, c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>)</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].axhline(y<span class="op">=</span>np.mean(white_noise)<span class="op">-</span>RMS_ordinary, c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>)</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].grid(<span class="va">False</span>)</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].margins(x<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_title(<span class="st">'Білий шум'</span>)</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>handles, labels <span class="op">=</span> ax[<span class="dv">0</span>].get_legend_handles_labels()</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>fig.legend(handles, labels, loc<span class="op">=</span><span class="st">'lower center'</span>)</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>plt.show()<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-step-2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="lab_7_files/figure-html/fig-step-2-output-1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;8.7: Мультифрактальни (верхня панель), монофрактальний (середня панель) та подібний до білого шуму (нижня панель) часові ряди з нульовим середнім значенням (червона штрихова лінія) і <span class="math inline">\(\pm\)</span> <code>RMS</code> (червона суцільна лінія)</figcaption>
</figure>
</div>
</div>
</div>
<p><a href="#fig-step-2">Рисунок&nbsp;<span>8.7</span></a> ілюструє, що середня амплітуда варіації (тобто середньоквадратичне відхилення) є однаковою для всіх трьох часових рядів — білого шуму, монофрактального та мультифрактального, навіть якщо вони мають досить різну структуру. MFDFA може розрізняти ці структури, як ми побачимо в наступних розділах.</p>
</section>
<section id="локальна-середньоквадратична-варіація-часового-ряду" class="level4" data-number="8.1.4.3">
<h4 data-number="8.1.4.3" class="anchored" data-anchor-id="локальна-середньоквадратична-варіація-часового-ряду"><span class="header-section-number">8.1.4.3</span> Локальна середньоквадратична варіація часового ряду</h4>
<p>Мультифрактальні часові ряди на верхній панелі мають локальні флуктуації як з великими, так і з малими величинами. Середньоквадратичне відхилення (RMS) у попередньому коді можна обчислити для сегментів часового ряду, щоб розрізнити величини локальних флуктуацій. Проста процедура полягає в тому, щоб розділи часовий ряд на однакові за розміром сегменти, що не перекриваються, і обчислити локальне середнє квадратичне відхилення для кожного сегмента. Це можна зробити за допомогою коду наведеного нижче, і це є основною MFDFA:</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_rms(arr, scale<span class="op">=</span><span class="dv">1335</span>, m<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># симулюємо випадкове блукання (X)</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.cumsum(arr <span class="op">-</span> np.mean(arr))</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># транспонуємо значення X </span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> X.T                           </span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># визначаємо довжини сегментів </span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    scale <span class="op">=</span> scale</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># визначаємо порядок полінома</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> m</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># визначаємо кількість сегментів</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    segments <span class="op">=</span> np.floor(<span class="bu">len</span>(X) <span class="op">/</span> scale).astype(<span class="bu">int</span>)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    Index <span class="op">=</span> {}  <span class="co"># словник індексів значень</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    fit <span class="op">=</span> {}    <span class="co"># словник для збереження отриманих поліноміальних кривих</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>                <span class="co"># для кожного сегмента</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    RMS <span class="op">=</span> []    <span class="co"># список середньоквадратичних відхилень</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(segments<span class="op">+</span><span class="dv">1</span>):       <span class="co"># проходимо по кожному сегменту</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>        Idx_start <span class="op">=</span> v <span class="op">*</span> scale         <span class="co"># визначаємо початкове значення сегмента                                           </span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>        Idx_stop <span class="op">=</span> (v <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> scale    <span class="co"># визначаємо кінцеве значення</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># формуємо масив індексів значень досліджуваного сегмента</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>        Index[v] <span class="op">=</span> np.arange(Idx_start, <span class="bu">min</span>(Idx_stop, <span class="bu">len</span>(X)))  </span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>        <span class="co"># вилучаємо значення по індексам</span></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>        X_Idx <span class="op">=</span> X[Index[v]]                       </span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># визначаємо поліноміальні коефіцієнти порядку m</span></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>        C <span class="op">=</span> np.polyfit(Index[v], X_Idx, m) </span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># будуємо поліноміальну криву по визначеним коефіцієнтам</span></span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>        fit[v] <span class="op">=</span> np.polyval(C, Index[v])         </span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>                 </span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>        <span class="co"># визначаємо варіацію ряду навколо поліноміального тренда</span></span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>        RMS.append(np.sqrt(np.mean((X_Idx <span class="op">-</span> fit[v]) <span class="op">**</span> <span class="dv">2</span>)))  </span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fit, RMS, Index, X</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Перший рядок коду функції <code>calc_rms()</code> перетворює зашумлений часовий ряд, мультифрактал, на часовий ряд випадкового блукання <span class="math inline">\(X\)</span>. Третій рядок коду задає масштаб параметра, який визначає розмір вибірки сегментів, що не перетинаються, для яких обчислюється локальне середнє квадратичне відхилення, <code>RMS</code>. П’ятий рядок — це кількість сегментів, на які можна розбити часовий ряд <span class="math inline">\(X\)</span>, де <code>len(X)</code> — розмір вибірки часового ряду <span class="math inline">\(X\)</span>. Таким чином, <code>segments = 6</code> при <code>len(X) = 9335</code> і <code>scale = 1335</code>. З дев’ятого по шістнадцятий рядок — це цикл, який обчислює локальне середньоквадратичне значення навколо тренду <code>fit[v]</code> для кожного сегмента, оновлюючи часовий індекс. У першому циклі <code>v = 0</code>, <code>Index[0]</code> переходить від 0 до 1335 значення сегмента (не включно). У другому циклі <span class="math inline">\(v = 1\)</span>, <code>Index[1]</code> переходить від 1335 до 2670 значення другого сегмента. В останньому циклі <span class="math inline">\(v = 6\)</span>, <code>Index[6]</code> переходить від 8010-го до 9345-го значення (не включно).</p>
</section>
<section id="локальне-детрендування-часового-ряду" class="level4" data-number="8.1.4.4">
<h4 data-number="8.1.4.4" class="anchored" data-anchor-id="локальне-детрендування-часового-ряду"><span class="header-section-number">8.1.4.4</span> Локальне детрендування часового ряду</h4>
<p>У складних системах наявні повільні мінливі тренди, тому для кількісної оцінки масштабо-інваріантності флуктуацій навколо цих трендів необхідно провести детрендування сигналу. У попередньому коді до <span class="math inline">\(X\)</span> на кожному сегменті <span class="math inline">\(v\)</span> підбирається поліноміальний тренд <code>fit[v]</code>. Параметр <span class="math inline">\(m\)</span> визначає порядок полінома. Поліноміальний тренд є лінійним, якщо <span class="math inline">\(m = 1\)</span>, квадратичним, якщо <span class="math inline">\(m = 2\)</span>, і кубічним, якщо <span class="math inline">\(m = 3\)</span>. Рядок <code>C = np.polyfit(Index[v], X[Index[v]], m)</code> визначає коефіцієнти полінома <code>C</code>, які використовуються для створення поліноміальної залежності тренду <code>fit[v]</code> для кожного сегмента. Потім для залишкової варіації, <code>X(Index[v])-fit[v]</code>, обчислюється локальне середньоквадратичне відхилення, <code>RMS[v]</code>, в межах кожного сегмента <span class="math inline">\(v\)</span>. Локальна середньоквадратична варіація, <code>RMS[v]</code>, представлено на наступному рисунку як відстань між червоними пунктирними трендами і червоними суцільними лініями.</p>
<div class="cell" data-execution_count="289">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>fit_1, RMS_1, Index_1, X <span class="op">=</span> calc_rms(wti_ret, scale<span class="op">=</span><span class="dv">1335</span>, m<span class="op">=</span><span class="dv">1</span>) <span class="co"># оцінка локального відхилення для мультифрактала</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>fit_2, RMS_2, Index_2, X <span class="op">=</span> calc_rms(wti_ret, scale<span class="op">=</span><span class="dv">1335</span>, m<span class="op">=</span><span class="dv">2</span>) <span class="co"># оцінка локального відхилення для монофрактала</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>fit_3, RMS_3, Index_3, X <span class="op">=</span> calc_rms(wti_ret, scale<span class="op">=</span><span class="dv">1335</span>, m<span class="op">=</span><span class="dv">3</span>) <span class="co"># оцінка локального відхилення для білого шуму</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="290">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>), sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(time_ser.index[<span class="dv">1</span>:], X)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> <span class="bu">list</span>(fit_1.keys()):</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>].plot(time_ser.index[Index_1[v]], fit_1[v], <span class="st">'r--'</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>].plot(time_ser.index[Index_1[v]], fit_1[v]<span class="op">+</span>RMS_1[v], c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>].plot(time_ser.index[Index_1[v]], fit_1[v]<span class="op">-</span>RMS_1[v], c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].grid(<span class="va">False</span>)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].margins(x<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">'Лінійне детрендування '</span> <span class="op">+</span> <span class="vs">r'$(m=1)$'</span>)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(time_ser.index[<span class="dv">1</span>:], X, label<span class="op">=</span><span class="st">'Випадкове блукання мультифрактального сигналу'</span>)</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> <span class="bu">list</span>(fit_2.keys()):</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> v <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>].plot(time_ser.index[Index_2[v]], fit_2[v], <span class="st">'r--'</span>, label<span class="op">=</span><span class="st">'Локальний тренд'</span>)</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>].plot(time_ser.index[Index_2[v]], fit_2[v]<span class="op">+</span>RMS_2[v], c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, label<span class="op">=</span><span class="st">'+/- 1 RMS'</span>)</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>].plot(time_ser.index[Index_2[v]], fit_2[v]<span class="op">-</span>RMS_2[v], c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>)</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>].plot(time_ser.index[Index_2[v]], fit_2[v], <span class="st">'r--'</span>)</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>].plot(time_ser.index[Index_2[v]], fit_2[v]<span class="op">+</span>RMS_2[v], c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>)</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>].plot(time_ser.index[Index_2[v]], fit_2[v]<span class="op">-</span>RMS_2[v], c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>)</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].grid(<span class="va">False</span>)</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].margins(x<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">'Квадратичне детрендування '</span> <span class="op">+</span> <span class="vs">r'$(m=2)$'</span>)</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(time_ser.index[<span class="dv">1</span>:], X)</span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> <span class="bu">list</span>(fit_3.keys()):</span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">2</span>].plot(time_ser.index[Index_3[v]], fit_3[v], <span class="st">'r--'</span>)</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">2</span>].plot(time_ser.index[Index_3[v]], fit_3[v]<span class="op">+</span>RMS_3[v], c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>)</span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">2</span>].plot(time_ser.index[Index_3[v]], fit_3[v]<span class="op">-</span>RMS_3[v], c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>)</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].grid(<span class="va">False</span>)</span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].margins(x<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_title(<span class="st">'Кубічне детрендування '</span> <span class="op">+</span> <span class="vs">r'$(m=3)$'</span>)</span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a>handles, labels <span class="op">=</span> ax[<span class="dv">1</span>].get_legend_handles_labels()</span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a>fig.legend(handles, labels, loc<span class="op">=</span><span class="st">'lower center'</span>)</span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a>plt.show()<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-step-3" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="lab_7_files/figure-html/fig-step-3-output-1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;8.8: Обчислення локальних флуктуацій, <code>RMS</code>, навколо лінійного, квадратичного та кубічного трендів за допомогою функції <code>calc_rms()</code> (<span class="math inline">\(m = 1\)</span>, <span class="math inline">\(m = 2\)</span> та <span class="math inline">\(m = 3\)</span>, відповідно). Червона пунктирна лінія — це підігнаний тренд, <code>fit[v]</code>, у шести сегментах вибірки розміром 1335. Відстань між червоним штриховим трендом і суцільними червоними лініями становить <span class="math inline">\(\pm\)</span> <code>RMS</code>. Локальні коливання, <code>RMS</code>, поблизу поліноміальних трендів є основою аналізу детрендованих флуктуацій</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="монофрактальний-аналіз-детрендованих-флуктуацій" class="level4" data-number="8.1.4.5">
<h4 data-number="8.1.4.5" class="anchored" data-anchor-id="монофрактальний-аналіз-детрендованих-флуктуацій"><span class="header-section-number">8.1.4.5</span> Монофрактальний аналіз детрендованих флуктуацій</h4>
<p>У DFA варіації локального середньоквадратичного відхилення кількісно оцінюються загальним середньоквадратичним відхиленням (<span class="math inline">\(F\)</span>).</p>
<p>Швидкі коливання часового ряду <span class="math inline">\(X\)</span> впливатимуть на загальне середньоквадратичне відхилення, <span class="math inline">\(F\)</span>, у сегментах малої довжини (масштабу), тоді як повільні коливання впливатимуть на <span class="math inline">\(F\)</span> у сегментах великої довжини (масштабу). Таким чином, функція флуктуацій, <span class="math inline">\(F\)</span>, повинна бути обчислена для декількох масштабів, щоб виокремити вплив як швидкоплинних, так і повільних коливань, які у свою чергу визначають структурні перетворення часового ряду. Функція флуктуацій <span class="math inline">\(F(ns)\)</span> може бути обчислена для декількох масштабів шляхом модифікації попереднього коду:</p>
<div class="cell" data-execution_count="146">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_F(arr, scale, m<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.cumsum(arr <span class="op">-</span> np.mean(arr)) <span class="co"># симулюємо випадкове блукання (X)</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> X.T                           <span class="co"># транспонуємо значення X</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    scale <span class="op">=</span> scale</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> m</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    segments <span class="op">=</span> np.zeros(<span class="bu">len</span>(scale), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    F <span class="op">=</span> np.zeros(<span class="bu">len</span>(scale))</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    Index <span class="op">=</span> {}  <span class="co"># словник індексів значень</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    fit <span class="op">=</span> {}    <span class="co"># словник для збереження отриманих поліноміальних кривих</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>                <span class="co"># для кожного сегмента</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    RMS <span class="op">=</span> {}    <span class="co"># словник середньоквадратичних відхилень</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ns <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(scale)):</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>        segments[ns] <span class="op">=</span> np.floor(<span class="bu">len</span>(X) <span class="op">/</span> scale[ns]).astype(<span class="bu">int</span>)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>        RMS[ns] <span class="op">=</span> np.zeros(segments[ns])</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(segments[ns]):         <span class="co"># проходимо по кожному сегменту</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>            <span class="co"># визначаємо початкове значення сегмента</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>            Idx_start <span class="op">=</span> v <span class="op">*</span> scale[ns]  </span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>                       </span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>            <span class="co"># визначаємо кінцеве значення</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>            Idx_stop <span class="op">=</span> (v <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> scale[ns] <span class="cf">if</span> v <span class="op">&lt;</span> segments[ns] <span class="op">-</span> <span class="dv">1</span> <span class="cf">else</span> <span class="bu">len</span>(X)    </span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>            <span class="co"># формуємо масив індексів значень досліджуваного сегмента</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>            Index[v, ns] <span class="op">=</span> np.arange(Idx_start, Idx_stop)  </span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>            <span class="co"># вилучаємо значення по індексам</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>            X_Idx <span class="op">=</span> X[Index[v, ns]]                       </span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>            <span class="co"># визначаємо поліноміальні коефіцієнти порядку m</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>            C <span class="op">=</span> np.polyfit(Index[v, ns], X_Idx, m) </span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>            <span class="co"># будуємо поліноміальну криву по визначеним коефіцієнтам</span></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>            fit[v, ns] <span class="op">=</span> np.polyval(C, Index[v, ns])  </span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>            <span class="co"># оцінюємо середньоквадратичне відхилення для фрагмента v на масштабі ns </span></span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>            RMS[ns][v] <span class="op">=</span> np.sqrt(np.mean((X_Idx <span class="op">-</span> fit[v, ns]) <span class="op">**</span> <span class="dv">2</span>)) </span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># оцінюємо загальне середньоквадратичне відхилення в межах масштабу ns</span></span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>        F[ns] <span class="op">=</span> np.sqrt(np.mean(RMS[ns] <span class="op">**</span> <span class="dv">2</span>))</span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> F, RMS, Index, X</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="287">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>scales <span class="op">=</span> [<span class="dv">16</span>, <span class="dv">32</span>, <span class="dv">64</span>, <span class="dv">128</span>, <span class="dv">256</span>, <span class="dv">512</span>, <span class="dv">1024</span>][::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>F, RMS, Index, X <span class="op">=</span> calc_F(wti_ret, scale<span class="op">=</span>scales) <span class="co"># оцінка узагальненої функції флуктуацій по різним масштабам</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="288">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="bu">len</span>(scales), <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>), sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> scale, val <span class="kw">in</span> <span class="bu">enumerate</span>(scales):</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    l <span class="op">=</span> [Index[val] <span class="cf">for</span> val <span class="kw">in</span> Index.keys() <span class="cf">if</span> (val[<span class="dv">1</span>] <span class="op">==</span> scale)]</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.array([])</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> l:</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.concatenate([x, v])</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.array([])</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idx, v <span class="kw">in</span> <span class="bu">enumerate</span>(l): </span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> np.concatenate([y, RMS[scale][idx]<span class="op">*</span>np.ones(<span class="bu">len</span>(v))])</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> scales[scale] <span class="op">==</span> <span class="dv">16</span>:</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>        ax[scale].plot(time_ser.index[<span class="dv">1</span>:], y, c<span class="op">=</span><span class="st">'b'</span>, label<span class="op">=</span><span class="st">"Локальні флуктуацій: RMS"</span>)</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>        ax[scale].axhline(y<span class="op">=</span>F[scale], c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, label<span class="op">=</span><span class="vs">r"RMS локальних флуктуацій: $F$"</span>)</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>        ax[scale].grid(<span class="va">False</span>)</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>        ax[scale].set_title(<span class="ss">f"Масштаб = </span><span class="sc">{</span>scales[scale]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>        ax[scale].margins(x<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: </span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>        ax[scale].plot(time_ser.index[<span class="dv">1</span>:], y, c<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>        ax[scale].axhline(y<span class="op">=</span>F[scale], c<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>)</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>        ax[scale].grid(<span class="va">False</span>)</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>        ax[scale].set_title(<span class="ss">f"Масштаб = </span><span class="sc">{</span>scales[scale]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>        ax[scale].margins(x<span class="op">=</span><span class="dv">0</span>)       </span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>handles, labels <span class="op">=</span> ax[<span class="op">-</span><span class="dv">1</span>].get_legend_handles_labels()</span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>fig.legend(handles, labels, loc<span class="op">=</span><span class="st">'upper left'</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>fig.tight_layout(pad<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>plt.show()<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-step-5" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="lab_7_files/figure-html/fig-step-5-output-1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;8.9: Локальні флуктуації, <code>RMS[ns]</code>, обчислені для сегментів із різними масштабами. Функція флуктуацій <code>F[ns]</code> є загальним середньоквадратичним відхиленням локальних коливань <code>RMS[ns]</code>. Зверніть увагу, що <code>F[ns]</code> зменшується на менших масштабах</figcaption>
</figure>
</div>
</div>
</div>
<p>DFA визначає монофрактальну структуру часового ряду відповідно до степеневої залежність між загальним середнім квадратичним відхиленням (тобто <span class="math inline">\(F\)</span>), обчисленим для декількох масштабів. Степенева залежність між загальним середнім квадратичним відхиленням позначається нахилом (<span class="math inline">\(H\)</span>) лінії регресії, розрахованим за допомогою коду, що представлений нижче:</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> np.polyfit(np.log(scales), np.log(F), <span class="dv">1</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> C[<span class="dv">0</span>]</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>RegLine <span class="op">=</span> np.polyval(C, np.log(scales))</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Модифікуємо попередній код, додавши нові фрагменти:</p>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_H(arr, scale, m<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.cumsum(arr <span class="op">-</span> np.mean(arr)) <span class="co"># симулюємо випадкове блукання (X)</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> X.T                           <span class="co"># транспонуємо значення X</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    scale <span class="op">=</span> scale</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> m</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    segments <span class="op">=</span> np.zeros(<span class="bu">len</span>(scale), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    F <span class="op">=</span> np.zeros(<span class="bu">len</span>(scale))</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    Index <span class="op">=</span> {}  <span class="co"># словник індексів значень</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    fit <span class="op">=</span> {}    <span class="co"># словник для збереження отриманих поліноміальних кривих</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>                <span class="co"># для кожного сегмента</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    RMS <span class="op">=</span> {}    <span class="co"># словник середньоквадратичних відхилень</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ns <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(scale)):</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>        segments[ns] <span class="op">=</span> np.floor(<span class="bu">len</span>(X) <span class="op">/</span> scale[ns]).astype(<span class="bu">int</span>)</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>        RMS[ns] <span class="op">=</span> np.zeros(segments[ns])</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(segments[ns]):         <span class="co"># проходимо по кожному сегменту</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>            <span class="co"># визначаємо початкове значення сегмента</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>            Idx_start <span class="op">=</span> v <span class="op">*</span> scale[ns]  </span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>                       </span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>            <span class="co"># визначаємо кінцеве значення</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>            Idx_stop <span class="op">=</span> (v <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> scale[ns] <span class="cf">if</span> v <span class="op">&lt;</span> segments[ns] <span class="op">-</span> <span class="dv">1</span> <span class="cf">else</span> <span class="bu">len</span>(X)    </span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>            <span class="co"># формуємо масив індексів значень досліджуваного сегмента</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>            Index[v, ns] <span class="op">=</span> np.arange(Idx_start, Idx_stop)  </span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>            <span class="co"># вилучаємо значення по індексам</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>            X_Idx <span class="op">=</span> X[Index[v, ns]]                       </span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>            <span class="co"># визначаємо поліноміальні коефіцієнти порядку m</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>            C <span class="op">=</span> np.polyfit(Index[v, ns], X_Idx, m) </span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>            <span class="co"># будуємо поліноміальну криву по визначеним коефіцієнтам</span></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>            fit[v, ns] <span class="op">=</span> np.polyval(C, Index[v, ns])  </span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>            <span class="co"># оцінюємо середньоквадратичне відхилення для фрагмента v на масштабі ns </span></span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>            RMS[ns][v] <span class="op">=</span> np.sqrt(np.mean((X_Idx <span class="op">-</span> fit[v, ns]) <span class="op">**</span> <span class="dv">2</span>)) </span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># оцінюємо загальне середньоквадратичне відхилення в межах масштабу ns</span></span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>        F[ns] <span class="op">=</span> np.sqrt(np.mean(RMS[ns] <span class="op">**</span> <span class="dv">2</span>))</span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># знаходимо коефіцієнти рівняння прямої </span></span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a>    C <span class="op">=</span> np.polyfit(np.log(scale), np.log(F), <span class="dv">1</span>) </span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># беремо кут нахилу прямої в якості показника Херста</span></span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> C[<span class="dv">0</span>]</span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a>    <span class="co"># будуємо саме рівняння</span></span>
<span id="cb25-52"><a href="#cb25-52" aria-hidden="true" tabindex="-1"></a>    RegLine <span class="op">=</span> np.polyval(C, np.log(scale))</span>
<span id="cb25-53"><a href="#cb25-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-54"><a href="#cb25-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> H, RegLine, F</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Тепер розглянемо залежність загальної функції флуктуацій <span class="math inline">\(F\)</span> від різних довжин (масштабів) локальних сегментів ряду для досліджуваних нами рядів:</p>
<div class="cell" data-execution_count="295">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>scmin <span class="op">=</span> <span class="dv">16</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>scmax <span class="op">=</span> <span class="dv">1024</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>scres <span class="op">=</span> <span class="dv">19</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>exponents <span class="op">=</span> np.linspace(np.log(scmin), np.log(scmax), scres)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>scales_exp <span class="op">=</span> np.<span class="bu">round</span>(np.exp(<span class="dv">1</span>)<span class="op">**</span>exponents).astype(<span class="bu">int</span>)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>H_multifrac, RegLine_multifrac, F_multifrac <span class="op">=</span> calc_H(wti_ret, scale<span class="op">=</span>scales_exp, m<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>H_monofrac, RegLine_monofrac, F_monofrac <span class="op">=</span> calc_H(pink_noise, scale<span class="op">=</span>scales_exp, m<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>H_white_noise, RegLine_white_noise, F_white_noise <span class="op">=</span> calc_H(white_noise, scale<span class="op">=</span>scales_exp, m<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="296">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>ax.set_xscale(<span class="st">'log'</span>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>ax.set_yscale(<span class="st">'log'</span>)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>ax.scatter(scales_exp, F_multifrac, </span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>           label<span class="op">=</span><span class="vs">fr"Мультифрактальний ряд ($H$=</span><span class="sc">{</span>H_multifrac<span class="sc">:.2f}</span><span class="vs">)"</span>, </span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>           color<span class="op">=</span><span class="st">'darkblue'</span>)</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>plt.plot(scales_exp, np.exp(RegLine_multifrac),  color<span class="op">=</span><span class="st">'darkblue'</span>)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>ax.scatter(scales_exp, F_monofrac, </span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>           label<span class="op">=</span><span class="vs">fr"Монофрактальний ряд ($H$=</span><span class="sc">{</span>H_monofrac<span class="sc">:.2f}</span><span class="vs">)"</span>, </span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>           color<span class="op">=</span><span class="st">'magenta'</span>)</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>plt.plot(scales_exp, np.exp(RegLine_monofrac), color<span class="op">=</span><span class="st">'magenta'</span>)</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>ax.scatter(scales_exp, F_white_noise, </span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>           label<span class="op">=</span><span class="vs">fr"Білий шум ($H$=</span><span class="sc">{</span>H_white_noise<span class="sc">:.2f}</span><span class="vs">)"</span>, </span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>           color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>plt.plot(scales_exp, np.exp(RegLine_white_noise), color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="vs">r'$\log</span><span class="sc">{ns}</span><span class="vs">$'</span>)</span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="vs">r"$\log{F(ns)}$"</span>)</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>plt.show()<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-step-6" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="lab_7_files/figure-html/fig-step-6-output-1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;8.10: Графік залежності загального середньоквадратичного відхилення (тобто функції флуктуацій <span class="math inline">\(F\)</span>) від масштабу, де і <span class="math inline">\(F\)</span>, і масштаб представлені в логарифмічних координатах. Масштабно-інваріантна залежність позначається нахилом, <span class="math inline">\(H\)</span>, ліній регресії. Нахил, <span class="math inline">\(H\)</span>, є показником степеневого закону, який називається показником Херста, оскільки <span class="math inline">\(F\)</span> і масштаб представлені в логарифмічних координатах</figcaption>
</figure>
</div>
</div>
</div>
<p>Як уже зазначалося в попередній лабораторній роботі, кут нахилу <span class="math inline">\(H\)</span> ліній регресії називається показником Херста. Показник Херста визначає монофрактальну структуру часового ряду, показуючи, наскільки швидко зростає загальне середньоквадратичне відхилення, <span class="math inline">\(F\)</span>, локальних коливань, <code>RMS</code>, зі збільшенням розміру локальних сегментів ряду (тобто, масштабу). <a href="#fig-step-6">Рисунок&nbsp;<span>8.10</span></a> показує, що загальне середньоквадратичне значення локальних флуктуацій, <span class="math inline">\(F\)</span>, зростає швидше зі збільшенням розміру вибірки сегментів для монофрактального рожевого шуму порівняно з індексом нафти та білим шумом. Більший показник Херста, <span class="math inline">\(H\)</span>, візуально свідчить про повільнішу еволюцію варіацій (тобто більш стійку структуру) в рожевому шумі порівняно з нафтою та білим шумом. <a href="#fig-hurst">Рисунок&nbsp;<span>8.11</span></a> ілюструє, що показник Херста визначає континуум між часовими рядами, подібними до шуму, і часовими рядами, подібними до випадкового блукання. Показник Херста знаходиться в інтервалі від 0 до 1 для часових рядів, подібних до шуму, тоді як для часових рядів, подібних до випадкових блукань, він перевищує 1. Часовий ряд має довгострокову залежну (тобто корельовану) структуру, коли показник Херста знаходиться в інтервалі 0.5-1, і антикорельовану структуру, коли показник Херста знаходиться в інтервалі 0-0.5. Часовий ряд має незалежну або короткострокову залежну структуру в окремому випадку, коли показник Херста дорівнює 0.5. Згідно з попереднім рисунком, часові ряди білого шуму та нафти представляються непередбачуваними, оскільки показник Херста близький до 0.5, тоді як рожевий шум довгостроково залежну структуру з показником Херста близьким до 1.</p>
<div class="cell" data-execution_count="283">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>betas <span class="op">=</span> np.linspace(<span class="fl">0.0</span>, <span class="fl">2.0</span>, <span class="dv">12</span>)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>scmin <span class="op">=</span> <span class="dv">16</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>scmax <span class="op">=</span> <span class="dv">1024</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>scres <span class="op">=</span> <span class="dv">19</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>exponents <span class="op">=</span> np.linspace(np.log(scmin), np.log(scmax), scres)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>scales_exp <span class="op">=</span> np.<span class="bu">round</span>(np.exp(<span class="dv">1</span>)<span class="op">**</span>exponents).astype(<span class="bu">int</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="286">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>color <span class="op">=</span> <span class="bu">iter</span>(plt.cm.rainbow(np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="bu">len</span>(betas))))</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="bu">len</span>(betas), <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>), sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx, beta <span class="kw">in</span> <span class="bu">enumerate</span>(betas):</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    noise <span class="op">=</span> nk.signal_noise(duration<span class="op">=</span>wti_length,  <span class="co"># генеруємо шум із різними значеннями beta </span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>                              sampling_rate<span class="op">=</span><span class="dv">1</span>, </span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>                              beta<span class="op">=</span>beta, </span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>                              random_state<span class="op">=</span><span class="dv">123</span>)   </span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    H_noise, _, _ <span class="op">=</span> calc_H(arr<span class="op">=</span>noise, scale<span class="op">=</span>scales_exp, m<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> <span class="bu">next</span>(color)</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>    ax[idx].plot(np.arange(<span class="bu">len</span>(noise)), noise, label<span class="op">=</span><span class="vs">fr"$H$ = </span><span class="sc">{</span>H_noise<span class="sc">:.2f}</span><span class="vs">"</span>, c<span class="op">=</span>c)</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>    ax[idx].grid(<span class="va">False</span>)</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>    ax[idx].legend(loc<span class="op">=</span><span class="st">"upper left"</span>)</span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>    ax[idx].margins(x<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>fig.subplots_adjust(hspace<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>plt.show()<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-hurst" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="lab_7_files/figure-html/fig-hurst-output-1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;8.11: Діапазон показників Херста визначає континуум фрактальних структур між білим шумом (<span class="math inline">\(Н = 0.5\)</span>) і коричневим шумом (<span class="math inline">\(H = 1.5\)</span>). Рожевий шум <span class="math inline">\(H = 1\)</span> розділяє шуми <span class="math inline">\(H &lt; 1\)</span>, які мають більш помітні швидкі флуктуації, і випадкові блукання <span class="math inline">\(H &gt; 1\)</span>, які мають більш помітні повільні флуктуації</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="мультифрактальний-аналіз-детрендованих-флуктуацій-1" class="level4" data-number="8.1.4.6">
<h4 data-number="8.1.4.6" class="anchored" data-anchor-id="мультифрактальний-аналіз-детрендованих-флуктуацій-1"><span class="header-section-number">8.1.4.6</span> Мультифрактальний аналіз детрендованих флуктуацій</h4>
<p>Структури монофрактального та мультифрактального часових рядів відрізняється, хоча вони мають схожі загальні середньоквадратичні значення. Мультифрактальні часові ряди мають локальні флуктуації як з екстремально малими, так і з екстремально великими значеннями, що не характерно монофрактальним часовим рядам. Відсутність флуктуацій з екстремально великими та малими значеннями призводить до нормального розподілу для монофрактального часового ряду, де варіація описується лише статистичним моментом другого порядку (тобто дисперсією). Отже, монофрактальний DFA базується на статистиці другого порядку загального середньоквадратичного відхилення (тобто, <span class="math inline">\(F\)</span>). У мультифрактальному часовому ряді локальні коливання, <code>RMS[ns][v]</code>, будуть екстремально великими для сегментів <span class="math inline">\(v\)</span> в межах часових періодів великих коливань і екстремально малими для сегментів <span class="math inline">\(v\)</span> в межах часових періодів малих коливань. Отже, мультифрактальні часові ряди не є нормально розподіленими і слід враховувати всі статистичні моменти <span class="math inline">\(q\)</span>-го порядку. Таким чином, необхідно розширити загальне середньоквадратичне значення монофрактального DFA (тобто <span class="math inline">\(F\)</span>) до середньоквадратичної функції флуктуацій <span class="math inline">\(q\)</span>-го порядку мультифрактального DFA (<span class="math inline">\(F_{q}\)</span>):</p>
<div class="cell" data-execution_count="273">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_Fq(arr, scale, q, m<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.cumsum(arr <span class="op">-</span> np.mean(arr)) <span class="co"># симулюємо випадкове блукання (X)</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> X.T                           <span class="co"># транспонуємо значення X</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    scale <span class="op">=</span> scale </span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    qs <span class="op">=</span> q</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> m</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    segments <span class="op">=</span> np.zeros(<span class="bu">len</span>(scale), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    Fq <span class="op">=</span> np.zeros((<span class="bu">len</span>(qs), <span class="bu">len</span>(scale)))</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>    Index <span class="op">=</span> {}</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>    RMS <span class="op">=</span> {}    <span class="co"># словник локальних середньоквадратичних відхилень</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>    fit <span class="op">=</span> {}    <span class="co"># словник для збереження отриманих поліноміальних кривих</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>                <span class="co"># для кожного сегмента</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>    qRMS <span class="op">=</span> {}   <span class="co"># словник локальних відхилень зважених показником q</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ns <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(scale)):</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>        segments[ns] <span class="op">=</span> np.floor(<span class="bu">len</span>(X) <span class="op">/</span> scale[ns]).astype(<span class="bu">int</span>)</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>        RMS[ns] <span class="op">=</span> np.zeros(segments[ns])</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># проходимо по кожному сегменту</span></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(segments[ns]): </span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>            <span class="co"># визначаємо початкове значення сегмента</span></span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>            Idx_start <span class="op">=</span> v <span class="op">*</span> scale[ns]  </span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>                       </span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>            <span class="co"># визначаємо кінцеве значення</span></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>            Idx_stop <span class="op">=</span> (v <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> scale[ns] <span class="cf">if</span> v <span class="op">&lt;</span> segments[ns] <span class="op">-</span> <span class="dv">1</span> <span class="cf">else</span> <span class="bu">len</span>(X)    </span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>            <span class="co"># формуємо масив індексів значень досліджуваного сегмента</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>            Index[v] <span class="op">=</span> np.arange(Idx_start, Idx_stop)  </span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>            <span class="co"># вилучаємо значення по індексам</span></span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>            X_Idx <span class="op">=</span> X[Index[v]]                       </span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>            <span class="co"># визначаємо поліноміальні коефіцієнти порядку m</span></span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>            C <span class="op">=</span> np.polyfit(Index[v], X_Idx, m) </span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a>            <span class="co"># будуємо поліноміальну криву по визначеним коефіцієнтам</span></span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a>            fit <span class="op">=</span> np.polyval(C, Index[v])  </span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a>            <span class="co"># оцінюємо середньоквадратичне відхилення для фрагмента v на масштабі ns </span></span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a>            RMS[ns][v] <span class="op">=</span> np.sqrt(np.mean((X_Idx <span class="op">-</span> fit) <span class="op">**</span> <span class="dv">2</span>)) </span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a>        <span class="co"># приводимо q значення до типу float</span></span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a>        qs <span class="op">=</span> np.asarray_chkfinite(qs, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a>        <span class="co"># для мультифрактальності</span></span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ----------------------------</span></span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nq, qval <span class="kw">in</span> <span class="bu">enumerate</span>(qs):</span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (qval <span class="op">!=</span> <span class="fl">0.</span>): </span>
<span id="cb30-52"><a href="#cb30-52" aria-hidden="true" tabindex="-1"></a>                qRMS[nq, ns] <span class="op">=</span> RMS[ns] <span class="op">**</span> q[nq]</span>
<span id="cb30-53"><a href="#cb30-53" aria-hidden="true" tabindex="-1"></a>                Fq[nq, ns] <span class="op">=</span> np.mean(qRMS[nq, ns]) <span class="op">**</span> (<span class="dv">1</span> <span class="op">/</span> q[nq])</span>
<span id="cb30-54"><a href="#cb30-54" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb30-55"><a href="#cb30-55" aria-hidden="true" tabindex="-1"></a>                Fq[nq, ns] <span class="op">=</span> np.exp(<span class="fl">0.5</span> <span class="op">*</span> np.mean(np.log(RMS[ns] <span class="op">**</span> <span class="dv">2</span>)))</span>
<span id="cb30-56"><a href="#cb30-56" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ----------------------------</span></span>
<span id="cb30-57"><a href="#cb30-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-58"><a href="#cb30-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Fq, qRMS, Index</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>У новому блоці коду запускається цикл, який обчислює загальне середньоквадратичне значення <span class="math inline">\(q\)</span>-порядку, <span class="math inline">\(F_{q}(nq)\)</span>, від від’ємних до додатних <span class="math inline">\(q\)</span>. Порядок <span class="math inline">\(q\)</span> зважує вплив сегментів ряду з великими та малими коливаннями, <code>RMS</code>, як показано на наступному рисунку. На <span class="math inline">\(F_{q}(nq)\)</span> для від’ємних <span class="math inline">\(q\)</span> впливають сегменти <span class="math inline">\(v\)</span> з малими <code>RMS(v)</code>. Навпаки, на <span class="math inline">\(F_{q}(nq)\)</span> для додатних <span class="math inline">\(q\)</span> впливають відрізки <span class="math inline">\(v\)</span> з великими <code>RMS(v)</code>. Локальні флуктуації <code>RMS</code> з великими та малими величинами класифікуються за величиною від’ємного або додатного порядку <span class="math inline">\(q\)</span> відповідно. На <span class="math inline">\(F_{q}\)</span> для <span class="math inline">\(q = -3\)</span> і <span class="math inline">\(3\)</span> більше впливають відрізки <span class="math inline">\(v\)</span> з найменшим і найбільшим <code>RMS(v)</code>, відповідно, порівняно з <span class="math inline">\(F_{q}\)</span> для <span class="math inline">\(q = -1\)</span> і <span class="math inline">\(1\)</span>. Середня точка <span class="math inline">\(q = 0\)</span> є нейтральною до впливу відрізків з малим та великим <code>RMS</code>. Зверніть увагу, що в останньому рядку коду нового блоку перевизначено окремий випадок <span class="math inline">\(q(nq) = 0\)</span>, оскільки <span class="math inline">\(1/0\)</span> прямує до нескінченності (тобто, <span class="math inline">\(1/q(q = 0) = \infty\)</span>). Читач також повинен помітити, що <span class="math inline">\(F_{q}[q == 2]\)</span> дорівнює статистиці другого порядку <span class="math inline">\(F\)</span>, оскільки <span class="math inline">\(\sqrt{x} = x^{1/2}\)</span>. Монофрактальний DFA тепер розширюється до MFDFA.</p>
<div class="cell" data-execution_count="274">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>scales <span class="op">=</span> np.array([<span class="dv">32</span>])</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>nq <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">3</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">3</span>])</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>Fq, qRMS, Index <span class="op">=</span> calc_Fq(wti_ret, scale<span class="op">=</span>scales, q<span class="op">=</span>nq, m<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>Fq_pink, qRMS_pink, Index <span class="op">=</span> calc_Fq(pink_noise, scale<span class="op">=</span>scales, q<span class="op">=</span>nq, m<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="275">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots((<span class="bu">len</span>(nq)<span class="op">+</span><span class="dv">1</span>), <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">10</span>))</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(time_ser.index[<span class="dv">1</span>:], wti_ret, label<span class="op">=</span><span class="st">"Мультифрактал"</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(time_ser.index[<span class="dv">1</span>:], pink_noise, label<span class="op">=</span><span class="st">"Монофрактал"</span>)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].grid(<span class="va">False</span>)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].margins(x<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].legend(loc<span class="op">=</span><span class="st">'upper left'</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].get_xaxis().set_visible(<span class="va">False</span>)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(nq)<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    l <span class="op">=</span> [Index[val] <span class="cf">for</span> val <span class="kw">in</span> Index.keys()]</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.array([])</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> l:</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.concatenate([x, v])</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.array([])</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>    y_pink <span class="op">=</span> np.array([])</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, v <span class="kw">in</span> <span class="bu">enumerate</span>(l): </span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> np.concatenate([y, qRMS[(idx<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>)][i]<span class="op">*</span>np.ones(<span class="bu">len</span>(v))])</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>        y_pink <span class="op">=</span> np.concatenate([y_pink, qRMS_pink[(idx<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>)][i]<span class="op">*</span>np.ones(<span class="bu">len</span>(v))])</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>    ax[idx].set_title(<span class="vs">fr"Локальні варіації для </span><span class="sc">{</span>scales[<span class="dv">0</span>]<span class="sc">}</span><span class="vs">-го масштабу при $q=$</span><span class="sc">{</span>nq[idx<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="vs">"</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>    ax[idx].plot(time_ser.index[<span class="dv">1</span>:], y)</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>    ax[idx].plot(time_ser.index[<span class="dv">1</span>:], y_pink)</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>    ax[idx].grid(<span class="va">False</span>)</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>    ax[idx].margins(x<span class="op">=</span><span class="dv">0</span>)       </span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> idx <span class="op">!=</span> <span class="bu">len</span>(nq): </span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>        ax[idx].get_xaxis().set_visible(<span class="va">False</span>)</span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>handles, labels <span class="op">=</span> ax[<span class="dv">0</span>].get_legend_handles_labels()</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a>plt.show()<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-step-7" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="lab_7_files/figure-html/fig-step-7-output-1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;8.12: Ілюстрація залежності локальних флуктуацій <code>qRMS</code> від <span class="math inline">\(q\)</span> при масштабі 32. <code>qRMS</code> — це <span class="math inline">\(q\)</span>-порядок локальних флуктуацій (тобто, <code>RMS</code>) і є складовою частиною загального <span class="math inline">\(q\)</span>-порядку <code>RMS</code> (тобто, $F_{q}). <code>qRMS</code> представлено для монофрактального (зелена смуга) та мультифрактальних (синя смуга) часових рядів. Від’ємний порядок <span class="math inline">\(q\)</span> (<span class="math inline">\(q = -3\)</span> і <span class="math inline">\(-1\)</span>) підсилює сегменти в мультифрактальному часовому ряді з екстремально малими <code>RMS</code>, тоді як додатний порядок <span class="math inline">\(q\)</span> (<span class="math inline">\(q = 3\)</span> і <span class="math inline">\(1\)</span>) підсилює відрізки з екстремально великими <code>RMS</code>. Зверніть увагу, що <span class="math inline">\(q = -3\)</span> і <span class="math inline">\(q = 3\)</span> підсилюють малу і велику варіацію відповідно більше, ніж <span class="math inline">\(q = -1\)</span> і <span class="math inline">\(q = 1\)</span>. Зауважте також, що монофрактальний часовий ряд не має відрізків з екстремально великими або малими коливаннями і, таким чином, не має піків у <code>qRMS</code>. Загальне середньоквадратичне відхилення <span class="math inline">\(q\)</span>-го порядку здатне розрізняти структуру малих і великих флуктуацій і, відповідно, монофрактальних і мультифрактальних часових рядів</figcaption>
</figure>
</div>
</div>
</div>
<p>Тепер можна визначити показники Херста <span class="math inline">\(q\)</span>-го порядку як нахили (<span class="math inline">\(h(q)\)</span>) ліній регресії для кожного середньоквадратичного значення <span class="math inline">\(q\)</span>-го порядку (<span class="math inline">\(F_{q}\)</span>). І <span class="math inline">\(h(q)\)</span>, і лінія регресії визначаються в циклі для кожного <span class="math inline">\(q\)</span>-го порядку:</p>
<div class="cell" data-execution_count="276">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_Hq(arr, scale, q, m<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.cumsum(arr <span class="op">-</span> np.mean(arr)) <span class="co"># симулюємо випадкове блукання (X)</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> X.T                           <span class="co"># транспонуємо значення X</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    scale <span class="op">=</span> scale </span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    qs <span class="op">=</span> q</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> m</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    segments <span class="op">=</span> np.zeros(<span class="bu">len</span>(scale), dtype<span class="op">=</span><span class="bu">int</span>) </span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    Fq <span class="op">=</span> np.zeros((<span class="bu">len</span>(qs), <span class="bu">len</span>(scale)))       <span class="co"># масив для збереження загальної функції флуктуацій </span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    hq <span class="op">=</span> np.zeros(<span class="bu">len</span>(qs), dtype<span class="op">=</span><span class="bu">float</span>)        <span class="co"># масив для збереження Херста q-го порядку</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    qRegLine <span class="op">=</span> {} <span class="co"># словник для збереження ліній регресій</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>    Index <span class="op">=</span> {}    <span class="co"># словник для збереження індексів сегментів ряду</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>    RMS <span class="op">=</span> {}      <span class="co"># словник локальних середньоквадратичних відхилень</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>    fit <span class="op">=</span> {}      <span class="co"># словник для збереження отриманих поліноміальних кривих</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>                  <span class="co"># для кожного сегмента</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>    qRMS <span class="op">=</span> {}     <span class="co"># словник локальних відхилень зважених показником q</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ns <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(scale)):</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>        segments[ns] <span class="op">=</span> np.floor(<span class="bu">len</span>(X) <span class="op">/</span> scale[ns]).astype(<span class="bu">int</span>)</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>        RMS[ns] <span class="op">=</span> np.zeros(segments[ns])</span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># проходимо по кожному сегменту</span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(segments[ns]): </span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>            <span class="co"># визначаємо початкове значення сегмента</span></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>            Idx_start <span class="op">=</span> v <span class="op">*</span> scale[ns]  </span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>                       </span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>            <span class="co"># визначаємо кінцеве значення</span></span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>            Idx_stop <span class="op">=</span> (v <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> scale[ns] <span class="cf">if</span> v <span class="op">&lt;</span> segments[ns] <span class="op">-</span> <span class="dv">1</span> <span class="cf">else</span> <span class="bu">len</span>(X)    </span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># формуємо масив індексів значень досліджуваного сегмента</span></span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a>            Index[v] <span class="op">=</span> np.arange(Idx_start, Idx_stop)  </span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true" tabindex="-1"></a>            <span class="co"># вилучаємо значення по індексам</span></span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true" tabindex="-1"></a>            X_Idx <span class="op">=</span> X[Index[v]]                       </span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-38"><a href="#cb33-38" aria-hidden="true" tabindex="-1"></a>            <span class="co"># визначаємо поліноміальні коефіцієнти порядку m</span></span>
<span id="cb33-39"><a href="#cb33-39" aria-hidden="true" tabindex="-1"></a>            C <span class="op">=</span> np.polyfit(Index[v], X_Idx, m) </span>
<span id="cb33-40"><a href="#cb33-40" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb33-41"><a href="#cb33-41" aria-hidden="true" tabindex="-1"></a>            <span class="co"># будуємо поліноміальну криву по визначеним коефіцієнтам</span></span>
<span id="cb33-42"><a href="#cb33-42" aria-hidden="true" tabindex="-1"></a>            fit <span class="op">=</span> np.polyval(C, Index[v])  </span>
<span id="cb33-43"><a href="#cb33-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-44"><a href="#cb33-44" aria-hidden="true" tabindex="-1"></a>            <span class="co"># оцінюємо середньоквадратичне відхилення для фрагмента v на масштабі ns </span></span>
<span id="cb33-45"><a href="#cb33-45" aria-hidden="true" tabindex="-1"></a>            RMS[ns][v] <span class="op">=</span> np.sqrt(np.mean((X_Idx <span class="op">-</span> fit) <span class="op">**</span> <span class="dv">2</span>)) </span>
<span id="cb33-46"><a href="#cb33-46" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb33-47"><a href="#cb33-47" aria-hidden="true" tabindex="-1"></a>        <span class="co"># приводимо q значення до типу float</span></span>
<span id="cb33-48"><a href="#cb33-48" aria-hidden="true" tabindex="-1"></a>        qs <span class="op">=</span> np.asarray_chkfinite(qs, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb33-49"><a href="#cb33-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-50"><a href="#cb33-50" aria-hidden="true" tabindex="-1"></a>        <span class="co"># для мультифрактальності</span></span>
<span id="cb33-51"><a href="#cb33-51" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ----------------------------</span></span>
<span id="cb33-52"><a href="#cb33-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nq, qval <span class="kw">in</span> <span class="bu">enumerate</span>(qs):</span>
<span id="cb33-53"><a href="#cb33-53" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (qval <span class="op">!=</span> <span class="fl">0.</span>): </span>
<span id="cb33-54"><a href="#cb33-54" aria-hidden="true" tabindex="-1"></a>                qRMS[nq, ns] <span class="op">=</span> RMS[ns] <span class="op">**</span> q[nq]</span>
<span id="cb33-55"><a href="#cb33-55" aria-hidden="true" tabindex="-1"></a>                Fq[nq, ns] <span class="op">=</span> np.mean(qRMS[nq, ns]) <span class="op">**</span> (<span class="dv">1</span> <span class="op">/</span> q[nq])</span>
<span id="cb33-56"><a href="#cb33-56" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb33-57"><a href="#cb33-57" aria-hidden="true" tabindex="-1"></a>                Fq[nq, ns] <span class="op">=</span> np.exp(<span class="fl">0.5</span> <span class="op">*</span> np.mean(np.log(RMS[ns] <span class="op">**</span> <span class="dv">2</span>)))</span>
<span id="cb33-58"><a href="#cb33-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-59"><a href="#cb33-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nq, _ <span class="kw">in</span> <span class="bu">enumerate</span>(qs): </span>
<span id="cb33-60"><a href="#cb33-60" aria-hidden="true" tabindex="-1"></a>            C <span class="op">=</span> np.polyfit(np.log(scale), np.log(Fq[nq, :]), m)</span>
<span id="cb33-61"><a href="#cb33-61" aria-hidden="true" tabindex="-1"></a>            hq[nq] <span class="op">=</span> C[<span class="dv">0</span>]</span>
<span id="cb33-62"><a href="#cb33-62" aria-hidden="true" tabindex="-1"></a>            qRegLine[nq] <span class="op">=</span> np.polyval(C, np.log(scale))</span>
<span id="cb33-63"><a href="#cb33-63" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ----------------------------</span></span>
<span id="cb33-64"><a href="#cb33-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-65"><a href="#cb33-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hq, qRegLine, Fq </span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="277">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>scmin <span class="op">=</span> <span class="dv">16</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>scmax <span class="op">=</span> <span class="dv">1024</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>scres <span class="op">=</span> <span class="dv">19</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>nq <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">11</span>)</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>exponents <span class="op">=</span> np.linspace(np.log(scmin), np.log(scmax), scres)</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>scales_exp <span class="op">=</span> np.<span class="bu">round</span>(np.exp(<span class="dv">1</span>)<span class="op">**</span>exponents).astype(<span class="bu">int</span>)</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>Hq_multifrac, qRegLine_multifrac, Fq_multifrac <span class="op">=</span> calc_Hq(wti_ret, scale<span class="op">=</span>scales_exp, q<span class="op">=</span>nq, m<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>Hq_monofrac, qRegLine_monofrac, Fq_monofrac <span class="op">=</span> calc_Hq(pink_noise, scale<span class="op">=</span>scales_exp, q<span class="op">=</span>nq, m<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>Hq_white_noise, qRegLine_white_noise, Fq_white_noise <span class="op">=</span> calc_Hq(white_noise, scale<span class="op">=</span>scales_exp, q<span class="op">=</span>nq, m<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="279">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">10</span>))</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>][<span class="dv">0</span>].set_title(<span class="st">"Мультифрактал"</span>)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>][<span class="dv">0</span>].set_xlabel(<span class="vs">r"$ns$"</span>)</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>][<span class="dv">0</span>].set_ylabel(<span class="vs">r"$F_</span><span class="sc">{q}</span><span class="vs">(ns)$"</span>)</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>][<span class="dv">0</span>].set_xscale(<span class="st">'log'</span>)</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>][<span class="dv">0</span>].set_yscale(<span class="st">'log'</span>)</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(nq)):</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>][<span class="dv">0</span>].scatter(scales_exp, Fq_multifrac[i, :], color<span class="op">=</span><span class="st">'darkblue'</span>)</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>][<span class="dv">0</span>].plot(scales_exp, np.exp(qRegLine_multifrac[i]),  color<span class="op">=</span><span class="st">'darkblue'</span>)</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>][<span class="dv">1</span>].set_title(<span class="st">"Монофрактал"</span>)</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>][<span class="dv">1</span>].set_xlabel(<span class="vs">r"$ns$"</span>)</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>][<span class="dv">1</span>].set_xscale(<span class="st">'log'</span>)</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>][<span class="dv">1</span>].set_yscale(<span class="st">'log'</span>)</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(nq)):</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>][<span class="dv">1</span>].scatter(scales_exp, Fq_monofrac[i, :], color<span class="op">=</span><span class="st">'magenta'</span>)</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>][<span class="dv">1</span>].plot(scales_exp, np.exp(qRegLine_monofrac[i]),  color<span class="op">=</span><span class="st">'magenta'</span>)</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>][<span class="dv">0</span>].set_title(<span class="st">"Білий шум"</span>)</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>][<span class="dv">0</span>].set_xlabel(<span class="vs">r"$ns$"</span>)</span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>][<span class="dv">0</span>].set_ylabel(<span class="vs">r"$F_</span><span class="sc">{q}</span><span class="vs">(ns)$"</span>)</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>][<span class="dv">0</span>].set_xscale(<span class="st">'log'</span>)</span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>][<span class="dv">0</span>].set_yscale(<span class="st">'log'</span>)</span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(nq)):</span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>][<span class="dv">0</span>].scatter(scales_exp, Fq_white_noise[i, :], color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>][<span class="dv">0</span>].plot(scales_exp, np.exp(qRegLine_white_noise[i]),  color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>][<span class="dv">1</span>].set_title(<span class="vs">r"Показники Херста $q$-го порядку"</span>)</span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>][<span class="dv">1</span>].set_xlabel(<span class="vs">r"$q$"</span>)</span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>][<span class="dv">1</span>].set_ylabel(<span class="vs">r"$h(q)$"</span>)</span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>][<span class="dv">1</span>].plot(nq, Hq_multifrac, linestyle<span class="op">=</span><span class="st">'-'</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"Мультифрактал"</span>, color<span class="op">=</span><span class="st">'darkblue'</span>)</span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>][<span class="dv">1</span>].plot(nq, Hq_monofrac,linestyle<span class="op">=</span><span class="st">'-'</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"Монофрактал"</span>, color<span class="op">=</span><span class="st">'magenta'</span>)</span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>][<span class="dv">1</span>].plot(nq, Hq_white_noise, linestyle<span class="op">=</span><span class="st">'-'</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"Білий шум"</span>, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>][<span class="dv">1</span>].legend()</span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a>plt.show()<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-step8" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="lab_7_files/figure-html/fig-step8-output-1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;8.13: Середньоквадратичні значення <span class="math inline">\(F_{q}\)</span> для різних <span class="math inline">\(q\)</span>-их порядків та відповідні лінії регресії обчислені за допомогою MFDFA для мультифракталу, монофракталу та білого шуму</figcaption>
</figure>
</div>
</div>
</div>
<p>Можемо бачити, що узагальнена функція флуктуацій для мультифракталу залежить не лише від масштабу, але й від <span class="math inline">\(q\)</span>, що демонструють різні нахили ліній регресії <span class="math inline">\(h(q)\)</span>. Масштабуючі узагальнені функції флуктуацій <span class="math inline">\(F_{q}\)</span> для монофракталу та білого шуму є <span class="math inline">\(q\)</span>-незалежними, оскільки їх лінії регресії для різних масштабів мають один і той самий кут нахилу. Показник Херста <span class="math inline">\(q\)</span>-го порядку <span class="math inline">\(h(q)\)</span> для мультифрактального (синя лінія) ряду представляється незалежним для <span class="math inline">\(q&lt;0\)</span> і змінним для <span class="math inline">\(q&gt;0\)</span>. Це вказує на те, що джерелом мультифрактальності нафти є аномально великі флуктуацій як, наприклад, криза коронавірусної пандемії. Для монофракталу (рожева лінія) та білого шуму (червона лінія) <span class="math inline">\(h(q)\)</span> залишаються сталими.</p>
</section>
<section id="мультифрактальний-спектр-часових-рядів" class="level4" data-number="8.1.4.7">
<h4 data-number="8.1.4.7" class="anchored" data-anchor-id="мультифрактальний-спектр-часових-рядів"><span class="header-section-number">8.1.4.7</span> Мультифрактальний спектр часових рядів</h4>
<p>Показник Херста <span class="math inline">\(q\)</span>-го порядку <span class="math inline">\(h(q)\)</span> є лише одним з декількох типів масштабних показників, що використовуються для параметризації мультифрактальної структури часових рядів. Як уже було представлено попередньо, ми можемо вивести показник маси <span class="math inline">\(q\)</span>-го порядку (<span class="math inline">\(\tau(q)\)</span>), а потім через <span class="math inline">\(\tau(q)\)</span> отримати показник сингулярності <span class="math inline">\(q\)</span>-го порядку (<span class="math inline">\(\alpha(q)\)</span>) і фрактальну розмірність (<span class="math inline">\(f(\alpha)\)</span>) флуктуацій (областей) із ступенем сингулярності <span class="math inline">\(\alpha(q)\)</span>. Графік залежності <span class="math inline">\(\alpha(q)\)</span> від <span class="math inline">\(f(\alpha)\)</span> представляє мультифрактальний спектр. Показники маси, сингулярності та фрактальності можна обчислити згідно коду, що наведений нижче:</p>
<div class="cell" data-execution_count="312">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>tau_multifrac <span class="op">=</span> nq <span class="op">*</span> Hq_multifrac <span class="op">-</span> <span class="dv">1</span> </span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>tau_monofrac <span class="op">=</span> nq <span class="op">*</span> Hq_monofrac <span class="op">-</span> <span class="dv">1</span> </span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>tau_white_noise <span class="op">=</span> nq <span class="op">*</span> Hq_white_noise <span class="op">-</span> <span class="dv">1</span> </span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>alpha_multifrac <span class="op">=</span> np.gradient(tau_multifrac, nq)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>alpha_monofrac <span class="op">=</span> np.gradient(tau_monofrac, nq)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>alpha_white_noise <span class="op">=</span> np.gradient(tau_white_noise, nq)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>f_multifrac <span class="op">=</span> nq <span class="op">*</span> alpha_multifrac <span class="op">-</span> tau_multifrac</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>f_monofrac <span class="op">=</span> nq <span class="op">*</span> alpha_monofrac <span class="op">-</span> tau_monofrac</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>f_white_noise <span class="op">=</span> nq <span class="op">*</span> alpha_white_noise <span class="op">-</span> tau_white_noise</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="323">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$q$"</span>)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="vs">r"$\tau(q)$"</span>)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(nq, tau_multifrac, linestyle<span class="op">=</span><span class="st">'-'</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"Мультифрактал"</span>, color<span class="op">=</span><span class="st">'darkblue'</span>)</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(nq, tau_monofrac, linestyle<span class="op">=</span><span class="st">'-'</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"Монофрактал"</span>, color<span class="op">=</span><span class="st">'magenta'</span>)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(nq, tau_white_noise, linestyle<span class="op">=</span><span class="st">'-'</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"Білий шум"</span>, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].legend()</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\alpha$"</span>)</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="vs">r"$f(\alpha)$"</span>)</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(alpha_multifrac, f_multifrac, linestyle<span class="op">=</span><span class="st">'-'</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"Мультифрактал"</span>, color<span class="op">=</span><span class="st">'darkblue'</span>)</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(alpha_monofrac, f_monofrac, linestyle<span class="op">=</span><span class="st">'-'</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"Монофрактал"</span>, color<span class="op">=</span><span class="st">'magenta'</span>)</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(alpha_white_noise, f_white_noise, linestyle<span class="op">=</span><span class="st">'-'</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"Білий шум"</span>, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_xlabel(<span class="vs">r"$q$"</span>)</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].set_ylabel(<span class="vs">r"$f(\alpha)$"</span>)</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(nq, f_multifrac, linestyle<span class="op">=</span><span class="st">'-'</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"Мультифрактал"</span>, color<span class="op">=</span><span class="st">'darkblue'</span>)</span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(nq, f_monofrac, linestyle<span class="op">=</span><span class="st">'-'</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"Монофрактал"</span>, color<span class="op">=</span><span class="st">'magenta'</span>)</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>].plot(nq, f_white_noise, linestyle<span class="op">=</span><span class="st">'-'</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"Білий шум"</span>, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>fig.tight_layout(pad<span class="op">=</span><span class="fl">0.3</span>) </span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>plt.show()<span class="op">;</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-step9" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="lab_7_files/figure-html/fig-step9-output-1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;8.14: Множинне представляння мультифрактального спектру для мультифрактала, монофрактала та білого шуму</figcaption>
</figure>
</div>
</div>
</div>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Скопійовано!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Скопійовано!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation column-body">
  <div class="nav-page nav-page-previous">
      <a href="./lab_6.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Лабораторна робота № 6</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./lab_11.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Лабораторна робота № 11</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>